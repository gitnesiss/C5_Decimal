#include "s21_decimal.h"
#include <stdio.h>
#include <stdlib.h>
#include <limits.h>
#include <string.h>

#define VALUE_TRUE 1
#define VALUE_FALSE 0
#define VALUE_OK 0
#define VALUE_ERROR 1
#define VALUE_INF 1
#define VALUE_MINUS_INF 2
#define VALUE_NAN 3


#test S21_ADD
    //            + |  0.000000  1.000000 -1.000000       inf      -inf      -nan
    //   -------------------------------------------------------------------------
    //     0.000000 |  0.000000  1.000000 -1.000000       inf      -inf      -nan
    //     1.000000 |  1.000000  2.000000  0.000000       inf      -inf      -nan
    //    -1.000000 | -1.000000  0.000000 -2.000000       inf      -inf      -nan
    //          inf |       inf       inf       inf       inf      -nan      -nan
    //         -inf |      -inf      -inf      -inf      -nan      -inf      -nan
    //         -nan |      -nan      -nan      -nan      -nan      -nan      -nan
    s21_decimal result = {{0}};  
    s21_decimal value_09 = {{1, 0, 0, 0x80000000}};                             // -1
    s21_decimal value_10 = {{0, 0, 0, 0x80000000}};                             // -0
    s21_decimal value_11 = {{0, 0, 0, 0x00000000}};                             //  0
    s21_decimal value_12 = {{1, 0, 0, 0x00000000}};                             //  1
    s21_decimal value_24 = {{254, 0, 0, 0x00000000}};                           //  254
    s21_decimal correct_answer_01 = {{0, 0, 0, 0x00000000}};                    //  -0 + 0 = 0
    s21_decimal correct_answer_02 = {{255, 0, 0, 0x00000000}};                  //  1 + 254 = 255
    s21_decimal correct_answer_03 = {{1, 0, 0, 0x00000000}};                    //  0 + 1 = 1
    decimal_reset(&result);
    s21_add(value_10, value_11, &result);                                     // -0 + 0 = 0
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_01.bits[i]);
    }
    decimal_reset(&result);
    s21_add(value_12, value_24, &result);                                     // 1 + 254 = 255
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_02.bits[i]);
    }
    decimal_reset(&result);
    s21_add(value_11, value_12, &result);                                     // 0 + 1 = 1
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_03.bits[i]);
    }
    decimal_reset(&result);
    s21_add(value_12, value_11, &result);                                     // 1 + 0 = 1
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_03.bits[i]);
    }
    decimal_reset(&result);
    s21_add(value_09, value_12, &result);                                     // -1 + 1 = 0
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], value_11.bits[i]);
    }
#test S21_ADD_ADDITION_01
    s21_decimal result = {{0}};
    s21_decimal value_09 = {{1, 0, 0, 0x80000000}};                             // -1
    s21_decimal value_11 = {{0, 0, 0, 0x00000000}};                             //  0
    s21_decimal value_12 = {{1, 0, 0, 0x00000000}};                             //  1
    s21_decimal value_29 = {{200, 0, 0, 0x80020000}};                           // -2,00
    s21_decimal value_30 = {{10, 0, 0, 0x80010000}};                            // -1,0
    s21_decimal value_25 = {{200, 0, 0, 0x00020000}};                           //  2,00
    s21_decimal value_26 = {{10, 0, 0, 0x00010000}};                            //  1,0
    s21_decimal correct_answer_04 = {{300, 0, 0, 0x00020000}};                  //  2,00 + 1,0 = 3
    s21_decimal correct_answer_05 = {{2, 0, 0, 0x80000000}};                    //  -1 - -1 = -2
    s21_decimal correct_answer_06 = {{300, 0, 0, 0x80020000}};                  //  -2,00 + -1,0 = 3
    decimal_reset(&result);
    s21_add(value_12, value_09, &result);                                     // 1 + -1 = 0
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], value_11.bits[i]);
    }
    decimal_reset(&result);
    s21_add(value_09, value_09, &result);                                     // -1 + -1 = -2
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_05.bits[i]);
    }
    decimal_reset(&result);
    s21_add(value_29, value_30, &result);                                     // -2,00 + -1,0 = -3,00
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_06.bits[i]);
    }
    decimal_reset(&result);
    s21_add(value_25, value_26, &result);                                     // 2,00 + 1,0 = 3,00
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_04.bits[i]);
    }
    decimal_reset(&result);
    s21_add(value_26, value_25, &result);                                     // 1,0 + 2,00 = 3,00
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_04.bits[i]);
    }
#test S21_ADD_ADDITION_02
    s21_decimal result = {{0}};
    s21_decimal value_12 = {{1, 0, 0, 0x00000000}};                             //  1
    s21_decimal value_20 = {{4294967295, 4294967295, 4294967295, 0x00000000}};  //  79 228 162 514 264 337 593 543 950 335
    s21_decimal value_22 = {{0, 0, 0, 0x00FF0000}};                             // +INF
    s21_decimal value_25 = {{200, 0, 0, 0x00020000}};                           //  2,00
    s21_decimal value_26 = {{10, 0, 0, 0x00010000}};                            //  1,0
    s21_decimal value_27 = {{0, 0, 4278190080, 0x00020000}};                    //  78 918 677 504 442 992 524 819 169 2,80
    s21_decimal value_28 = {{4294967295, 4294967295, 4294967295, 0x00150000}};  //  79 228 162, 514 264 337 593 543 950 335
    s21_decimal value_29 = {{200, 0, 0, 0x80020000}};                           // -2,00
    s21_decimal value_30 = {{10, 0, 0, 0x80010000}};                            // -1,0
    s21_decimal correct_answer_09 = {{100, 0, 0, 0x00020000}};                  //  1,00
    s21_decimal correct_answer_10 = {{100, 0, 0, 0x80020000}};                   //  1,00
    s21_decimal correct_answer_10_1 = {{3627848955, 1, 4278190080, 0x00020000}};          //  789 186 775 044 429 925 327 419 855.31
    decimal_reset(&result);
    s21_add(value_25, value_30, &result);                                     // 2,00 + -1,0 = 1,00
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_09.bits[i]);
    }
    decimal_reset(&result);
    s21_add(value_29, value_26, &result);                                     // -2,00 + 1,0 = -1,00
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_10.bits[i]);
    }
    decimal_reset(&result);
    s21_add(value_27, value_28, &result);                                     // 78 918 677 504 442 992 524 819 169 2,80  +  79 228 162, 514 264 337 593 543 950 335 = 789186775044429925327419855.31 00000000 00000000 00000001  11011000 00111100 10010100 11111011
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_10_1.bits[i]);
    }
    decimal_reset(&result);
    s21_add(value_28, value_27, &result);                                     // 79 228 162, 514 264 337 593 543 950 335  +  78 918 677 504 442 992 524 819 169 2,80 = 789 186 775 044 429 925 327 419 855.31
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_10_1.bits[i]);
    }
    decimal_reset(&result);
    s21_add(value_20, value_12, &result);                                     // 79 228 162 514 264 337 593 543 950 335  +  1 = +INF
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], value_22.bits[i]);
    }
#test S21_ADD_ADDITION_03
    s21_decimal result = {{0}};  
    s21_decimal value_01 = {{4294967295, 4294967295, 4294967295, 0x80000000}};  // -79 228 162 514 264 337 593 543 950 335
    s21_decimal value_09 = {{1, 0, 0, 0x80000000}};                             // -1
    s21_decimal value_12 = {{1, 0, 0, 0x00000000}};                             //  1
    s21_decimal value_21 = {{0, 0, 0, 0x80FF0000}};                             // -INF
    s21_decimal value_22 = {{0, 0, 0, 0x00FF0000}};                             // +INF
    s21_decimal value_31 = {{4294967295, 4294967295, 536870911, 0x001B0000}};  //  9, 903 520 314 283 042 199 192 993 791
    s21_decimal value_32 = {{108903, 0, 0, 0x00010000}};                        //  108 90,3
    s21_decimal value_33 = {{1, 0, 0, 0x801C0000}};                             // -0,0 000 000 000 000 000 000 000 000 001
    s21_decimal value_34 = {{1, 0, 0, 0x001C0000}};                             //  0,0 000 000 000 000 000 000 000 000 001
    s21_decimal correct_answer_07 = {{2, 0, 0, 0x001C0000}};                    //  0,0 000 000 000 000 000 000 000 000 002
    s21_decimal correct_answer_08 = {{0, 0, 0, 0x00000000}};                    //  0,0 000 000 000 000 000 000 000 000 002
    s21_decimal correct_answer_10_2 = {{2704688546, 3706318177, 590901216, 0x00180000}};
    decimal_reset(&result);
    s21_add(value_01, value_09, &result);                                     // -79 228 162 514 264 337 593 543 950 335  - 1  = -INF
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], value_21.bits[i]);
    }
    decimal_reset(&result);
    s21_add(value_31, value_32, &result);                                     // 9, 903 520 314 283 042 199 192 993 791 + 10 890,3 = 10 900.203 520 314 283 042 199 192 994 = 000100011 00111000 01101111 11100000  11011100 11101001 11101101 01100001  10100001 00110110 01000101 10100010
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_10_2.bits[i]);
    }
    decimal_reset(&result);
    s21_add(value_34, value_34, &result);                                     // 0,0 000 000 000 000 000 000 000 000 001 + 0,0 000 000 000 000 000 000 000 000 001 = 0,0 000 000 000 000 000 000 000 000 002
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_07.bits[i]);
    }
    decimal_reset(&result);
    s21_add(value_34, value_33, &result);                                     // 0,0 000 000 000 000 000 000 000 000 001 + -0,0 000 000 000 000 000 000 000 000 001 = 0,0 000 000 000 000 000 000 000 000 000
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_08.bits[i]);
    }
    decimal_reset(&result);
    s21_add(value_22, value_12, &result);                                     //  INF + 1 = INF
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], value_22.bits[i]);
    }
#test S21_ADD_ADDITION_04
    s21_decimal result = {{0}}; 
    s21_decimal value_12 = {{1, 0, 0, 0x00000000}};                             //  1
    s21_decimal value_21 = {{0, 0, 0, 0x80FF0000}};                             // -INF
    s21_decimal value_22 = {{0, 0, 0, 0x00FF0000}};                             // +INF
    s21_decimal value_23 = {{1431655765, 1431655765, 1431655765, 0x80FF0000}};  //  NaN (диапазон от (-1)*10^(-28) до (1)*10^(-28), но !=0)
    decimal_reset(&result);
    s21_add(value_22, value_22, &result);                                     //  INF + INF = INF
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], value_22.bits[i]);
    }
    decimal_reset(&result);
    s21_add(value_22, value_21, &result);                                     //  INF + -INF = -NAN
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], value_23.bits[i]);
    }
    decimal_reset(&result);
    s21_add(value_22, value_21, &result);                                     //  INF + NAN = -NAN
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], value_23.bits[i]);
    }
    decimal_reset(&result);
    s21_add(value_12, value_21, &result);                                     //  -INF + 1 = INF
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], value_21.bits[i]);
    }
    decimal_reset(&result);
    s21_add(value_21, value_12, &result);                                     //  -INF + 1 = INF
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], value_21.bits[i]);
    }
#test S21_ADD_ADDITION_05
    s21_decimal result = {{0}};
    s21_decimal value_12 = {{1, 0, 0, 0x00000000}};                             //  1
    s21_decimal value_21 = {{0, 0, 0, 0x80FF0000}};                             // -INF
    s21_decimal value_22 = {{0, 0, 0, 0x00FF0000}};                             // +INF
    s21_decimal value_23 = {{1431655765, 1431655765, 1431655765, 0x80FF0000}};  //  NaN (диапазон от (-1)*10^(-28) до (1)*10^(-28), но !=0)
    decimal_reset(&result);
    s21_add(value_21, value_22, &result);                                     //  -INF + INF = -NAN
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], value_23.bits[i]);
    }
    decimal_reset(&result);
    s21_add(value_21, value_21, &result);                                     //  -INF + -INF = -INF
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], value_21.bits[i]);
    }
    decimal_reset(&result);
    s21_add(value_21, value_23, &result);                                     //  -INF + NAN = -NAN
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], value_23.bits[i]);
    }
    decimal_reset(&result);
    s21_add(value_23, value_12, &result);                                     //  -NAN + 1 = -NAN
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], value_23.bits[i]);
    }
    decimal_reset(&result);
    s21_add(value_23, value_22, &result);                                     //  -NAN + INF = -NAN
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], value_23.bits[i]);
    }
#test S21_ADD_ADDITION_06
    s21_decimal result = {{0}};
    s21_decimal value_12 = {{1, 0, 0, 0x00000000}};                             //  1
    s21_decimal value_21 = {{0, 0, 0, 0x80FF0000}};                             // -INF
    s21_decimal value_22 = {{0, 0, 0, 0x00FF0000}};                             // +INF
    s21_decimal value_23 = {{1431655765, 1431655765, 1431655765, 0x80FF0000}};  //  NaN (диапазон от (-1)*10^(-28) до (1)*10^(-28), но !=0)
    decimal_reset(&result);
    s21_add(value_23, value_21, &result);                                     //  -NAN + -INF = -NAN
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], value_23.bits[i]);
    }
    decimal_reset(&result);
    s21_add(value_23, value_23, &result);                                     //  -NAN + NAN = -NAN
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], value_23.bits[i]);
    }
    decimal_reset(&result);
    s21_add(value_12, value_21, &result);                                     //  1 + -INF = -INF
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], value_21.bits[i]);
    }
    decimal_reset(&result);
    s21_add(value_12, value_22, &result);                                     //  1 + INF = INF
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], value_22.bits[i]);
    }
    decimal_reset(&result);
    s21_add(value_12, value_21, &result);                                     //  1 + -NAN = -NAN
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], value_21.bits[i]);
    }
#test S21_ADD_ADDITION_07
    s21_decimal result = {{0}};  
    s21_decimal value_70 = {{0, 0, 0, 0x00000000}};
    s21_decimal value_71 = {{0, 0, 0, 0x00000000}};
    decimal_reset(&result);
    s21_add(value_70, value_71, &result);
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], value_70.bits[i]);
    }
    s21_decimal value_72 = {{542000, 0, 0, 0x00030000}};
    s21_decimal value_73 = {{24500, 0, 0, 0x80020000}};
    s21_decimal correct_answer_72 = {{297000, 0, 0, 0x00030000}};
    decimal_reset(&result);
    s21_add(value_72, value_73, &result);
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_72.bits[i]);
    }
#test S21_ADD_ADDITION_08
    s21_decimal result = {{0}};
    s21_decimal value_74 = {{542000, 0, 0, 0x80030000}};
    s21_decimal value_75 = {{24500, 0, 0, 0x00020000}};
    s21_decimal correct_answer_73 = {{297000, 0, 0, 0x80030000}};
    decimal_reset(&result);
    s21_add(value_74, value_75, &result);
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_73.bits[i]);
    }
    s21_decimal value_76 = {{24500, 0, 0, 0x80020000}};
    s21_decimal value_77 = {{542000, 0, 0, 0x00030000}};
    s21_decimal correct_answer_74 = {{297000, 0, 0, 0x00030000}};
    decimal_reset(&result);
    s21_add(value_76, value_77, &result);
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_74.bits[i]);
    }
#test S21_ADD_ADDITION_09
    s21_decimal result = {{0}};
    s21_decimal value_78 = {{24500, 0, 0, 0x00020000}};
    s21_decimal value_79 = {{542000, 0, 0, 0x80030000}};
    s21_decimal correct_answer_75 = {{297000, 0, 0, 0x80030000}};
    decimal_reset(&result);
    s21_add(value_78, value_79, &result);
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_75.bits[i]);
    }
    s21_decimal value_35 = {{3406640011, 4061021864, 101847910, 0x001C0000}};          //  0.1 878 762 347 654 159 876 754 322 315  =      110 00010010 00010011 01100110  11110010 00001110 01000110 10101000  11001011 00001101 00110011 10001011
    s21_decimal value_36 = {{9, 0, 0, 0x00000000}};                                    //  9
    s21_decimal correct_answer_11 = {{2729739560, 3062440654, 498075768, 0x001B0000}}; //  9.187 876 234 765 415 987 675 432 232    =    11101 10110000 00001000 01111000  10110110 10001001 00100010 11001110  10100010 10110100 10000101 00101000
    decimal_reset(&result);
    s21_add(value_35, value_36, &result);
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_11.bits[i]);
    }
#test S21_ADD_ADDITION_10
    s21_decimal result = {{0}};
    s21_decimal value_37 = {{3406640011, 4061021864, 101847910, 0x001C0000}};          //  0.1 878 762 347 654 159 876 754 322 315  =      110 00010010 00010011 01100110  11110010 00001110 01000110 10101000  11001011 00001101 00110011 10001011
    s21_decimal value_38 = {{4, 0, 0, 0x00000000}};                                    //  4
    s21_decimal correct_answer_12 = {{185414539, 3936505901, 2270252255, 0x001C0000}}; //  4.1 878 762 347 654 159 876 754 322 315  = 10000111 01010001 01001100 11011111  11101010 10100010 01010000 00101101  00001011 00001101 00110011 10001011
    decimal_reset(&result);
    s21_add(value_37, value_38, &result);
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_12.bits[i]);
    }
    s21_decimal value_39 = {{3406640011, 4061021864, 101847910, 0x001C0000}};          //  0.1 878 762 347 654 159 876 754 322 315  =      110 00010010 00010011 01100110  11110010 00001110 01000110 10101000  11001011 00001101 00110011 10001011
    s21_decimal value_40 = {{9351118, 0, 0, 0x00000000}};                              //  9 351 118                                =
    s21_decimal correct_answer_13 = {{927185371, 3106147652, 506925132, 0x00150000}};  //  9 351 118. 187 876 234 765 415 987 675   = 00011110 00110111 00010000 01001100  10111001 00100100 00001101 01000100  00110111 01000011 10111001 11011011
    decimal_reset(&result);
    s21_add(value_39, value_40, &result);
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_13.bits[i]);
    }
#test S21_ADD_ADDITION_11
    s21_decimal result = {{0}};
    s21_decimal value_41 = {{3406640011, 4061021864, 101847910, 0x001C0000}};          //  0.1 878 762 347 654 159 876 754 322 315  =      110 00010010 00010011 01100110  11110010 00001110 01000110 10101000  11001011 00001101 00110011 10001011
    s21_decimal value_42 = {{1626524789, 1028356652, 87887469, 0x001C0000}};           //  0.1 621 237 652 345 840 123 245 677 685  =      101 00111101 00001110 01101101  00111101 01001011 01111010 00101100  01100000 11110010 11001100 01110101
    s21_decimal correct_answer_14 = {{738197504, 794411221, 189735380, 0x001C0000}};                         //  0.3 500 000 000 000 000 000 000 000 000  =     1011 01001111 00100001 11010100  00101111 01011001 11000000 11010101  00101100 00000000 00000000 00000000
    decimal_reset(&result);
    s21_add(value_41, value_42, &result);
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_14.bits[i]);
    }
    s21_decimal value_43 = {{4294967295, 4294967295, 4294967295, 0x00000000}};         //  79 228 162 514 264 337 593 543 950 335   = 11111111 11111111 11111111 11111111  11111111 11111111 11111111 11111111  11111111 11111111 11111111 11111111
    s21_decimal value_44 = {{1626524789, 1028356652, 87887469, 0x001C0000}};           //  0.1 621 237 652 345 840 123 245 677 685  =      101 00111101 00001110 01101101  00111101 01001011 01111010 00101100  01100000 11110010 11001100 01110101
    s21_decimal correct_answer_15 = {{4294967295, 4294967295, 4294967295, 0x00000000}};//  79 228 162 514 264 337 593 543 950 335   = 11111111 11111111 11111111 11111111  11111111 11111111 11111111 11111111  11111111 11111111 11111111 11111111
    decimal_reset(&result);
    s21_add(value_43, value_44, &result);
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_15.bits[i]);
    }
#test S21_ADD_ADDITION_12
    s21_decimal result = {{0}};
    s21_decimal value_45 = {{4294967295, 4294967295, 4294967295, 0x00000000}};         //  79 228 162 514 264 337 593 543 950 335   = 11111111 11111111 11111111 11111111  11111111 11111111 11111111 11111111  11111111 11111111 11111111 11111111
    s21_decimal value_46 = {{2364722293, 1822767873, 277622849, 0x001C0000}};          //  0.5 121 237 652 345 840 123 245 677 685  =    10000 10001100 00110000 01000001  01101100 10100101 00111011 00000001  10001100 11110010 11001100 01110101
    s21_decimal correct_answer_16 = {{0, 0, 0, 0x00FF0000}};                           //  +INF
    decimal_reset(&result);
    s21_add(value_45, value_46, &result);
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_16.bits[i]);
    }
    s21_decimal value_47 = {{35, 0, 0, 0x00020000}};                                   //  0,35
    s21_decimal value_48 = {{555, 0, 0, 0x00000000}};                                  //  555
    s21_decimal correct_answer_17 = {{55535, 0, 0, 0x00020000}};                       //  555,35
    decimal_reset(&result);
    s21_add(value_47, value_48, &result);
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_17.bits[i]);
    }
#test S21_ADD_ADDITION_13
    s21_decimal result = {{0}};
    s21_decimal value_49 = {{4294967295, 4294967295, 4294967295, 0x00000000}};         //  79 228 162 514 264 337 593 543 950 335   = 11111111 11111111 11111111 11111111  11111111 11111111 11111111 11111111  11111111 11111111 11111111 11111111
    s21_decimal value_50 = {{49, 0, 0, 0x00020000}};                                   //  0.49                                     = 00000000 00000000 00000000 00000000  00000000 00000000 00000000 00000000  00000000 00000000 00000000 00110001
    s21_decimal correct_answer_18 = {{4294967295, 4294967295, 4294967295, 0x00000000}};//  79 228 162 514 264 337 593 543 950 335   = 11111111 11111111 11111111 11111111  11111111 11111111 11111111 11111111  11111111 11111111 11111111 11111111
    decimal_reset(&result);
    s21_add(value_49, value_50, &result);
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_18.bits[i]);
    } 
    s21_decimal value_51 = {{4294967295, 4294967295, 4294967295, 0x00000000}};         //  79 228 162 514 264 337 593 543 950 335   = 11111111 11111111 11111111 11111111  11111111 11111111 11111111 11111111  11111111 11111111 11111111 11111111
    s21_decimal value_52 = {{50, 0, 0, 0x00020000}};                                   //  0.50                                     = 00000000 00000000 00000000 00000000  00000000 00000000 00000000 00000000  00000000 00000000 00000000 00110001
    s21_decimal correct_answer_19 = {{0, 0, 0, 0x00FF0000}};                           //  +INF
    decimal_reset(&result);
    s21_add(value_51, value_52, &result);
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_19.bits[i]);
    }
#test S21_ADD_ADDITION_14
    s21_decimal result = {{0}};
    s21_decimal value_53 = {{2550136832, 1364693707, 4282598581, 0x00020000}};         //  79 000 000 000 000 000 000 000 000 0.00  = 11111111 01000011 01000100 10110101  01010001 01010111 10010010 11001011  10011000 00000000 00000000 00000000
    s21_decimal value_54 = {{1744830883, 2930273588, 12368714, 0x00020000}};           //     228 162 514 264 337 593 543 950 7.55  = 00000000 10111100 10111011 01001010  10101110 10101000 01101101 00110100  01101000 00000000 00000001 10100011
    s21_decimal correct_answer_20 = {{2576980420, 2576980377, 429496729, 0x00010000}}; //   7 922 816 251 426 433 759 354 395 07.6  = 00011001 10011001 10011001 10011001  10011001 10011001 10011001 10011001  10011001 10011001 10011001 11000100
    decimal_reset(&result);
    s21_add(value_53, value_54, &result);
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_20.bits[i]);
    }



#test S21_DIV
    //          / |  0.000000  1.000000 -1.000000       inf      -inf      -nan
    // -------------------------------------------------------------------------
    //   0.000000 |      -nan  0.000000 -0.000000  0.000000 -0.000000      -nan
    //   1.000000 |       inf  1.000000 -1.000000  0.000000 -0.000000      -nan
    //  -1.000000 |      -inf -1.000000  1.000000 -0.000000  0.000000      -nan
    //        inf |       inf       inf      -inf      -nan      -nan      -nan
    //       -inf |      -inf      -inf       inf      -nan      -nan      -nan
    //       -nan |      -nan      -nan      -nan      -nan      -nan      -nan
    s21_decimal result = {{0}};  
    s21_decimal value_01 = {{4294967295, 4294967295, 4294967295, 0x80000000}};  // -79 228 162 514 264 337 593 543 950 335
    s21_decimal value_08 = {{2147483647, 0, 0, 0x80000000}};                    // -2 147 483 647
    s21_decimal value_09 = {{1, 0, 0, 0x80000000}};                             // -1
    s21_decimal value_10 = {{0, 0, 0, 0x80000000}};                             // -0
    s21_decimal value_11 = {{0, 0, 0, 0x00000000}};                             //  0
    s21_decimal value_12 = {{1, 0, 0, 0x00000000}};                             //  1
    s21_decimal value_13 = {{2147483647, 0, 0, 0}};                             //  2 147 483 647
    s21_decimal value_20 = {{4294967295, 4294967295, 4294967295, 0x00000000}};  //  79 228 162 514 264 337 593 543 950 335
    s21_decimal value_21 = {{0, 0, 0, 0x80FF0000}};                             // -INF
    s21_decimal value_22 = {{0, 0, 0, 0x00FF0000}};                             // +INF
    s21_decimal value_23 = {{1431655765, 1431655765, 1431655765, 0x80FF0000}};  //  NaN (диапазон от (-1)*10^(-28) до (1)*10^(-28), но !=0)
    decimal_reset(&result);
    s21_div(value_11, value_11, &result);                                     //  0 / 0 = -NAN
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], value_23.bits[i]);
    }
    decimal_reset(&result);
    s21_div(value_10, value_11, &result);                                     // -0 / 0 = -NAN
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], value_23.bits[i]);
    }
    decimal_reset(&result);
    s21_div(value_11, value_10, &result);                                     //  0 / -0 = -NAN
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], value_23.bits[i]);
    }
    decimal_reset(&result);
    s21_div(value_13, value_11, &result);                                     //  2 147 483 647 / 0 = +INF
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], value_22.bits[i]);
    }
    decimal_reset(&result);
    s21_div(value_20, value_11, &result);                                     //  79 228 162 514 264 337 593 543 950 335 / 0 = +INF
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], value_22.bits[i]);
    }
    decimal_reset(&result);
    s21_div(value_01, value_11, &result);                                     // -79 228 162 514 264 337 593 543 950 335 / 0 = -INF
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], value_21.bits[i]);
    }
    decimal_reset(&result);
    s21_div(value_22, value_11, &result);                                     // +INF / 0 = +INF
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], value_22.bits[i]);
    }
    decimal_reset(&result);
    s21_div(value_22, value_12, &result);                                     // +INF / 1 = +INF
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], value_22.bits[i]);
    }
    decimal_reset(&result);
    s21_div(value_22, value_09, &result);                                     // +INF / -1 = -INF
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], value_21.bits[i]);
    }
    decimal_reset(&result);
    s21_div(value_22, value_22, &result);                                     // +INF / +INF = -NAN
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], value_23.bits[i]);
    }
    decimal_reset(&result);
    s21_div(value_22, value_21, &result);                                     // +INF / -INF = -NAN
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], value_23.bits[i]);
    }
    decimal_reset(&result);
    s21_div(value_21, value_10, &result);                                     // -INF / -0 = -INF
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], value_21.bits[i]);
    }
    decimal_reset(&result);
    s21_div(value_21, value_12, &result);                                     // -INF / 1 = -INF
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], value_21.bits[i]);
    }
    decimal_reset(&result);
    s21_div(value_21, value_09, &result);                                     // -INF / -1 = +INF
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], value_22.bits[i]);
    }
    decimal_reset(&result);
    s21_div(value_21, value_22, &result);                                     // -INF / +INF = -NAN
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], value_23.bits[i]);
    }
    decimal_reset(&result);
    s21_div(value_21, value_21, &result);                                     // -INF / -INF = -NAN
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], value_23.bits[i]);
    }
    decimal_reset(&result);
    s21_div(value_23, value_13, &result);                                     // -NAN / 2 147 483 647 = -NAN
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], value_23.bits[i]);
    }
    decimal_reset(&result);
    s21_div(value_11, value_13, &result);                                     //  0 / 2 147 483 647 = 0
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], value_11.bits[i]);
    }
    decimal_reset(&result);
    s21_div(value_11, value_08, &result);                                     //  0 / -2 147 483 647 = -0
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], value_10.bits[i]);
    }
    decimal_reset(&result);
    s21_div(value_11, value_22, &result);                                     //  0 / +INF = 0
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], value_11.bits[i]);
    }
    decimal_reset(&result);
    s21_div(value_11, value_21, &result);                                     //  0 / -INF = -0
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], value_10.bits[i]);
    }
    decimal_reset(&result);
    s21_div(value_13, value_22, &result);                                     //  2 147 483 647 / +INF = 0
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], value_11.bits[i]);
    }
    decimal_reset(&result);
    s21_div(value_13, value_21, &result);                                     //  2 147 483 647 / -INF = -0
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], value_10.bits[i]);
    }
    decimal_reset(&result);
    s21_div(value_08, value_22, &result);                                     // -2 147 483 647 / +INF = -0
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], value_10.bits[i]);
    }
    decimal_reset(&result);
    s21_div(value_08, value_21, &result);                                     // -2 147 483 647 / -INF = 0
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], value_11.bits[i]);
    }
    s21_decimal value_24 = {{10, 0, 0, 0x00000000}};                            //  10
    s21_decimal value_25 = {{2, 0, 0, 0x00000000}};                             //  2
    s21_decimal correct_answer_01 = {{5, 0, 0, 0x00000000}};                    //  5
    decimal_reset(&result);
    s21_div(value_24, value_25, &result);                                     //  10 / 2 = 5
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_01.bits[i]);
    }
    s21_decimal value_26 = {{10, 0, 0, 0x80000000}};                            // -10
    s21_decimal value_27 = {{2, 0, 0, 0x00000000}};                             //  2
    s21_decimal correct_answer_02 = {{5, 0, 0, 0x80000000}};                    // -5
    decimal_reset(&result);
    s21_div(value_26, value_27, &result);                                     // -10 / 2 = -5
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_02.bits[i]);
    }
    s21_decimal value_28 = {{10, 0, 0, 0x00000000}};                            //  10
    s21_decimal value_29 = {{2, 0, 0, 0x80000000}};                             // -2
    s21_decimal correct_answer_03 = {{5, 0, 0, 0x80000000}};                    // -5
    decimal_reset(&result);
    s21_div(value_28, value_29, &result);                                     //  10 / -2 = -5
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_03.bits[i]);
    }
    s21_decimal value_30 = {{10, 0, 0, 0x80000000}};                            // -10
    s21_decimal value_31 = {{2, 0, 0, 0x80000000}};                             // -2
    s21_decimal correct_answer_04 = {{5, 0, 0, 0x00000000}};                    // -5
    decimal_reset(&result);
    s21_div(value_30, value_31, &result);                                     // -10 / -2 = 5
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_04.bits[i]);
    }
    s21_decimal value_32 = {{4556, 0, 0, 0x00000000}};                          //  4556
    s21_decimal value_33 = {{2, 0, 0, 0x00000000}};                             //  2
    s21_decimal correct_answer_05 = {{2278, 0, 0, 0x00000000}};                 //  2278
    decimal_reset(&result);
    s21_div(value_32, value_33, &result);                                     //  4556 / 2 = 2278
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_05.bits[i]);
    }
    s21_decimal value_34 = {{22, 0, 0, 0x00000000}};                            //  22
    s21_decimal value_35 = {{110, 0, 0, 0x00000000}};                           //  110
    s21_decimal correct_answer_06 = {{2, 0, 0, 0x00010000}};                    //  2
    decimal_reset(&result);
    s21_div(value_34, value_35, &result);                                     //  22 / 110 = 0.2
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_06.bits[i]);
    }
    s21_decimal value_36 = {{9, 0, 0, 0x00000000}};                             //  9
    s21_decimal value_37 = {{45, 0, 0, 0x00010000}};                            //  4,5
    s21_decimal correct_answer_07 = {{2, 0, 0, 0x00000000}};                    //  2
    decimal_reset(&result);
    s21_div(value_36, value_37, &result);                                     //  9 / 4,5 = 2
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_07.bits[i]);
    }
    s21_decimal value_38 = {{11, 0, 0, 0x00000000}};                            //  11
    s21_decimal value_39 = {{22, 0, 0, 0x80010000}};                            //  -2,2
    s21_decimal correct_answer_08 = {{5, 0, 0, 0x80000000}};                    //  -5
    decimal_reset(&result);
    s21_div(value_38, value_39, &result);                                     //  11 / (-2,2) = -5
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_08.bits[i]);
    }
    s21_decimal value_40 = {{22, 0, 0, 0x80010000}};                            //  -2,2
    s21_decimal value_41 = {{11, 0, 0, 0x00000000}};                            //  11
    s21_decimal correct_answer_09 = {{2, 0, 0, 0x80010000}};                    //  -0,2
    decimal_reset(&result);
    s21_div(value_40, value_41, &result);                                     //  (-2,2) / 11 = -0,2
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_09.bits[i]);
    }
    s21_decimal value_42 = {{4, 0, 0, 0x00000000}};                             //  4
    s21_decimal value_43 = {{80, 0, 0, 0x00010000}};                            //  8,0
    s21_decimal correct_answer_10 = {{5, 0, 0, 0x00010000}};                    //  0,5
    decimal_reset(&result);
    s21_div(value_42, value_43, &result);                                     //  4 / 8,0 = 0,5
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_10.bits[i]);
    }
    s21_decimal value_44 = {{75, 0, 0, 0x00010000}};                            //  7,5
    s21_decimal value_45 = {{3, 0, 0, 0x00000000}};                             //  3
    s21_decimal correct_answer_11 = {{25, 0, 0, 0x00010000}};                   //  2,5
    decimal_reset(&result);
    s21_div(value_44, value_45, &result);                                     //  7,5 / 3 = 2,5
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_11.bits[i]);
    }
    s21_decimal value_46 = {{60, 0, 0, 0x00010000}};                            //  6,0
    s21_decimal value_47 = {{12, 0, 0, 0x00000000}};                            //  12
    s21_decimal correct_answer_12 = {{5, 0, 0, 0x00010000}};                    //  0,5
    decimal_reset(&result);
    s21_div(value_46, value_47, &result);                                     //  6,0 / 12 = 0,5
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_12.bits[i]);
    }
    s21_decimal value_48 = {{154, 0, 0, 0x00010000}};                           //  15,4
    s21_decimal value_49 = {{44, 0, 0, 0x00010000}};                            //  4,4
    s21_decimal correct_answer_13 = {{35, 0, 0, 0x00010000}};                   //  3,5
    decimal_reset(&result);
    s21_div(value_48, value_49, &result);                                     //  15,4 / 4,4 = 3,5
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_13.bits[i]);
    }
    s21_decimal value_50 = {{44, 0, 0, 0x00010000}};                            //  4,4
    s21_decimal value_51 = {{88, 0, 0, 0x00010000}};                            //  8,8
    s21_decimal correct_answer_14 = {{5, 0, 0, 0x00010000}};                    //  0,5
    decimal_reset(&result);
    s21_div(value_50, value_51, &result);                                     //  4,4 / 8,8 = 0,5
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_14.bits[i]);
    }
    s21_decimal value_52 = {{6, 0, 0, 0x00000000}};                             //  6
    s21_decimal value_53 = {{6, 0, 0, 0x00010000}};                             //  0,6
    s21_decimal correct_answer_15 = {{10, 0, 0, 0x00000000}};                   //  10
    decimal_reset(&result);
    s21_div(value_52, value_53, &result);                                     //  6 / 0,6 = 10
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_15.bits[i]);
    }
    s21_decimal value_54 = {{60, 0, 0, 0x00010000}};                            //  6,0
    s21_decimal value_55 = {{6, 0, 0, 0x00010000}};                             //  0,6
    s21_decimal correct_answer_16 = {{10, 0, 0, 0x00000000}};                   //  10
    decimal_reset(&result);
    s21_div(value_54, value_55, &result);                                     //  6,0 / 0,6 = 10
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_16.bits[i]);
    }

#test S21_DIV_ADDITION
    s21_decimal result = {{0}};  
    s21_decimal value_56 = {{2, 0, 0, 0x00000000}};                             //  2
    s21_decimal value_57 = {{3, 0, 0, 0x00000000}};                             //  3
    s21_decimal correct_answer_17 = {{178956971, 695075222, 361400724, 0x001C0000}};  // 0.666 666 666 666 666 666 666 666 666 7 = 00010101 10001010 10001001 10010100  00101001 01101110 00000001 10010110  00001010 10101010 10101010 10101011
    decimal_reset(&result);
    s21_div(value_56, value_57, &result);                                     //  2 / 3 = 0.666 666 666 666 666 666 666 666 666 7
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_17.bits[i]);
    }
    s21_decimal value_58 = {{4294967295, 4294967295, 4294967295, 0x00000000}};   //  79 228 162 514 264 337 593 543 950 335
    s21_decimal value_59 = {{15, 0, 0, 0x00020000}};                             //  0,15
    s21_decimal correct_answer_18 = {{0, 0, 0, 0x00FF0000}};                     //  INF
    decimal_reset(&result);
    s21_div(value_58, value_59, &result);                                      //
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_18.bits[i]);
    }
    s21_decimal value_60 = {{4294967295, 4294967295, 4294967295, 0x80000000}};   //  79 228 162 514 264 337 593 543 950 335
    s21_decimal value_61 = {{15, 0, 0, 0x00020000}};                             //  0,15
    s21_decimal correct_answer_19 = {{0, 0, 0, 0x80FF0000}};                     // -INF
    decimal_reset(&result);
    s21_div(value_60, value_61, &result);                                     //
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_19.bits[i]);
    }

#test s21_div_testing_1

    s21_decimal num_1, num_2, num_3, num_4, num_6, res_1, res_3,
        res_4, res_5, res_6, res_7, res_8, dest_1, dest_2, dest_3, dest_4, dest_5;

    /*
    *dest_1 = num_1 / num_3 = -0.1252573170030476
    */
    dest_1.bits[0] = 0b11100010100001010000101010101100;
    dest_1.bits[1] = 0b10011011011100011100011010101101;
    dest_1.bits[2] = 0b00000100000011000001101010101111;
    dest_1.bits[3] = 0b10000000000111000000000000000000;

    /*
    * num_2 = 0
    */
    num_2.bits[0] = 0b00000000000000000000000000000000;
    num_2.bits[1] = 0b00000000000000000000000000000000;
    num_2.bits[2] = 0b00000000000000000000000000000000;
    num_2.bits[3] = 0b00000000000000000000000000000000;
    /*
    *dest_2 = num_5 / num_1 = 0.1234645763995684807308283793
    */
    dest_2.bits[0] = 0b01110010000010010000111110010001;
    dest_2.bits[1] = 0b11111010100011001001000001111110;
    dest_2.bits[2] = 0b00000011111111010100011001101000;
    dest_2.bits[3] = 0b00000000000111000000000000000000;

    /*
    *num_3 = -347820
    */
    num_3.bits[0] = 0b00000000000001010100111010101100;
    num_3.bits[1] = 0b00000000000000000000000000000000;
    num_3.bits[2] = 0b00000000000000000000000000000000;
    num_3.bits[3] = 0b10000000000000000000000000000000;
    /*
    *dest_3 = num_3 / num_6 = -86955
    */
    dest_3.bits[0] = 0b00000000000000010101001110101011;
    dest_3.bits[1] = 0b00000000000000000000000000000000;
    dest_3.bits[2] = 0b00000000000000000000000000000000;
    dest_3.bits[3] = 0b10000000000000000000000000000000;

    /*
    *dest_4 = num_3 / num_3 = 1
    */
    dest_4.bits[0] = 0b00000000000000000000000000000001;
    dest_4.bits[1] = 0b00000000000000000000000000000000;
    dest_4.bits[2] = 0b00000000000000000000000000000000;
    dest_4.bits[3] = 0b00000000000000000000000000000000;

    /*
    *num_1 = 43567
    */
    num_1.bits[0] = 0b00000000000000001010101000101111;
    num_1.bits[1] = 0b00000000000000000000000000000000;
    num_1.bits[2] = 0b00000000000000000000000000000000;
    num_1.bits[3] = 0b00000000000000000000000000000000;

    /*
    *num_4 = 79228162514264337593543950335
    */
    num_4.bits[0] = 0b11111111111111111111111111111111;
    num_4.bits[1] = 0b11111111111111111111111111111111;
    num_4.bits[2] = 0b11111111111111111111111111111111;
    num_4.bits[3] = 0b00000000000000000000000000000000;
    /*
    *dest_5 = num_1 / num_4 = 0.0000000000000000000000005499
    */
    dest_5.bits[0] = 0b00000000000000000001010101111011;
    dest_5.bits[1] = 0b00000000000000000000000000000000;
    dest_5.bits[2] = 0b00000000000000000000000000000000;
    dest_5.bits[3] = 0b00000000000111000000000000000000;
    /*
    *num_6 = 4
    */
    num_6.bits[0] = 0b00000000000000000000000000000100;
    num_6.bits[1] = 0b00000000000000000000000000000000;
    num_6.bits[2] = 0b00000000000000000000000000000000;
    num_6.bits[3] = 0b00000000000000000000000000000000;
    /* dest_6 = num_3 / num_4 = -inf
    * dest_7 = num_1 / num_2 = nan
    */
    int value_1 = s21_div(num_1, num_3, &res_1);
    int value_3 = s21_div(num_3, num_6, &res_3);
    int value_4 = s21_div(num_3, num_3, &res_4);
    int value_5 = s21_div(num_1, num_4, &res_5);
    int value_6 = s21_div(num_4, dest_1, &res_6);
    int value_7 = s21_div(num_4, dest_2, &res_7);
    int value_8 = s21_div(num_1, num_2, &res_8);
    ck_assert_int_eq(res_1.bits[0], dest_1.bits[0]);
    ck_assert_int_eq(res_1.bits[1], dest_1.bits[1]);
    ck_assert_int_eq(res_1.bits[2], dest_1.bits[2]);
    ck_assert_int_eq(res_1.bits[3], dest_1.bits[3]);
    ck_assert_int_eq(value_1, VALUE_OK);
    ck_assert_int_eq(res_3.bits[0], dest_3.bits[0]);
    ck_assert_int_eq(res_3.bits[1], dest_3.bits[1]);
    ck_assert_int_eq(res_3.bits[2], dest_3.bits[2]);
    ck_assert_int_eq(res_3.bits[3], dest_3.bits[3]);
    ck_assert_int_eq(value_3, VALUE_OK);
    ck_assert_int_eq(res_4.bits[0], dest_4.bits[0]);
    ck_assert_int_eq(res_4.bits[1], dest_4.bits[1]);
    ck_assert_int_eq(res_4.bits[2], dest_4.bits[2]);
    ck_assert_int_eq(res_4.bits[3], dest_4.bits[3]);
    ck_assert_int_eq(value_4, VALUE_OK);
    ck_assert_int_eq(res_5.bits[0], dest_5.bits[0]);
    ck_assert_int_eq(res_5.bits[1], dest_5.bits[1]);
    ck_assert_int_eq(res_5.bits[2], dest_5.bits[2]);
    ck_assert_int_eq(res_5.bits[3], dest_5.bits[3]);
    ck_assert_int_eq(value_5, VALUE_OK);
    ck_assert_int_eq(value_6, VALUE_MINUS_INF);
    ck_assert_int_eq(value_7, VALUE_INF);
    ck_assert_int_eq(value_8, VALUE_NAN);

    #test s21_div_testing_2

    s21_decimal src1, src2, res_div;
    // src1 = 9;
    // src2 = 3;
    // origin_result = 3
    s21_decimal origin = {{0}};
    int value_type_result = 0;
    int value_type_origin = 0;
    src1.bits[0] = 0b00000000000000000000000000001001;
    src1.bits[1] = 0b00000000000000000000000000000000;
    src1.bits[2] = 0b00000000000000000000000000000000;
    src1.bits[3] = 0b00000000000000000000000000000000;
    src2.bits[0] = 0b00000000000000000000000000000011;
    src2.bits[1] = 0b00000000000000000000000000000000;
    src2.bits[2] = 0b00000000000000000000000000000000;
    src2.bits[3] = 0b00000000000000000000000000000000;
    value_type_result = s21_div(src1, src2, &res_div);
    value_type_origin = 0;
    origin.bits[0] = 0b00000000000000000000000000000011;
    origin.bits[1] = 0b00000000000000000000000000000000;
    origin.bits[2] = 0b00000000000000000000000000000000;
    origin.bits[3] = 0b00000000000000000000000000000000;
    ck_assert_int_eq(origin.bits[3], res_div.bits[3]);
    ck_assert_int_eq(origin.bits[2], res_div.bits[2]);
    ck_assert_int_eq(origin.bits[1], res_div.bits[1]);
    ck_assert_int_eq(origin.bits[0], res_div.bits[0]);
    ck_assert_int_eq(value_type_result, value_type_origin);

    #test s21_div_testing_3
    s21_decimal src1, src2, res_div;
    s21_decimal origin = {{0}};
    int value_type_result = 0;
    int value_type_origin = 0;
    // src1 = -98765;
    // src2 = 1234;
    // origin_result = -80.03646677471636952998379254
    src1.bits[0] = 0b00000000000000011000000111001101;
    src1.bits[1] = 0b00000000000000000000000000000000;
    src1.bits[2] = 0b00000000000000000000000000000000;
    src1.bits[3] = 0b10000000000000000000000000000000;
    src2.bits[0] = 0b00000000000000000000010011010010;
    src2.bits[1] = 0b00000000000000000000000000000000;
    src2.bits[2] = 0b00000000000000000000000000000000;
    src2.bits[3] = 0b00000000000000000000000000000000;
    value_type_result = s21_div(src1, src2, &res_div);
    value_type_origin = 0;
    origin.bits[0] = 0b11101100100111100111111011110110;
    origin.bits[1] = 0b11000110101010111010101001101000;
    origin.bits[2] = 0b00011001110111000111011000011011;
    origin.bits[3] = 0b10000000000110100000000000000000;
    ck_assert_int_eq(origin.bits[3], res_div.bits[3]);
    ck_assert_int_eq(origin.bits[2], res_div.bits[2]);
    ck_assert_int_eq(origin.bits[1], res_div.bits[1]);
    ck_assert_int_eq(origin.bits[0], res_div.bits[0]);
    ck_assert_int_eq(value_type_result, value_type_origin);

    #test s21_div_testing_4
    // src1 = 30198;
    // src2 = 20210;
    // origin_result = 1.4942107867392380009896091044
    s21_decimal src1, src2, res_div;
    s21_decimal origin = {{0}};
    int value_type_result = 0;
    int value_type_origin = 0;
    src1.bits[0] = 0b00000000000000000111010111110110;
    src1.bits[1] = 0b00000000000000000000000000000000;
    src1.bits[2] = 0b00000000000000000000000000000000;
    src1.bits[3] = 0b00000000000000000000000000000000;
    src2.bits[0] = 0b00000000000000000100111011110010;
    src2.bits[1] = 0b00000000000000000000000000000000;
    src2.bits[2] = 0b00000000000000000000000000000000;
    src2.bits[3] = 0b00000000000000000000000000000000;
    value_type_result = s21_div(src1, src2, &res_div);
    value_type_origin = 0;
    origin.bits[0] = 0b01010101010111100001110110100100;
    origin.bits[1] = 0b10010001001001010111110101101001;
    origin.bits[2] = 0b00110000010001111101001001101010;
    origin.bits[3] = 0b00000000000111000000000000000000;
    ck_assert_int_eq(origin.bits[3], res_div.bits[3]);
    ck_assert_int_eq(origin.bits[2], res_div.bits[2]);
    ck_assert_int_eq(origin.bits[1], res_div.bits[1]);
    ck_assert_int_eq(origin.bits[0], res_div.bits[0]);
    ck_assert_int_eq(value_type_result, value_type_origin);

    #test s21_div_testing_5
    // src1 = -98765;
    // src2 = -1234;
    // origin_result = 80.03646677471636952998379254
    s21_decimal src1, src2, res_div;
    s21_decimal origin = {{0}};
    int value_type_result = 0;
    int value_type_origin = 0;;
    src1.bits[0] = 0b00000000000000011000000111001101;
    src1.bits[1] = 0b00000000000000000000000000000000;
    src1.bits[2] = 0b00000000000000000000000000000000;
    src1.bits[3] = 0b10000000000000000000000000000000;
    src2.bits[0] = 0b00000000000000000000010011010010;
    src2.bits[1] = 0b00000000000000000000000000000000;
    src2.bits[2] = 0b00000000000000000000000000000000;
    src2.bits[3] = 0b10000000000000000000000000000000;
    value_type_result = s21_div(src1, src2, &res_div);
    value_type_origin = 0;
    origin.bits[0] = 0b11101100100111100111111011110110;
    origin.bits[1] = 0b11000110101010111010101001101000;
    origin.bits[2] = 0b00011001110111000111011000011011;
    origin.bits[3] = 0b00000000000110100000000000000000;
    ck_assert_int_eq(origin.bits[3], res_div.bits[3]);
    ck_assert_int_eq(origin.bits[2], res_div.bits[2]);
    ck_assert_int_eq(origin.bits[1], res_div.bits[1]);
    ck_assert_int_eq(origin.bits[0], res_div.bits[0]);
    ck_assert_int_eq(value_type_result, value_type_origin);

    #test s21_div_testing_6
    // src1 = 98765;
    // src2 = 127234;
    // origin_result = 0.7762469151327475360359652294
    s21_decimal src1, src2, res_div;
    s21_decimal origin = {{0}};
    int value_type_result = 0;
    int value_type_origin = 0;
    src1.bits[0] = 0b00000000000000011000000111001101;
    src1.bits[1] = 0b00000000000000000000000000000000;
    src1.bits[2] = 0b00000000000000000000000000000000;
    src1.bits[3] = 0b00000000000000000000000000000000;
    src2.bits[0] = 0b00000000000000011111000100000010;
    src2.bits[1] = 0b00000000000000000000000000000000;
    src2.bits[2] = 0b00000000000000000000000000000000;
    src2.bits[3] = 0b00000000000000000000000000000000;
    value_type_result = s21_div(src1, src2, &res_div);
    value_type_origin = 0;
    origin.bits[0] = 0b00011000000010100001101111000110;
    origin.bits[1] = 0b11100010110101000000100110001111;
    origin.bits[2] = 0b00011001000101001111011011000111;
    origin.bits[3] = 0b00000000000111000000000000000000;
    ck_assert_int_eq(origin.bits[3], res_div.bits[3]);
    ck_assert_int_eq(origin.bits[2], res_div.bits[2]);
    ck_assert_int_eq(origin.bits[1], res_div.bits[1]);
    ck_assert_int_eq(origin.bits[0], res_div.bits[0]);
    ck_assert_int_eq(value_type_result, value_type_origin);

    #test s21_div_testing_7
    // src1 = 342576;
    // src2 = 1542134;
    // origin_result = 0.2221441197716929916596093465
    s21_decimal src1, src2, res_div;
    s21_decimal origin = {{0}};
    int value_type_result = 0;
    int value_type_origin = 0;
    src1.bits[0] = 0b00000000000001010011101000110000;
    src1.bits[1] = 0b00000000000000000000000000000000;
    src1.bits[2] = 0b00000000000000000000000000000000;
    src1.bits[3] = 0b00000000000000000000000000000000;
    src2.bits[0] = 0b00000000000101111000011111110110;
    src2.bits[1] = 0b00000000000000000000000000000000;
    src2.bits[2] = 0b00000000000000000000000000000000;
    src2.bits[3] = 0b00000000000000000000000000000000;
    value_type_result = s21_div(src1, src2, &res_div);
    value_type_origin = 0;
    origin.bits[0] = 0b00001110001000111000001000011001;
    origin.bits[1] = 0b10100001011100111110011110110000;
    origin.bits[2] = 0b00000111001011011000100001111000;
    origin.bits[3] = 0b00000000000111000000000000000000;
    ck_assert_int_eq(origin.bits[3], res_div.bits[3]);
    ck_assert_int_eq(origin.bits[2], res_div.bits[2]);
    ck_assert_int_eq(origin.bits[1], res_div.bits[1]);
    ck_assert_int_eq(origin.bits[0], res_div.bits[0]);
    ck_assert_int_eq(value_type_result, value_type_origin);

    #test s21_div_testing_8
    // src1 = 12;
    // src2 = 0;
    // origin_result = 0.0
    s21_decimal src1, src2, res_div;
    s21_decimal origin = {{0}};
    int value_type_result = 0;
    int value_type_origin = 0;
    src1.bits[0] = 0b00000000000000000000000000001100;
    src1.bits[1] = 0b00000000000000000000000000000000;
    src1.bits[2] = 0b00000000000000000000000000000000;
    src1.bits[3] = 0b00000000000000000000000000000000;
    src2.bits[0] = 0b00000000000000000000000000000000;
    src2.bits[1] = 0b00000000000000000000000000000000;
    src2.bits[2] = 0b00000000000000000000000000000000;
    src2.bits[3] = 0b00000000000000000000000000000000;
    value_type_result = s21_div(src1, src2, &res_div);
    value_type_origin = 3;
    origin.bits[0] = 0b00000000000000000000000000000000;
    origin.bits[1] = 0b00000000000000000000000000000000;
    origin.bits[2] = 0b00000000000000000000000000000000;
    origin.bits[3] = 0b00000000111111110000000000000000;
    ck_assert_int_eq(origin.bits[3], res_div.bits[3]);
    ck_assert_int_eq(origin.bits[2], res_div.bits[2]);
    ck_assert_int_eq(origin.bits[1], res_div.bits[1]);
    ck_assert_int_eq(origin.bits[0], res_div.bits[0]);
    ck_assert_int_eq(value_type_result, value_type_origin);

    #test s21_div_testing_9
    // src1 = 0;
    // src2 = 8976545415646545.5746845454;
    // origin_result = 0.0
    s21_decimal src1, src2, res_div;
    s21_decimal origin = {{0}};
    int value_type_result = 0;
    int value_type_origin = 0;
    src1.bits[0] = 0b00000000000000000000000000000000;
    src1.bits[1] = 0b00000000000000000000000000000000;
    src1.bits[2] = 0b00000000000000000000000000000000;
    src1.bits[3] = 0b00000000000000000000000000000000;
    src2.bits[0] = 0b11011101111000010000101100001110;
    src2.bits[1] = 0b00000101010000010110101000000010;
    src2.bits[2] = 0b00000000010010100100000010010011;
    src2.bits[3] = 0b00000000000010100000000000000000;
    value_type_result = s21_div(src1, src2, &res_div);
    value_type_origin = 0;
    origin.bits[0] = 0b00000000000000000000000000000000;
    origin.bits[1] = 0b00000000000000000000000000000000;
    origin.bits[2] = 0b00000000000000000000000000000000;
    origin.bits[3] = 0b00000000000000000000000000000000;
    ck_assert_int_eq(origin.bits[3], res_div.bits[3]);
    ck_assert_int_eq(origin.bits[2], res_div.bits[2]);
    ck_assert_int_eq(origin.bits[1], res_div.bits[1]);
    ck_assert_int_eq(origin.bits[0], res_div.bits[0]);
    ck_assert_int_eq(value_type_result, value_type_origin);

    #test s21_div_testing_10
    // src1 = 178324.4353453454;
    // src2 = 19.87;
    // origin_result = 8974.556383761721187720181178
    s21_decimal src1, src2, res_div;
    s21_decimal origin = {{0}};
    int value_type_result = 0;
    int value_type_origin = 0;
    src1.bits[0] = 0b11101110001111000011110110001110;
    src1.bits[1] = 0b00000000000001100101010111011001;
    src1.bits[2] = 0b00000000000000000000000000000000;
    src1.bits[3] = 0b00000000000010100000000000000000;
    src2.bits[0] = 0b00000000000000000000011111000011;
    src2.bits[1] = 0b00000000000000000000000000000000;
    src2.bits[2] = 0b00000000000000000000000000000000;
    src2.bits[3] = 0b00000000000000100000000000000000;
    value_type_result = s21_div(src1, src2, &res_div);
    value_type_origin = 0;
    origin.bits[0] = 0b00101100000011110011010110111010;
    origin.bits[1] = 0b01101011000111001001111111101011;
    origin.bits[2] = 0b00011100111111111001010000111100;
    origin.bits[3] = 0b00000000000110000000000000000000;
    ck_assert_int_eq(origin.bits[3], res_div.bits[3]);
    ck_assert_int_eq(origin.bits[2], res_div.bits[2]);
    ck_assert_int_eq(origin.bits[1], res_div.bits[1]);
    ck_assert_int_eq(origin.bits[0], res_div.bits[0]);
    ck_assert_int_eq(value_type_result, value_type_origin);

    #test s21_div_testing_11
    // src1 = -1783244353453454.71;
    // src2 = 4e-28;
    // origin_result = 0
    s21_decimal src1, src2, res_div;
    s21_decimal origin = {{0}};
    int value_type_result = 0;
    int value_type_origin = 0;
    src1.bits[0] = 0b00001111100010000000101110111111;
    src1.bits[1] = 0b00000010011110011000100100100001;
    src1.bits[2] = 0b00000000000000000000000000000000;
    src1.bits[3] = 0b10000000000000100000000000000000;
    src2.bits[0] = 0b00000000000000000000000000000100;
    src2.bits[1] = 0b00000000000000000000000000000000;
    src2.bits[2] = 0b00000000000000000000000000000000;
    src2.bits[3] = 0b00000000000111000000000000000000;
    value_type_result = s21_div(src1, src2, &res_div);
    value_type_origin = 2;
    origin.bits[0] = 0b00000000000000000000000000000000;
    origin.bits[1] = 0b00000000000000000000000000000000;
    origin.bits[2] = 0b00000000000000000000000000000000;
    origin.bits[3] = 0b10000000111111110000000000000000;
    ck_assert_int_eq(origin.bits[3], res_div.bits[3]);
    ck_assert_int_eq(origin.bits[2], res_div.bits[2]);
    ck_assert_int_eq(origin.bits[1], res_div.bits[1]);
    ck_assert_int_eq(origin.bits[0], res_div.bits[0]);
    ck_assert_int_eq(value_type_result, value_type_origin);

    #test s21_div_testing_12
    // src1 = 70000000000000000000000000000;
    // src2 = 0.001;
    // origin_result = 0
    s21_decimal src1, src2, res_div;
    s21_decimal origin = {{0}};
    int value_type_result = 0;
    int value_type_origin = 0;
    src1.bits[0] = 0b01110000000000000000000000000000;
    src1.bits[1] = 0b10110011000000110001000010100111;
    src1.bits[2] = 0b11100010001011101010010010010011;
    src1.bits[3] = 0b00000000000000000000000000000000;
    src2.bits[0] = 0b00000000000000000000000000000001;
    src2.bits[1] = 0b00000000000000000000000000000000;
    src2.bits[2] = 0b00000000000000000000000000000000;
    src2.bits[3] = 0b00000000000000110000000000000000;
    value_type_result = s21_div(src1, src2, &res_div);
    value_type_origin = 1;
    origin.bits[0] = 0b00000000000000000000000000000000;
    origin.bits[1] = 0b00000000000000000000000000000000;
    origin.bits[2] = 0b00000000000000000000000000000000;
    origin.bits[3] = 0b00000000111111110000000000000000;
    ck_assert_int_eq(origin.bits[3], res_div.bits[3]);
    ck_assert_int_eq(origin.bits[2], res_div.bits[2]);
    ck_assert_int_eq(origin.bits[1], res_div.bits[1]);
    ck_assert_int_eq(origin.bits[0], res_div.bits[0]);
    ck_assert_int_eq(value_type_result, value_type_origin);

    #test s21_div_testing_13
    // src1 = 79228162514264337593543950335;
    // src2 = 79228162514.26433759354;
    // origin_result = 1000000000000000000.0000498602
    s21_decimal src1, src2, res_div;
    s21_decimal origin = {{0}};
    int value_type_result = 0;
    int value_type_origin = 0;
    src1.bits[0] = 0b11111111111111111111111111111111;
    src1.bits[1] = 0b11111111111111111111111111111111;
    src1.bits[2] = 0b11111111111111111111111111111111;
    src1.bits[3] = 0b00000000000000000000000000000000;
    src2.bits[0] = 0b11110100100001010111100001111010;
    src2.bits[1] = 0b01111111001010011010101111001010;
    src2.bits[2] = 0b00000000000000000000000110101101;
    src2.bits[3] = 0b00000000000010110000000000000000;
    value_type_result = s21_div(src1, src2, &res_div);
    value_type_origin = 0;
    origin.bits[0] = 0b00010000000001111001101110101010;
    origin.bits[1] = 0b00111110001001010000001001100001;
    origin.bits[2] = 0b00100000010011111100111001011110;
    origin.bits[3] = 0b00000000000010100000000000000000;
    ck_assert_int_eq(origin.bits[3], res_div.bits[3]);
    ck_assert_int_eq(origin.bits[2], res_div.bits[2]);
    ck_assert_int_eq(origin.bits[1], res_div.bits[1]);
    ck_assert_int_eq(origin.bits[0], res_div.bits[0]);
    ck_assert_int_eq(value_type_result, value_type_origin);

    #test s21_div_testing_14
    // src1 = 79228162514264337593543950335;
    // src2 = 7922816251426433759354395033.5;
    // origin_result = 10
    s21_decimal src1, src2, res_div;
    s21_decimal origin = {{0}};
    int value_type_result = 0;
    int value_type_origin = 0;
    src1.bits[0] = 0b11111111111111111111111111111111;
    src1.bits[1] = 0b11111111111111111111111111111111;
    src1.bits[2] = 0b11111111111111111111111111111111;
    src1.bits[3] = 0b00000000000000000000000000000000;
    src2.bits[0] = 0b11111111111111111111111111111111;
    src2.bits[1] = 0b11111111111111111111111111111111;
    src2.bits[2] = 0b11111111111111111111111111111111;
    src2.bits[3] = 0b00000000000000010000000000000000;
    value_type_result = s21_div(src1, src2, &res_div);
    value_type_origin = 0;
    origin.bits[0] = 0b00000000000000000000000000001010;
    origin.bits[1] = 0b00000000000000000000000000000000;
    origin.bits[2] = 0b00000000000000000000000000000000;
    origin.bits[3] = 0b00000000000000000000000000000000;
    ck_assert_int_eq(origin.bits[3], res_div.bits[3]);
    ck_assert_int_eq(origin.bits[2], res_div.bits[2]);
    ck_assert_int_eq(origin.bits[1], res_div.bits[1]);
    ck_assert_int_eq(origin.bits[0], res_div.bits[0]);
    ck_assert_int_eq(value_type_result, value_type_origin);

    #test s21_div_testing_15
    // src1 = 79228162514264337593543950335;
    // src2 = 1;
    // origin_result = 0
    s21_decimal src1, src2, res_div;
    s21_decimal origin = {{0}};
    int value_type_result = 0;
    int value_type_origin = 0;
    src1.bits[0] = 0b11111111111111111111111111111111;
    src1.bits[1] = 0b11111111111111111111111111111111;
    src1.bits[2] = 0b11111111111111111111111111111111;
    src1.bits[3] = 0b00000000000000000000000000000000;
    src2.bits[0] = 0b00000000000000000000000000000001;
    src2.bits[1] = 0b00000000000000000000000000000000;
    src2.bits[2] = 0b00000000000000000000000000000000;
    src2.bits[3] = 0b00000000000000000000000000000000;
    value_type_result = s21_div(src1, src2, &res_div);
    value_type_origin = 0;
    origin.bits[0] = 0b11111111111111111111111111111111;
    origin.bits[1] = 0b11111111111111111111111111111111;
    origin.bits[2] = 0b11111111111111111111111111111111;
    origin.bits[3] = 0b00000000000000000000000000000000;
    ck_assert_int_eq(origin.bits[3], res_div.bits[3]);
    ck_assert_int_eq(origin.bits[2], res_div.bits[2]);
    ck_assert_int_eq(origin.bits[1], res_div.bits[1]);
    ck_assert_int_eq(origin.bits[0], res_div.bits[0]);
    ck_assert_int_eq(value_type_result, value_type_origin);



#test S21_FLOOR_1
    s21_decimal num_1, res_1, dest_1;
    /*
    *num_1 = 0,000
    */
    num_1.bits[0] = 0b00000000000000000000000000000000;
    num_1.bits[1] = 0b00000000000000000000000000000000;
    num_1.bits[2] = 0b00000000000000000000000000000000;
    num_1.bits[3] = 0b00000000000000110000000000000000;
    /*
    *dest_1 = 0
    */
    dest_1.bits[0] = 0b00000000000000000000000000000000;
    dest_1.bits[1] = 0b00000000000000000000000000000000;
    dest_1.bits[2] = 0b00000000000000000000000000000000;
    dest_1.bits[3] = 0b00000000000000000000000000000000;

    int value_1 = s21_floor(num_1, &res_1);
    ck_assert_int_eq(res_1.bits[0], dest_1.bits[0]);
    ck_assert_int_eq(res_1.bits[1], dest_1.bits[1]);
    ck_assert_int_eq(res_1.bits[2], dest_1.bits[2]);
    ck_assert_int_eq(res_1.bits[3], dest_1.bits[3]);
    ck_assert_int_eq(value_1, VALUE_OK);

    #test S21_FLOOR_2

    s21_decimal num_2, res_2, dest_2;

    /*
    *num_2 = 7845.0234
    */
    num_2.bits[0] = 0b00000100101011010000111000111010;
    num_2.bits[1] = 0b00000000000000000000000000000000;
    num_2.bits[2] = 0b00000000000000000000000000000000;
    num_2.bits[3] = 0x00040000;
    /*
    *dest_2 = 7845
    */
    dest_2.bits[0] = 0b00000000000000000001111010100101;
    dest_2.bits[1] = 0b00000000000000000000000000000000;
    dest_2.bits[2] = 0b00000000000000000000000000000000;
    dest_2.bits[3] = 0b00000000000000000000000000000000;

    int value_2 = s21_floor(num_2, &res_2);
    ck_assert_int_eq(res_2.bits[0], dest_2.bits[0]);
    ck_assert_int_eq(res_2.bits[1], dest_2.bits[1]);
    ck_assert_int_eq(res_2.bits[2], dest_2.bits[2]);
    ck_assert_int_eq(res_2.bits[3], dest_2.bits[3]);
    ck_assert_int_eq(value_2, VALUE_OK);


    #test S21_FLOOR_3

    s21_decimal num_3, res_3, dest_3;

    /*
    *num_3 = -821.4392
    */
    num_3.bits[0] = 0b00000000011111010101011101111000;
    num_3.bits[1] = 0b00000000000000000000000000000000;
    num_3.bits[2] = 0b00000000000000000000000000000000;
    num_3.bits[3] = 0x80040000;
    /*
    *dest_3 = -822
    */
    dest_3.bits[0] = 0b00000000000000000000001100110110;
    dest_3.bits[1] = 0b00000000000000000000000000000000;
    dest_3.bits[2] = 0b00000000000000000000000000000000;
    dest_3.bits[3] = 0b10000000000000000000000000000000;
    int value_3 = s21_floor(num_3, &res_3);
    ck_assert_int_eq(res_3.bits[0], dest_3.bits[0]);
    ck_assert_int_eq(res_3.bits[1], dest_3.bits[1]);
    ck_assert_int_eq(res_3.bits[2], dest_3.bits[2]);
    ck_assert_int_eq(res_3.bits[3], dest_3.bits[3]);
    ck_assert_int_eq(value_3, VALUE_OK);

    #test S21_FLOOR_4

    s21_decimal num_4, res_4, dest_4;

    /*
    *num_4 = -79228162514264337593543950335
    */
    num_4.bits[0] = 0b11111111111111111111111111111111;
    num_4.bits[1] = 0b11111111111111111111111111111111;
    num_4.bits[2] = 0b11111111111111111111111111111111;
    num_4.bits[3] = 0b10000000000000000000000000000000;
    /*
    *dest_4 = -79228162514264337593543950335
    */
    dest_4.bits[0] = 0b11111111111111111111111111111111;
    dest_4.bits[1] = 0b11111111111111111111111111111111;
    dest_4.bits[2] = 0b11111111111111111111111111111111;
    dest_4.bits[3] = 0b10000000000000000000000000000000;

    int value_4 = s21_floor(num_4, &res_4);
    ck_assert_int_eq(res_4.bits[0], dest_4.bits[0]);
    ck_assert_int_eq(res_4.bits[1], dest_4.bits[1]);
    ck_assert_int_eq(res_4.bits[2], dest_4.bits[2]);
    ck_assert_int_eq(res_4.bits[3], dest_4.bits[3]);
    ck_assert_int_eq(value_4, VALUE_OK);

    #test S21_FLOOR_5

    s21_decimal num_5, res_5, dest_5;

    /*
    *num_5 = 345
    */
    num_5.bits[0] = 0b00000000000000000000000101011001;
    num_5.bits[1] = 0b00000000000000000000000000000000;
    num_5.bits[2] = 0b00000000000000000000000000000000;
    num_5.bits[3] = 0b00000000000000000000000000000000;

    /*
    *dest_5 = 345
    */
    dest_5.bits[0] = 0b00000000000000000000000101011001;
    dest_5.bits[1] = 0b00000000000000000000000000000000;
    dest_5.bits[2] = 0b00000000000000000000000000000000;
    dest_5.bits[3] = 0b00000000000000000000000000000000;

    int value_5 = s21_floor(num_5, &res_5);
    ck_assert_int_eq(res_5.bits[0], dest_5.bits[0]);
    ck_assert_int_eq(res_5.bits[1], dest_5.bits[1]);
    ck_assert_int_eq(res_5.bits[2], dest_5.bits[2]);
    ck_assert_int_eq(res_5.bits[3], dest_5.bits[3]);
    ck_assert_int_eq(value_5, VALUE_OK);

    #test S21_FLOOR_6

    s21_decimal num_6, res_6, dest_6;

    /*
    *num_6 = -0.000
    */
    num_6.bits[0] = 0b00000000000000000000000000000000;
    num_6.bits[1] = 0b00000000000000000000000000000000;
    num_6.bits[2] = 0b00000000000000000000000000000000;
    num_6.bits[3] = 0b10000000000000110000000000000000;

    /*
    *dest_6 = 0
    */
    dest_6.bits[0] = 0b00000000000000000000000000000000;
    dest_6.bits[1] = 0b00000000000000000000000000000000;
    dest_6.bits[2] = 0b00000000000000000000000000000000;
    dest_6.bits[3] = 0b00000000000000000000000000000000;

    int value_6 = s21_floor(num_6, &res_6);
    ck_assert_int_eq(res_6.bits[0], dest_6.bits[0]);
    ck_assert_int_eq(res_6.bits[1], dest_6.bits[1]);
    ck_assert_int_eq(res_6.bits[2], dest_6.bits[2]);
    ck_assert_int_eq(res_6.bits[3], dest_6.bits[3]);
    ck_assert_int_eq(value_6, VALUE_OK);

#test S21_FLOOR_7

    s21_decimal num_7, res_7, dest_7;
    /*
    *num_7 = -98.78798789312
    */
    num_7.bits[0] = 0b00010110010010101110101011000000;
    num_7.bits[1] = 0b00000000000000000000100011111100;
    num_7.bits[2] = 0b00000000000000000000000000000000;
    num_7.bits[3] = 0b10000000000010110000000000000000;


    /*
    *dest_7 = -99
    */
    dest_7.bits[0] = 0b00000000000000000000000001100011;
    dest_7.bits[1] = 0b00000000000000000000000000000000;
    dest_7.bits[2] = 0b00000000000000000000000000000000;
    dest_7.bits[3] = 0b10000000000000000000000000000000;

    int value_7 = s21_floor(num_7, &res_7);
    ck_assert_int_eq(res_7.bits[0], dest_7.bits[0]);
    ck_assert_int_eq(res_7.bits[1], dest_7.bits[1]);
    ck_assert_int_eq(res_7.bits[2], dest_7.bits[2]);
    ck_assert_int_eq(res_7.bits[3], dest_7.bits[3]);
    ck_assert_int_eq(value_7, VALUE_OK);


#test S21_FLOOR_8
    s21_decimal src, origin, result;
    // src = 5.0;
    src.bits[0] = 0b00000000000000000000000000110010;
    src.bits[1] = 0b00000000000000000000000000000000;
    src.bits[2] = 0b00000000000000000000000000000000;
    src.bits[3] = 0b00000000000000010000000000000000;
    int check = s21_floor(src, &result);
    int check_origin = 0;
    // origin = 5;
    origin.bits[0] = 0b00000000000000000000000000000101;
    origin.bits[1] = 0b00000000000000000000000000000000;
    origin.bits[2] = 0b00000000000000000000000000000000;
    origin.bits[3] = 0b00000000000000000000000000000000;
    ck_assert_int_eq(origin.bits[3], result.bits[3]);
    ck_assert_int_eq(origin.bits[2], result.bits[2]);
    ck_assert_int_eq(origin.bits[1], result.bits[1]);
    ck_assert_int_eq(origin.bits[0], result.bits[0]);
    ck_assert_int_eq(check, check_origin);


    // src = 3.4;
    src.bits[0] = 0b00000000000000000000000000100010;
    src.bits[1] = 0b00000000000000000000000000000000;
    src.bits[2] = 0b00000000000000000000000000000000;
    src.bits[3] = 0b00000000000000010000000000000000;
    check = s21_floor(src, &result);
    check_origin = 0;
    // origin = 3;
    origin.bits[0] = 0b00000000000000000000000000000011;
    origin.bits[1] = 0b00000000000000000000000000000000;
    origin.bits[2] = 0b00000000000000000000000000000000;
    origin.bits[3] = 0b00000000000000000000000000000000;
    ck_assert_int_eq(origin.bits[3], result.bits[3]);
    ck_assert_int_eq(origin.bits[2], result.bits[2]);
    ck_assert_int_eq(origin.bits[1], result.bits[1]);
    ck_assert_int_eq(origin.bits[0], result.bits[0]);
    ck_assert_int_eq(check, check_origin);


#test S21_FLOOR_9
    s21_decimal src, origin, result;
    int check = 0;
    int check_origin = 0;
    // src = 0.0;
    src.bits[0] = 0b00000000000000000000000000000000;
    src.bits[1] = 0b00000000000000000000000000000000;
    src.bits[2] = 0b00000000000000000000000000000000;
    src.bits[3] = 0b00000000000000010000000000000000;
    check = s21_floor(src, &result);
    check_origin = 0;
    // origin = 0;
    origin.bits[0] = 0b00000000000000000000000000000000;
    origin.bits[1] = 0b00000000000000000000000000000000;
    origin.bits[2] = 0b00000000000000000000000000000000;
    origin.bits[3] = 0b00000000000000000000000000000000;
    ck_assert_int_eq(origin.bits[3], result.bits[3]);
    ck_assert_int_eq(origin.bits[2], result.bits[2]);
    ck_assert_int_eq(origin.bits[1], result.bits[1]);
    ck_assert_int_eq(origin.bits[0], result.bits[0]);
    ck_assert_int_eq(check, check_origin);

    // src = -2.4363463;
    src.bits[0] = 0b00000001011100111100000111000111;
    src.bits[1] = 0b00000000000000000000000000000000;
    src.bits[2] = 0b00000000000000000000000000000000;
    src.bits[3] = 0b10000000000001110000000000000000;
    check = s21_floor(src, &result);
    check_origin = 0;
    // origin = -3;
    origin.bits[0] = 0b00000000000000000000000000000011;
    origin.bits[1] = 0b00000000000000000000000000000000;
    origin.bits[2] = 0b00000000000000000000000000000000;
    origin.bits[3] = 0b10000000000000000000000000000000;
    ck_assert_int_eq(origin.bits[3], result.bits[3]);
    ck_assert_int_eq(origin.bits[2], result.bits[2]);
    ck_assert_int_eq(origin.bits[1], result.bits[1]);
    ck_assert_int_eq(origin.bits[0], result.bits[0]);
    ck_assert_int_eq(check, check_origin);


#test S21_FLOOR_10
    s21_decimal src, origin, result;
    int check = 0;
    int check_origin = 0;
    // src = -0.0;
    src.bits[0] = 0b00000000000000000000000000000000;
    src.bits[1] = 0b00000000000000000000000000000000;
    src.bits[2] = 0b00000000000000000000000000000000;
    src.bits[3] = 0b10000000000000010000000000000000;
    check = s21_floor(src, &result);
    check_origin = 0;
    // origin = 0;
    origin.bits[0] = 0b00000000000000000000000000000000;
    origin.bits[1] = 0b00000000000000000000000000000000;
    origin.bits[2] = 0b00000000000000000000000000000000;
    origin.bits[3] = 0b00000000000000000000000000000000;
    ck_assert_int_eq(origin.bits[3], result.bits[3]);
    ck_assert_int_eq(origin.bits[2], result.bits[2]);
    ck_assert_int_eq(origin.bits[1], result.bits[1]);
    ck_assert_int_eq(origin.bits[0], result.bits[0]);
    ck_assert_int_eq(check, check_origin);

    // src = -0.45;
    src.bits[0] = 0b00000000000000000000000000101101;
    src.bits[1] = 0b00000000000000000000000000000000;
    src.bits[2] = 0b00000000000000000000000000000000;
    src.bits[3] = 0b10000000000000100000000000000000;
    check = s21_floor(src, &result);
    check_origin = 0;
    // origin = -1;
    origin.bits[0] = 0b00000000000000000000000000000001;
    origin.bits[1] = 0b00000000000000000000000000000000;
    origin.bits[2] = 0b00000000000000000000000000000000;
    origin.bits[3] = 0b10000000000000000000000000000000;
    ck_assert_int_eq(origin.bits[3], result.bits[3]);
    ck_assert_int_eq(origin.bits[2], result.bits[2]);
    ck_assert_int_eq(origin.bits[1], result.bits[1]);
    ck_assert_int_eq(origin.bits[0], result.bits[0]);
    ck_assert_int_eq(check, check_origin);


#test S21_FLOOR_11
    s21_decimal src, origin, result;
    int check = 0;
    int check_origin = 0;
    // src = 652.34631;
    src.bits[0] = 0b00000011111000110110011011000111;
    src.bits[1] = 0b00000000000000000000000000000000;
    src.bits[2] = 0b00000000000000000000000000000000;
    src.bits[3] = 0b00000000000001010000000000000000;
    check = s21_floor(src, &result);
    check_origin = 0;
    // origin = 652;
    origin.bits[0] = 0b00000000000000000000001010001100;
    origin.bits[1] = 0b00000000000000000000000000000000;
    origin.bits[2] = 0b00000000000000000000000000000000;
    origin.bits[3] = 0b00000000000000000000000000000000;
    ck_assert_int_eq(origin.bits[3], result.bits[3]);
    ck_assert_int_eq(origin.bits[2], result.bits[2]);
    ck_assert_int_eq(origin.bits[1], result.bits[1]);
    ck_assert_int_eq(origin.bits[0], result.bits[0]);
    ck_assert_int_eq(check, check_origin);

    // src = 4.97623323;
    src.bits[0] = 0b00011101101010010010000100011011;
    src.bits[1] = 0b00000000000000000000000000000000;
    src.bits[2] = 0b00000000000000000000000000000000;
    src.bits[3] = 0b00000000000010000000000000000000;
    check = s21_floor(src, &result);
    check_origin = 0;
    // origin = 4;
    origin.bits[0] = 0b00000000000000000000000000000100;
    origin.bits[1] = 0b00000000000000000000000000000000;
    origin.bits[2] = 0b00000000000000000000000000000000;
    origin.bits[3] = 0b00000000000000000000000000000000;
    ck_assert_int_eq(origin.bits[3], result.bits[3]);
    ck_assert_int_eq(origin.bits[2], result.bits[2]);
    ck_assert_int_eq(origin.bits[1], result.bits[1]);
    ck_assert_int_eq(origin.bits[0], result.bits[0]);
    ck_assert_int_eq(check, check_origin);


#test S21_FLOOR_12
    s21_decimal src, origin, result;
    int check = 0;
    int check_origin = 0;
    // src = 65658654.59;
    src.bits[0] = 0b10000111010110110010011111110011;
    src.bits[1] = 0b00000000000000000000000000000001;
    src.bits[2] = 0b00000000000000000000000000000000;
    src.bits[3] = 0b00000000000000100000000000000000;
    check = s21_floor(src, &result);
    check_origin = 0;
    // origin = 65658654;
    origin.bits[0] = 0b00000011111010011101111100011110;
    origin.bits[1] = 0b00000000000000000000000000000000;
    origin.bits[2] = 0b00000000000000000000000000000000;
    origin.bits[3] = 0b00000000000000000000000000000000;
    ck_assert_int_eq(origin.bits[3], result.bits[3]);
    ck_assert_int_eq(origin.bits[2], result.bits[2]);
    ck_assert_int_eq(origin.bits[1], result.bits[1]);
    ck_assert_int_eq(origin.bits[0], result.bits[0]);
    ck_assert_int_eq(check, check_origin);

    // src = -364748.110;
    src.bits[0] = 0b00010101101111011001110101001110;
    src.bits[1] = 0b00000000000000000000000000000000;
    src.bits[2] = 0b00000000000000000000000000000000;
    src.bits[3] = 0b10000000000000110000000000000000;
    check = s21_floor(src, &result);
    check_origin = 0;
    // origin = -364749;
    origin.bits[0] = 0b00000000000001011001000011001101;
    origin.bits[1] = 0b00000000000000000000000000000000;
    origin.bits[2] = 0b00000000000000000000000000000000;
    origin.bits[3] = 0b10000000000000000000000000000000;
    ck_assert_int_eq(origin.bits[3], result.bits[3]);
    ck_assert_int_eq(origin.bits[2], result.bits[2]);
    ck_assert_int_eq(origin.bits[1], result.bits[1]);
    ck_assert_int_eq(origin.bits[0], result.bits[0]);
    ck_assert_int_eq(check, check_origin);


#test S21_FLOOR_13
    s21_decimal src, origin, result;
    int check = 0;
    int check_origin = 0;
    // src = 1.9874565432111;
    src.bits[0] = 0b01101000011010011010001100101111;
    src.bits[1] = 0b00000000000000000001001000010011;
    src.bits[2] = 0b00000000000000000000000000000000;
    src.bits[3] = 0b00000000000011010000000000000000;
    check = s21_floor(src, &result);
    check_origin = 0;
    // origin = 1;
    origin.bits[0] = 0b00000000000000000000000000000001;
    origin.bits[1] = 0b00000000000000000000000000000000;
    origin.bits[2] = 0b00000000000000000000000000000000;
    origin.bits[3] = 0b00000000000000000000000000000000;
    ck_assert_int_eq(origin.bits[3], result.bits[3]);
    ck_assert_int_eq(origin.bits[2], result.bits[2]);
    ck_assert_int_eq(origin.bits[1], result.bits[1]);
    ck_assert_int_eq(origin.bits[0], result.bits[0]);
    ck_assert_int_eq(check, check_origin);

    // src = -98.78798789312;
    src.bits[0] = 0b00010110010010101110101011000000;
    src.bits[1] = 0b00000000000000000000100011111100;
    src.bits[2] = 0b00000000000000000000000000000000;
    src.bits[3] = 0b10000000000010110000000000000000;
    check = s21_floor(src, &result);
    check_origin = 0;
    // origin = -99;
    origin.bits[0] = 0b00000000000000000000000001100011;
    origin.bits[1] = 0b00000000000000000000000000000000;
    origin.bits[2] = 0b00000000000000000000000000000000;
    origin.bits[3] = 0b10000000000000000000000000000000;
    ck_assert_int_eq(origin.bits[3], result.bits[3]);
    ck_assert_int_eq(origin.bits[2], result.bits[2]);
    ck_assert_int_eq(origin.bits[1], result.bits[1]);
    ck_assert_int_eq(origin.bits[0], result.bits[0]);
    ck_assert_int_eq(check, check_origin);


#test S21_FLOOR_14
    s21_decimal src, origin, result;
    int check = 0;
    int check_origin = 0;
    // src = 999999999999999999911.3;
    src.bits[0] = 0b10110010001111111111110010001001;
    src.bits[1] = 0b00011001111000001100100110111010;
    src.bits[2] = 0b00000000000000000000001000011110;
    src.bits[3] = 0b00000000000000010000000000000000;
    check = s21_floor(src, &result);
    check_origin = 0;
    // origin = 999999999999999999911;
    origin.bits[0] = 0b11011110100111111111111110100111;
    origin.bits[1] = 0b00110101110010011010110111000101;
    origin.bits[2] = 0b00000000000000000000000000110110;
    origin.bits[3] = 0b00000000000000000000000000000000;
    ck_assert_int_eq(origin.bits[3], result.bits[3]);
    ck_assert_int_eq(origin.bits[2], result.bits[2]);
    ck_assert_int_eq(origin.bits[1], result.bits[1]);
    ck_assert_int_eq(origin.bits[0], result.bits[0]);
    ck_assert_int_eq(check, check_origin);

    // src = -545454512454545.35265454545645;
    src.bits[0] = 0b10000010111000100101101011101101;
    src.bits[1] = 0b11111001111010000010010110101101;
    src.bits[2] = 0b10110000001111101111000010010100;
    src.bits[3] = 0b10000000000011100000000000000000;
    check = s21_floor(src, &result);
    check_origin = 0;
    // origin = -545454512454546;
    origin.bits[0] = 0b10000110011101001011101110010010;
    origin.bits[1] = 0b00000000000000011111000000010110;
    origin.bits[2] = 0b00000000000000000000000000000000;
    origin.bits[3] = 0b10000000000000000000000000000000;
    ck_assert_int_eq(origin.bits[3], result.bits[3]);
    ck_assert_int_eq(origin.bits[2], result.bits[2]);
    ck_assert_int_eq(origin.bits[1], result.bits[1]);
    ck_assert_int_eq(origin.bits[0], result.bits[0]);
    ck_assert_int_eq(check, check_origin);


#test S21_FLOOR_15
    s21_decimal src, origin, result;
    int check = 0;
    int check_origin = 0;
    // src = 545454512454545.35265454545645;
    src.bits[0] = 0b10000010111000100101101011101101;
    src.bits[1] = 0b11111001111010000010010110101101;
    src.bits[2] = 0b10110000001111101111000010010100;
    src.bits[3] = 0b00000000000011100000000000000000;
    check = s21_floor(src, &result);
    check_origin = 0;
    // origin = 545454512454545;
    origin.bits[0] = 0b10000110011101001011101110010001;
    origin.bits[1] = 0b00000000000000011111000000010110;
    origin.bits[2] = 0b00000000000000000000000000000000;
    origin.bits[3] = 0b00000000000000000000000000000000;
    ck_assert_int_eq(origin.bits[3], result.bits[3]);
    ck_assert_int_eq(origin.bits[2], result.bits[2]);
    ck_assert_int_eq(origin.bits[1], result.bits[1]);
    ck_assert_int_eq(origin.bits[0], result.bits[0]);
    ck_assert_int_eq(check, check_origin);

    // src = 7961327845421.879754123131254;
    src.bits[0] = 0b01001110111001000011100101110110;
    src.bits[1] = 0b01001011001101011010000111011001;
    src.bits[2] = 0b00011001101110010111010010111111;
    src.bits[3] = 0b00000000000011110000000000000000;
    check = s21_floor(src, &result);
    check_origin = 0;
    // origin = 7961327845421;
    origin.bits[0] = 0b10100100000111100100000000101101;
    origin.bits[1] = 0b00000000000000000000011100111101;
    origin.bits[2] = 0b00000000000000000000000000000000;
    origin.bits[3] = 0b00000000000000000000000000000000;
    ck_assert_int_eq(origin.bits[3], result.bits[3]);
    ck_assert_int_eq(origin.bits[2], result.bits[2]);
    ck_assert_int_eq(origin.bits[1], result.bits[1]);
    ck_assert_int_eq(origin.bits[0], result.bits[0]);
    ck_assert_int_eq(check, check_origin);


#test S21_FLOOR_16
    s21_decimal src, origin, result;
    int check = 0;
    int check_origin = 0;
    // src = 12345677.987654345678987654346;
    src.bits[0] = 0b10010001000010101111010011001010;
    src.bits[1] = 0b11000000010001011101010111110010;
    src.bits[2] = 0b00100111111001000001101100000000;
    src.bits[3] = 0b00000000000101010000000000000000;
    check = s21_floor(src, &result);
    check_origin = 0;
    // origin = 12345677;
    origin.bits[0] = 0b00000000101111000110000101001101;
    origin.bits[1] = 0b00000000000000000000000000000000;
    origin.bits[2] = 0b00000000000000000000000000000000;
    origin.bits[3] = 0b00000000000000000000000000000000;
    ck_assert_int_eq(origin.bits[3], result.bits[3]);
    ck_assert_int_eq(origin.bits[2], result.bits[2]);
    ck_assert_int_eq(origin.bits[1], result.bits[1]);
    ck_assert_int_eq(origin.bits[0], result.bits[0]);
    ck_assert_int_eq(check, check_origin);

    // src = -12345677.987654345678987654346;
    src.bits[0] = 0b10010001000010101111010011001010;
    src.bits[1] = 0b11000000010001011101010111110010;
    src.bits[2] = 0b00100111111001000001101100000000;
    src.bits[3] = 0b10000000000101010000000000000000;
    check = s21_floor(src, &result);
    check_origin = 0;
    // origin = -12345678;
    origin.bits[0] = 0b00000000101111000110000101001110;
    origin.bits[1] = 0b00000000000000000000000000000000;
    origin.bits[2] = 0b00000000000000000000000000000000;
    origin.bits[3] = 0b10000000000000000000000000000000;
    ck_assert_int_eq(origin.bits[3], result.bits[3]);
    ck_assert_int_eq(origin.bits[2], result.bits[2]);
    ck_assert_int_eq(origin.bits[1], result.bits[1]);
    ck_assert_int_eq(origin.bits[0], result.bits[0]);
    ck_assert_int_eq(check, check_origin);


#test S21_FLOOR_17
    s21_decimal src, origin, result;
    int check = 0;
    int check_origin = 0;
    // src = 87654323456.9876545678987653;
    src.bits[0] = 0b00010001110011011101000110000101;
    src.bits[1] = 0b11110101101111000110111111000000;
    src.bits[2] = 0b00000010110101010000111100111111;
    src.bits[3] = 0b00000000000100000000000000000000;
    check = s21_floor(src, &result);
    check_origin = 0;
    // origin = 87654323456;
    origin.bits[0] = 0b01101000100110101101010100000000;
    origin.bits[1] = 0b00000000000000000000000000010100;
    origin.bits[2] = 0b00000000000000000000000000000000;
    origin.bits[3] = 0b00000000000000000000000000000000;
    ck_assert_int_eq(origin.bits[3], result.bits[3]);
    ck_assert_int_eq(origin.bits[2], result.bits[2]);
    ck_assert_int_eq(origin.bits[1], result.bits[1]);
    ck_assert_int_eq(origin.bits[0], result.bits[0]);
    ck_assert_int_eq(check, check_origin);

    // src = 336565445454313.859865545;
    src.bits[0] = 0b00111110111111000101101111001001;
    src.bits[1] = 0b00111111110101011110000010001011;
    src.bits[2] = 0b00000000000000000100011101000101;
    src.bits[3] = 0b00000000000010010000000000000000;
    check = s21_floor(src, &result);
    check_origin = 0;
    // origin = 336565445454313;
    origin.bits[0] = 0b10111111110100011110100111101001;
    origin.bits[1] = 0b00000000000000010011001000011010;
    origin.bits[2] = 0b00000000000000000000000000000000;
    origin.bits[3] = 0b00000000000000000000000000000000;
    ck_assert_int_eq(origin.bits[3], result.bits[3]);
    ck_assert_int_eq(origin.bits[2], result.bits[2]);
    ck_assert_int_eq(origin.bits[1], result.bits[1]);
    ck_assert_int_eq(origin.bits[0], result.bits[0]);
    ck_assert_int_eq(check, check_origin);

    // src = -15456451234534;
    src.bits[0] = 0b10111100010010010000101011100110;
    src.bits[1] = 0b00000000000000000000111000001110;
    src.bits[2] = 0b00000000000000000000000000000000;
    src.bits[3] = 0b10000000000000000000000000000000;
    check = s21_floor(src, &result);
    check_origin = 0;
    // origin = -15456451234534;
    origin.bits[0] = 0b10111100010010010000101011100110;
    origin.bits[1] = 0b00000000000000000000111000001110;
    origin.bits[2] = 0b00000000000000000000000000000000;
    origin.bits[3] = 0b10000000000000000000000000000000;
    ck_assert_int_eq(origin.bits[3], result.bits[3]);
    ck_assert_int_eq(origin.bits[2], result.bits[2]);
    ck_assert_int_eq(origin.bits[1], result.bits[1]);
    ck_assert_int_eq(origin.bits[0], result.bits[0]);
    ck_assert_int_eq(check, check_origin);


#test S21_FLOOR_18
    s21_decimal src, origin, result;
    int check = 0;
    int check_origin = 0;
    // src = -0.42354543545;
    src.bits[0] = 0b11011100100001110000101110111001;
    src.bits[1] = 0b00000000000000000000000000001001;
    src.bits[2] = 0b00000000000000000000000000000000;
    src.bits[3] = 0b10000000000010110000000000000000;
    check = s21_floor(src, &result);
    check_origin = 0;
    // origin = -1;
    origin.bits[0] = 0b00000000000000000000000000000001;
    origin.bits[1] = 0b00000000000000000000000000000000;
    origin.bits[2] = 0b00000000000000000000000000000000;
    origin.bits[3] = 0b10000000000000000000000000000000;
    ck_assert_int_eq(origin.bits[3], result.bits[3]);
    ck_assert_int_eq(origin.bits[2], result.bits[2]);
    ck_assert_int_eq(origin.bits[1], result.bits[1]);
    ck_assert_int_eq(origin.bits[0], result.bits[0]);
    ck_assert_int_eq(check, check_origin);

    // src = 79228162514264337593543950335;
    src.bits[0] = 0b11111111111111111111111111111111;
    src.bits[1] = 0b11111111111111111111111111111111;
    src.bits[2] = 0b11111111111111111111111111111111;
    src.bits[3] = 0b00000000000000000000000000000000;
    check = s21_floor(src, &result);
    check_origin = 0;
    // origin = 79228162514264337593543950335;
    origin.bits[0] = 0b11111111111111111111111111111111;
    origin.bits[1] = 0b11111111111111111111111111111111;
    origin.bits[2] = 0b11111111111111111111111111111111;
    origin.bits[3] = 0b00000000000000000000000000000000;
    ck_assert_int_eq(origin.bits[3], result.bits[3]);
    ck_assert_int_eq(origin.bits[2], result.bits[2]);
    ck_assert_int_eq(origin.bits[1], result.bits[1]);
    ck_assert_int_eq(origin.bits[0], result.bits[0]);
    ck_assert_int_eq(check, check_origin);


#test S21_FLOOR_19
    s21_decimal src, origin, result;
    int check = 0;
    int check_origin = 0;
    // src = 2.7986531268974139743;
    src.bits[0] = 0b11111110100100001101100101011111;
    src.bits[1] = 0b10000100011001000010000111101000;
    src.bits[2] = 0b00000000000000000000000000000001;
    src.bits[3] = 0b00000000000100110000000000000000;
    check = s21_floor(src, &result);
    check_origin = 0;
    // origin = 2;
    origin.bits[0] = 0b00000000000000000000000000000010;
    origin.bits[1] = 0b00000000000000000000000000000000;
    origin.bits[2] = 0b00000000000000000000000000000000;
    origin.bits[3] = 0b00000000000000000000000000000000;
    ck_assert_int_eq(origin.bits[3], result.bits[3]);
    ck_assert_int_eq(origin.bits[2], result.bits[2]);
    ck_assert_int_eq(origin.bits[1], result.bits[1]);
    ck_assert_int_eq(origin.bits[0], result.bits[0]);
    ck_assert_int_eq(check, check_origin);

    // src = 0;
    src.bits[0] = 0b00000000000000000000000000000000;
    src.bits[1] = 0b00000000000000000000000000000000;
    src.bits[2] = 0b00000000000000000000000000000000;
    src.bits[3] = 0b00000000000000000000000000000000;
    check = s21_floor(src, &result);
    check_origin = 0;
    // origin = 0;
    origin.bits[0] = 0b00000000000000000000000000000000;
    origin.bits[1] = 0b00000000000000000000000000000000;
    origin.bits[2] = 0b00000000000000000000000000000000;
    origin.bits[3] = 0b00000000000000000000000000000000;
    ck_assert_int_eq(origin.bits[3], result.bits[3]);
    ck_assert_int_eq(origin.bits[2], result.bits[2]);
    ck_assert_int_eq(origin.bits[1], result.bits[1]);
    ck_assert_int_eq(origin.bits[0], result.bits[0]);
    ck_assert_int_eq(check, check_origin);


#test S21_FROM_DECIMAL_TO_FLOAT_1
    s21_decimal value_01 = {{4294967295, 4294967295, 4294967295, 0x80000000}};  // -79 228 162 514 264 337 593 543 950 335
    float dst_01 = 0.0;
    float res_01 = -79228162514264337593543950335.000000;
    ck_assert_int_eq(s21_from_decimal_to_float(value_01, &dst_01), 0);
    ck_assert_float_eq(dst_01, res_01);

    s21_decimal value_02 = {{4294967295, 4294967295, 4294967295, 0x801C0000}};  // -79 228 162 514 264 337 593 543 950 335        -28
    float dst_02 = 0.0;
    float res_02 = -7.9228162514264337593543950335;
    ck_assert_int_eq(s21_from_decimal_to_float(value_02, &dst_02), 0);
    ck_assert_float_eq(dst_02, res_02);

    s21_decimal value_03 = {{0, 0, 4294967295, 0x800F0000}};                    // -79 228 162 495 817 593 519 834 398 720        -15
    float dst_03 = 0.0;
    float res_03 = -79228160000000.0;
    ck_assert_int_eq(s21_from_decimal_to_float(value_03, &dst_03), 0);
    ck_assert_float_eq(dst_03, res_03);
#test S21_FROM_DECIMAL_TO_FLOAT_2
    s21_decimal value_04 = {{4294967295, 4294967295, 536870911, 0x80190000}};   // -9 903 520 314 283 042 199 192 993 791         -25
    float dst_04 = 0.0;
    float res_04 = -990.3520314283042199192993791;
    ck_assert_int_eq(s21_from_decimal_to_float(value_04, &dst_04), 0);
    ck_assert_float_eq(dst_04, res_04);

    s21_decimal value_05 = {{4294967295, 4294967295, 0, 0x801C0000}};           // -18 446 744 073 709 551 615                    -28
    float dst_05 = 0.0;
    float res_05 = -0.0000000018446744073709551615;
    ck_assert_int_eq(s21_from_decimal_to_float(value_05, &dst_05), 0);
    ck_assert_float_eq(dst_05, res_05);

    s21_decimal value_06 = {{0, 4294967295, 0, 0x80000000}};                    // -18 446 744 069 414 584 320
    float dst_06 = 0.0;
    float res_06 = -18446744069414584320.0;
    ck_assert_int_eq(s21_from_decimal_to_float(value_06, &dst_06), 0);
    ck_assert_float_eq(dst_06, res_06);
#test S21_FROM_DECIMAL_TO_FLOAT_3
    s21_decimal value_07 = {{4294967295, 0, 0, 0x80000000}};                    // -4 294 967 295
    float dst_07 = 0.0;
    float res_07 = -4294967295.0;
    ck_assert_int_eq(s21_from_decimal_to_float(value_07, &dst_07), 0);
    ck_assert_float_eq(dst_07, res_07);

    s21_decimal value_08 = {{2147483647, 0, 0, 0x80000000}};                    // -2 147 483 647
    float dst_08 = 0.0;
    float res_08 = -2147483647.0;
    ck_assert_int_eq(s21_from_decimal_to_float(value_08, &dst_08), 0);
    ck_assert_float_eq(dst_08, res_08);

    s21_decimal value_09 = {{1, 0, 0, 0x80000000}};                             // -1
    float dst_09 = 0.0;
    float res_09 = -1.0;
    ck_assert_int_eq(s21_from_decimal_to_float(value_09, &dst_09), 0);
    ck_assert_float_eq(dst_09, res_09);
#test S21_FROM_DECIMAL_TO_FLOAT_4
    s21_decimal value_10 = {{0, 0, 0, 0x80000000}};                             // -0
    float dst_10 = -0.0;
    float res_10 = 0.0;
    ck_assert_int_eq(s21_from_decimal_to_float(value_10, &dst_10), 0);
    ck_assert_float_eq(dst_10, res_10);

    s21_decimal value_11 = {{0, 0, 0, 0x00000000}};                             //  0
    float dst_11 = 0.0;
    float res_11 = 0.0;
    ck_assert_int_eq(s21_from_decimal_to_float(value_11, &dst_11), 0);
    ck_assert_float_eq(dst_11, res_11);

    s21_decimal value_12 = {{1, 0, 0, 0x00000000}};                             //  1
    float dst_12 = 0.0;
    float res_12 = 1.0;
    ck_assert_int_eq(s21_from_decimal_to_float(value_12, &dst_12), 0);
    ck_assert_float_eq(dst_12, res_12);
#test S21_FROM_DECIMAL_TO_FLOAT_5
    s21_decimal value_13 = {{2147483647, 0, 0, 0}};                             //  2 147 483 647
    float dst_13 = 0.0;
    float res_13 = 2147483647.0;
    ck_assert_int_eq(s21_from_decimal_to_float(value_13, &dst_13), 0);
    ck_assert_float_eq(dst_13, res_13);

    s21_decimal value_14 = {{4294967295, 0, 0, 0x00000000}};                    //  4 294 967 295
    float dst_14 = 0.0;
    float res_14 = 4294967295.0;
    ck_assert_int_eq(s21_from_decimal_to_float(value_14, &dst_14), 0);
    ck_assert_float_eq(dst_14, res_14);

    s21_decimal value_15 = {{0, 4294967295, 0, 0x00000000}};                    //  18 446 744 069 414 584 320
    float dst_15 = 0.0;
    float res_15 = 18446744069414584320.0;
    ck_assert_int_eq(s21_from_decimal_to_float(value_15, &dst_15), 0);
    ck_assert_float_eq(dst_15, res_15);
#test S21_FROM_DECIMAL_TO_FLOAT_6
    s21_decimal value_16 = {{4294967295, 4294967295, 0, 0x00000000}};           //  18 446 744 073 709 551 615
    float dst_16 = 0.0;
    float res_16 = 18446744073709551615.0;
    ck_assert_int_eq(s21_from_decimal_to_float(value_16, &dst_16), 0);
    ck_assert_float_eq(dst_16, res_16);

    s21_decimal value_17 = {{4294967295, 4294967295, 536870911, 0x00000000}};   //  9 903 520 314 283 042 199 192 993 791
    float dst_17 = 0.0;
    float res_17 = 9903520314283042199192993791.0;
    ck_assert_int_eq(s21_from_decimal_to_float(value_17, &dst_17), 0);
    ck_assert_float_eq(dst_17, res_17);

    s21_decimal value_18 = {{0, 0, 4294967295, 0x00000000}};                    //  79 228 162 495 817 593 519 834 398 720
    float dst_18 = 0.0;
    float res_18 = 79228162495817593519834398720.0;
    ck_assert_int_eq(s21_from_decimal_to_float(value_18, &dst_18), 0);
    ck_assert_float_eq(dst_18, res_18);
#test S21_FROM_DECIMAL_TO_FLOAT_7
    s21_decimal value_19 = {{0, 4294967295, 4294967295, 0x00000000}};           //  79 228 162 514 264 337 589 248 983 040
    float dst_19 = 0.0;
    float res_19 = 79228162514264337589248983040.0;
    ck_assert_int_eq(s21_from_decimal_to_float(value_19, &dst_19), 0);
    ck_assert_float_eq(dst_19, res_19);

    s21_decimal value_20 = {{4294967295, 4294967295, 4294967295, 0x00000000}};  //  79 228 162 514 264 337 593 543 950 335
    float dst_20 = 0.0;
    float res_20 = 79228162514264337593543950335.0;
    ck_assert_int_eq(s21_from_decimal_to_float(value_20, &dst_20), 0);
    ck_assert_float_eq(dst_20, res_20);
    
    s21_decimal value_21 = {{0, 0, 0, 0x80FF0000}};                              // -INF
    float dst_21 = 0.0;
    float res_21 = 0.0;
    ck_assert_int_eq(s21_from_decimal_to_float(value_21, &dst_21), 1);         //  Вернулась 1 (ошибка)
    ck_assert_float_eq(dst_21, res_21);
#test S21_FROM_DECIMAL_TO_FLOAT_8
    s21_decimal value_22 = {{0, 0, 0, 0x00FF0000}};                              // +INF
    float dst_22 = 0.0;
    float res_22 = 0.0;
    ck_assert_int_eq(s21_from_decimal_to_float(value_22, &dst_22), 1);         //  Вернулась 1 (ошибка)
    ck_assert_float_eq(dst_22, res_22);

    s21_decimal value_23 = {{1431655765, 1431655765, 1431655765, 0x80FF0000}};  //  NaN (диапазон от (-1)*10^(-28) до 1*10^(-28), но !=0)
    float dst_23 = 0.0;
    ck_assert_int_eq(s21_from_decimal_to_float(value_23, &dst_23), 1);         //  Вернулась 1 (ошибка)
    ck_assert_float_eq(dst_22, res_22);

    s21_decimal value_24 = {{4294967295, 4294967295, 0, 0x801D0000}};           // -18 446 744 073 709 551 615                    -29
    float dst_24 = 0.0;
    float res_24 = -0.0;
    ck_assert_int_eq(s21_from_decimal_to_float(value_24, &dst_24), 1);
    ck_assert_float_eq(dst_24, res_24);

#test S21_FROM_DECIMAL_TO_FLOAT_9
    s21_decimal a, b, c, e;
    /*
    * a = 71776119061217.280
    */
    a.bits[0] = 0b00000000000000000000000000000000;
    a.bits[1] = 0b00000000111111110000000000000000;
    a.bits[2] = 0b00000000000000000000000000000000;
    a.bits[3] = 0b00000000000000110000000000000000;
    /*
    *b = -0.00024
    */
    b.bits[0] = 0b00000000000000000000000000011000;
    b.bits[1] = 0b00000000000000000000000000000000;
    b.bits[2] = 0b00000000000000000000000000000000;
    b.bits[3] = 0x80050000;
    /*
    c* = 563.75832
    */
    c.bits[0] = 0b00000011010111000011101000011000;
    c.bits[1] = 0b00000000000000000000000000000000;
    c.bits[2] = 0b00000000000000000000000000000000;
    c.bits[3] = 0b00000000000001010000000000000000;
    /*
    *e = 0.0000000000000000049836243985
    */
    e.bits[0] = 0b10011010011110001011110000010001;
    e.bits[1] = 0b00000000000000000000000000001011;
    e.bits[2] = 0b00000000000000000000000000000000;
    e.bits[3] = 0x001C0000;
    float res_1, res_2, res_3, res_5, num_1, num_2, num_3, num_5;
    num_1 = 71776119061217.280;
    num_2 = -0.00024;
    num_3 = 563.75832;
    num_5 = 0.000000000000000000049836243985;
    int value_1 = s21_from_decimal_to_float(a, &res_1);
    int value_2 = s21_from_decimal_to_float(b, &res_2);
    int value_3 = s21_from_decimal_to_float(c, &res_3);
    // int value_4 = s21_from_decimal_to_float(d, &res_4);
    int value_5 = s21_from_decimal_to_float(e, &res_5);
    ck_assert_float_eq(res_1, num_1);
    ck_assert_int_eq(value_1, VALUE_OK);
    ck_assert_float_eq_tol(res_2, num_2, 1e-07);
    ck_assert_int_eq(value_2, VALUE_OK);
    ck_assert_float_eq(res_3, num_3);
    ck_assert_int_eq(value_3, VALUE_OK);
    // ck_assert_float_eq(res_4, num_4);
    // ck_assert_int_eq(value_4, VALUE_OK);
    ck_assert_float_eq_tol(res_5, num_5, 1e-07);
    ck_assert_int_eq(value_5, VALUE_OK);
#test S21_FROM_DECIMAL_TO_FLOAT_10
    s21_decimal number;
    int result_int = 0;
    int result_error = 0;
    int my_error = 0;
    int my_int = 0;
    float my_float = 0;
    // decimal: 2.0
    // float: 2
    // int: 1073741824
    number.bits[0] = 0b00000000000000000000000000010100;
    number.bits[1] = 0b00000000000000000000000000000000;
    number.bits[2] = 0b00000000000000000000000000000000;
    number.bits[3] = 0b00000000000000010000000000000000;
    result_int = 1073741824;
    result_error = 0;
    my_error = s21_from_decimal_to_float(number, &my_float);
    my_int = *((unsigned int *) &my_float);
    ck_assert_int_eq(result_int, my_int);
    ck_assert_int_eq(result_error, my_error);
#test S21_FROM_DECIMAL_TO_FLOAT_11
    s21_decimal number;
    int result_int = 0;
    int result_error = 0;
    int my_error = 0;
    int my_int = 0;
    float my_float = 0;
    // decimal: -0.8
    // float: -0.8
    // int: -1085485875
    number.bits[0] = 0b00000000000000000000000000001000;
    number.bits[1] = 0b00000000000000000000000000000000;
    number.bits[2] = 0b00000000000000000000000000000000;
    number.bits[3] = 0b10000000000000010000000000000000;
    result_int = -1085485875;
    result_error = 0;
    my_error = s21_from_decimal_to_float(number, &my_float);
    my_int = *((unsigned int *) &my_float);
    ck_assert_int_eq(result_int, my_int);
    ck_assert_int_eq(result_error, my_error);
#test S21_FROM_DECIMAL_TO_FLOAT_12
    s21_decimal number;
    int result_int = 0;
    int result_error = 0;
    int my_error = 0;
    int my_int = 0;
    float my_float = 0;
    // decimal: 0
    // float: 0
    // int: 0
    number.bits[0] = 0b00000000000000000000000000000000;
    number.bits[1] = 0b00000000000000000000000000000000;
    number.bits[2] = 0b00000000000000000000000000000000;
    number.bits[3] = 0b00000000000000000000000000000000;
    result_int = 0;
    result_error = 0;
    my_error = s21_from_decimal_to_float(number, &my_float);
    my_int = *((unsigned int *) &my_float);
    ck_assert_int_eq(result_int, my_int);
    ck_assert_int_eq(result_error, my_error);
#test S21_FROM_DECIMAL_TO_FLOAT_13
    s21_decimal number;
    int result_int = 0;
    int result_error = 0;
    int my_error = 0;
    int my_int = 0;
    float my_float = 0;
    // decimal: 1
    // float: 1
    // int: 1065353216
    number.bits[0] = 0b00000000000000000000000000000001;
    number.bits[1] = 0b00000000000000000000000000000000;
    number.bits[2] = 0b00000000000000000000000000000000;
    number.bits[3] = 0b00000000000000000000000000000000;
    result_int = 1065353216;
    result_error = 0;
    my_error = s21_from_decimal_to_float(number, &my_float);
    my_int = *((unsigned int *) &my_float);
    ck_assert_int_eq(result_int, my_int);
    ck_assert_int_eq(result_error, my_error);
#test S21_FROM_DECIMAL_TO_FLOAT_14
    s21_decimal number;
    int result_int = 0;
    int result_error = 0;
    int my_error = 0;
    int my_int = 0;
    float my_float = 0;
    // decimal: -1.75
    // float: -1.75
    // int: -1075838976
    number.bits[0] = 0b00000000000000000000000010101111;
    number.bits[1] = 0b00000000000000000000000000000000;
    number.bits[2] = 0b00000000000000000000000000000000;
    number.bits[3] = 0b10000000000000100000000000000000;
    result_int = -1075838976;
    result_error = 0;
    my_error = s21_from_decimal_to_float(number, &my_float);
    my_int = *((unsigned int *) &my_float);
    ck_assert_int_eq(result_int, my_int);
    ck_assert_int_eq(result_error, my_error);
#test S21_FROM_DECIMAL_TO_FLOAT_15
    s21_decimal number;
    int result_int = 0;
    int result_error = 0;
    int my_error = 0;
    int my_int = 0;
    float my_float = 0;
    // decimal: 6521
    // float: 6521
    // int: 1170982912
    number.bits[0] = 0b00000000000000000001100101111001;
    number.bits[1] = 0b00000000000000000000000000000000;
    number.bits[2] = 0b00000000000000000000000000000000;
    number.bits[3] = 0b00000000000000000000000000000000;
    result_int = 1170982912;
    result_error = 0;
    my_error = s21_from_decimal_to_float(number, &my_float);
    my_int = *((unsigned int *) &my_float);
    ck_assert_int_eq(result_int, my_int);
    ck_assert_int_eq(result_error, my_error);
#test S21_FROM_DECIMAL_TO_FLOAT_16
    s21_decimal number;
    int result_int = 0;
    int result_error = 0;
    int my_error = 0;
    int my_int = 0;
    float my_float = 0;
    // decimal: 4
    // float: 4
    // int: 1082130432
    number.bits[0] = 0b00000000000000000000000000000100;
    number.bits[1] = 0b00000000000000000000000000000000;
    number.bits[2] = 0b00000000000000000000000000000000;
    number.bits[3] = 0b00000000000000000000000000000000;
    result_int = 1082130432;
    result_error = 0;
    my_error = s21_from_decimal_to_float(number, &my_float);
    my_int = *((unsigned int *) &my_float);
    ck_assert_int_eq(result_int, my_int);
    ck_assert_int_eq(result_error, my_error);
#test S21_FROM_DECIMAL_TO_FLOAT_17
    s21_decimal number;
    int result_int = 0;
    int result_error = 0;
    int my_error = 0;
    int my_int = 0;
    float my_float = 0;
    // decimal: 65658654
    // float: 6.565866E+07
    // int: 1283094472
    number.bits[0] = 0b00000011111010011101111100011110;
    number.bits[1] = 0b00000000000000000000000000000000;
    number.bits[2] = 0b00000000000000000000000000000000;
    number.bits[3] = 0b00000000000000000000000000000000;
    result_int = 1283094472;
    result_error = 0;
    my_error = s21_from_decimal_to_float(number, &my_float);
    my_int = *((unsigned int *) &my_float);
    ck_assert_int_eq(result_int, my_int);
    ck_assert_int_eq(result_error, my_error);
#test S21_FROM_DECIMAL_TO_FLOAT_18
    s21_decimal number;
    int result_int = 0;
    int result_error = 0;
    int my_error = 0;
    int my_int = 0;
    float my_float = 0;
    // decimal: -364748
    // float: -364748
    // int: -927852160
    number.bits[0] = 0b00000000000001011001000011001100;
    number.bits[1] = 0b00000000000000000000000000000000;
    number.bits[2] = 0b00000000000000000000000000000000;
    number.bits[3] = 0b10000000000000000000000000000000;
    result_int = -927852160;
    result_error = 0;
    my_error = s21_from_decimal_to_float(number, &my_float);
    my_int = *((unsigned int *) &my_float);
    ck_assert_int_eq(result_int, my_int);
    ck_assert_int_eq(result_error, my_error);
#test S21_FROM_DECIMAL_TO_FLOAT_19
    s21_decimal number;
    int result_int = 0;
    int result_error = 0;
    int my_error = 0;
    int my_int = 0;
    float my_float = 0;
    // decimal: 0.003
    // float: 0.003
    // int: 994352038
    number.bits[0] = 0b00000000000000000000000000000011;
    number.bits[1] = 0b00000000000000000000000000000000;
    number.bits[2] = 0b00000000000000000000000000000000;
    number.bits[3] = 0b00000000000000110000000000000000;
    result_int = 994352038;
    result_error = 0;
    my_error = s21_from_decimal_to_float(number, &my_float);
    my_int = *((unsigned int *) &my_float);
    ck_assert_int_eq(result_int, my_int);
    ck_assert_int_eq(result_error, my_error);
#test S21_FROM_DECIMAL_TO_FLOAT_20
    s21_decimal number;
    int result_int = 0;
    int result_error = 0;
    int my_error = 0;
    int my_int = 0;
    float my_float = 0;
    // decimal: -9878798789
    // float: -9.878798E+09
    // int: -804047712
    number.bits[0] = 0b01001100110100101000000111000101;
    number.bits[1] = 0b00000000000000000000000000000010;
    number.bits[2] = 0b00000000000000000000000000000000;
    number.bits[3] = 0b10000000000000000000000000000000;
    result_int = -804047712;
    result_error = 0;
    my_error = s21_from_decimal_to_float(number, &my_float);
    my_int = *((unsigned int *) &my_float);
    ck_assert_int_eq(result_int, my_int);
    ck_assert_int_eq(result_error, my_error);
#test S21_FROM_DECIMAL_TO_FLOAT_21
    s21_decimal number;
    int result_int = 0;
    int result_error = 0;
    int my_error = 0;
    int my_int = 0;
    float my_float = 0;
    // decimal: 9959999999999999999
    // float: 9.96E+18
    // int: 1594505479
    number.bits[0] = 0b11001010111000111111111111111111;
    number.bits[1] = 0b10001010001110010000011100111010;
    number.bits[2] = 0b00000000000000000000000000000000;
    number.bits[3] = 0b00000000000000000000000000000000;
    result_int = 1594505479;
    result_error = 0;
    my_error = s21_from_decimal_to_float(number, &my_float);
    my_int = *((unsigned int *) &my_float);
    ck_assert_int_eq(result_int, my_int);
    ck_assert_int_eq(result_error, my_error);
#test S21_FROM_DECIMAL_TO_FLOAT_171
    s21_decimal number;
    int result_int = 0;
    int result_error = 0;
    int my_error = 0;
    int my_int = 0;
    float my_float = 0;
    // decimal: 18446744073709551615
    // float: 1.844674E+19
    // int: 1602224128
    number.bits[0] = 0b11111111111111111111111111111111;
    number.bits[1] = 0b11111111111111111111111111111111;
    number.bits[2] = 0b00000000000000000000000000000000;
    number.bits[3] = 0b00000000000000000000000000000000;
    result_int = 1602224128;
    result_error = 0;
    my_error = s21_from_decimal_to_float(number, &my_float);
    my_int = *((unsigned int *) &my_float);
    ck_assert_int_eq(result_int, my_int);
    ck_assert_int_eq(result_error, my_error);
#test S21_FROM_DECIMAL_TO_FLOAT_181
    s21_decimal number;
    int result_int = 0;
    int result_error = 0;
    int my_error = 0;
    int my_int = 0;
    float my_float = 0;
    // decimal: -5454545545352456454545645464
    // float: -5.454546E+27
    // int: -309526744
    number.bits[0] = 0b10001000100000001001111110011000;
    number.bits[1] = 0b10000010011101100000001010011001;
    number.bits[2] = 0b00010001100111111110010011110010;
    number.bits[3] = 0b10000000000000000000000000000000;
    result_int = -309526744;
    result_error = 0;
    my_error = s21_from_decimal_to_float(number, &my_float);
    my_int = *((unsigned int *) &my_float);
    ck_assert_int_eq(result_int, my_int);
    ck_assert_int_eq(result_error, my_error);
#test S21_FROM_DECIMAL_TO_FLOAT_ADDITION_1_136
    s21_decimal number;
    int result_int = 0;
    int result_error = 0;
    int my_error = 0;
    int my_int = 0;
    float my_float = 0;
    // decimal: 79228162514264337593543950335
    // float: 7.922816E+28
    // int: 1870659584
    number.bits[0] = 0b11111111111111111111111111111111;
    number.bits[1] = 0b11111111111111111111111111111111;
    number.bits[2] = 0b11111111111111111111111111111111;
    number.bits[3] = 0b00000000000000000000000000000000;
    result_int = 1870659584;
    result_error = 0;

    my_error = s21_from_decimal_to_float(number, &my_float);
    my_int = *((unsigned int *) &my_float);
    ck_assert_int_eq(result_int, my_int);
    ck_assert_int_eq(result_error, my_error);
#test S21_FROM_DECIMAL_TO_FLOAT_ADDITION_1_137
    s21_decimal number;
    int result_int = 0;
    int result_error = 0;
    int my_error = 0;
    int my_int = 0;
    float my_float = 0;
    // decimal: 1234.5677987654345678987654346
    // float: 1234.568
    // int: 1150964267
    number.bits[0] = 0b10010001000010101111010011001010;
    number.bits[1] = 0b11000000010001011101010111110010;
    number.bits[2] = 0b00100111111001000001101100000000;
    number.bits[3] = 0b00000000000110010000000000000000;
    result_int = 1150964267;
    result_error = 0;
    my_error = s21_from_decimal_to_float(number, &my_float);
    my_int = *((unsigned int *) &my_float);
    ck_assert_int_eq(result_int, my_int);
    ck_assert_int_eq(result_error, my_error);
#test S21_FROM_DECIMAL_TO_FLOAT_ADDITION_1_138
    s21_decimal number;
    int result_int = 0;
    int result_error = 0;
    int my_error = 0;
    int my_int = 0;
    float my_float = 0;
    // decimal: -123458677.98765434567898765435
    // float: -1.234587E+08
    // int: -856982897
    number.bits[0] = 0b10111001000000010001100001111011;
    number.bits[1] = 0b01101110100110001001011011101100;
    number.bits[2] = 0b00100111111001000100001100110010;
    number.bits[3] = 0b10000000000101000000000000000000;
    result_int = -856982897;
    result_error = 0;
    my_error = s21_from_decimal_to_float(number, &my_float);
    my_int = *((unsigned int *) &my_float);
    ck_assert_int_eq(result_int, my_int);
    ck_assert_int_eq(result_error, my_error);
#test S21_FROM_DECIMAL_TO_FLOAT_ADDITION_1_139
    s21_decimal number;
    int result_int = 0;
    int result_error = 0;
    int my_error = 0;
    int my_int = 0;
    float my_float = 0;
    // decimal: 123445677.98765434567898765435
    // float: 1.234457E+08
    // int: 1290499126
    number.bits[0] = 0b00110100100000010001100001111011;
    number.bits[1] = 0b01001010011100100010011000011110;
    number.bits[2] = 0b00100111111000110010111111101001;
    number.bits[3] = 0b00000000000101000000000000000000;
    result_int = 1290499126;
    result_error = 0;
    my_error = s21_from_decimal_to_float(number, &my_float);
    my_int = *((unsigned int *) &my_float);
    ck_assert_int_eq(result_int, my_int);
    ck_assert_int_eq(result_error, my_error);
#test S21_FROM_DECIMAL_TO_FLOAT_ADDITION_1_140
    s21_decimal number;
    int result_int = 0;
    int result_error = 0;
    int my_error = 0;
    int my_int = 0;
    float my_float = 0;
    // decimal: -12345677.987654533456789876543
    // float: -1.234568E+07
    // int: -885235378
    number.bits[0] = 0b11111110001111011010111100111111;
    number.bits[1] = 0b11000000010001101000000010111010;
    number.bits[2] = 0b00100111111001000001101100000000;
    number.bits[3] = 0b10000000000101010000000000000000;
    result_int = -885235378;
    result_error = 0;
    my_error = s21_from_decimal_to_float(number, &my_float);
    my_int = *((unsigned int *) &my_float);
    ck_assert_int_eq(result_int, my_int);
    ck_assert_int_eq(result_error, my_error);
#test S21_FROM_DECIMAL_TO_FLOAT_ADDITION_1_141
    s21_decimal number;
    int result_int = 0;
    int result_error = 0;
    int my_error = 0;
    int my_int = 0;
    float my_float = 0;
    // decimal: 0.0000000000000000001
    // float: 1E-19
    // int: 535567946
    number.bits[0] = 0b00000000000000000000000000000001;
    number.bits[1] = 0b00000000000000000000000000000000;
    number.bits[2] = 0b00000000000000000000000000000000;
    number.bits[3] = 0b00000000000100110000000000000000;
    result_int = 535567946;
    result_error = 0;
    my_error = s21_from_decimal_to_float(number, &my_float);
    my_int = *((unsigned int *) &my_float);
    ck_assert_int_eq(result_int, my_int);
    ck_assert_int_eq(result_error, my_error);
#test S21_FROM_DECIMAL_TO_FLOAT_ADDITION_1_142
    s21_decimal number;
    int result_int = 0;
    int result_error = 0;
    int my_error = 0;
    int my_int = 0;
    float my_float = 0;
    // decimal: 0.0000000000000000000000000001
    // float: 1E-28
    // int: 285050806
    number.bits[0] = 0b00000000000000000000000000000001;
    number.bits[1] = 0b00000000000000000000000000000000;
    number.bits[2] = 0b00000000000000000000000000000000;
    number.bits[3] = 0b00000000000111000000000000000000;
    result_int = 285050806;
    result_error = 0;
    my_error = s21_from_decimal_to_float(number, &my_float);
    my_int = *((unsigned int *) &my_float);
    ck_assert_int_eq(result_int, my_int);
    ck_assert_int_eq(result_error, my_error);
#test S21_FROM_DECIMAL_TO_FLOAT_ADDITION_1_144
    s21_decimal number;
    int result_int = 0;
    int result_error = 0;
    int my_error = 0;
    int my_int = 0;
    float my_float = 0;
    // decimal: -79228162514264337593543950335
    // float: -7.922816E+28
    // int: -276824064
    number.bits[0] = 0b11111111111111111111111111111111;
    number.bits[1] = 0b11111111111111111111111111111111;
    number.bits[2] = 0b11111111111111111111111111111111;
    number.bits[3] = 0b10000000000000000000000000000000;
    result_int = -276824064;
    result_error = 0;
    my_error = s21_from_decimal_to_float(number, &my_float);
    my_int = *((unsigned int *) &my_float);
    ck_assert_int_eq(result_int, my_int);
    ck_assert_int_eq(result_error, my_error);
#test S21_FROM_DECIMAL_TO_FLOAT_ADDITION_1_145
    s21_decimal number;
    int result_int = 0;
    int result_error = 0;
    int my_error = 0;
    int my_int = 0;
    float my_float = 0;
    // decimal: -792.28162514264337593543950335
    // float: -792.2816
    // int: -1002040826
    number.bits[0] = 0b11111111111111111111111111111111;
    number.bits[1] = 0b11111111111111111111111111111111;
    number.bits[2] = 0b11111111111111111111111111111111;
    number.bits[3] = 0b10000000000110100000000000000000;
    result_int = -1002040826;
    result_error = 0;
    my_error = s21_from_decimal_to_float(number, &my_float);
    my_int = *((unsigned int *) &my_float);
    ck_assert_int_eq(result_int, my_int);
    ck_assert_int_eq(result_error, my_error);
#test S21_FROM_DECIMAL_TO_FLOAT_ADDITION_1_146
    s21_decimal number;
    int result_int = 0;
    int result_error = 0;
    int my_error = 0;
    int my_int = 0;
    float my_float = 0;
    // decimal: -79228162514264337593543950335
    // float: -7.922816E+28
    // int: -276824064
    number.bits[0] = 0b11111111111111111111111111111111;
    number.bits[1] = 0b11111111111111111111111111111111;
    number.bits[2] = 0b11111111111111111111111111111111;
    number.bits[3] = 0b10000000000000000000000000000000;
    result_int = -276824064;
    result_error = 0;
    my_error = s21_from_decimal_to_float(number, &my_float);
    my_int = *((unsigned int *) &my_float);
    ck_assert_int_eq(result_int, my_int);
    ck_assert_int_eq(result_error, my_error);
#test S21_FROM_DECIMAL_TO_FLOAT_ADDITION_1_147
    s21_decimal number;
    int result_int = 0;
    int result_error = 0;
    int my_error = 0;
    int my_int = 0;
    float my_float = 0;
    // decimal: 2.7986531268974139743
    // float: 2.798653
    // int: 1077091618
    number.bits[0] = 0b11111110100100001101100101011111;
    number.bits[1] = 0b10000100011001000010000111101000;
    number.bits[2] = 0b00000000000000000000000000000001;
    number.bits[3] = 0b00000000000100110000000000000000;
    result_int = 1077091618;
    result_error = 0;
    my_error = s21_from_decimal_to_float(number, &my_float);
    my_int = *((unsigned int *) &my_float);
    ck_assert_int_eq(result_int, my_int);
    ck_assert_int_eq(result_error, my_error);
#test S21_FROM_DECIMAL_TO_FLOAT_ADDITION_1_148
    s21_decimal number;
    int result_int = 0;
    int result_error = 0;
    int my_error = 0;
    int my_int = 0;
    float my_float = 0;
    // decimal: 5.4564654654864768465454654846
    // float: 5.456465
    // int: 1085184861
    number.bits[0] = 0b01101110100110100110010101111110;
    number.bits[1] = 0b11100010111000110111110100101010;
    number.bits[2] = 0b10110000010011101101001100001111;
    number.bits[3] = 0b00000000000111000000000000000000;
    result_int = 1085184861;
    result_error = 0;
    my_error = s21_from_decimal_to_float(number, &my_float);
    my_int = *((unsigned int *) &my_float);
    ck_assert_int_eq(result_int, my_int);
    ck_assert_int_eq(result_error, my_error);
#test S21_FROM_DECIMAL_TO_FLOAT_ADDITION_1_149
    s21_decimal number;
    int result_int = 0;
    int result_error = 0;
    int my_error = 0;
    int my_int = 0;
    float my_float = 0;
    // decimal: -79228162514264337593543950330
    // float: -7.922816E+28
    // int: -276824064
    number.bits[0] = 0b11111111111111111111111111111010;
    number.bits[1] = 0b11111111111111111111111111111111;
    number.bits[2] = 0b11111111111111111111111111111111;
    number.bits[3] = 0b10000000000000000000000000000000;
    result_int = -276824064;
    result_error = 0;
    my_error = s21_from_decimal_to_float(number, &my_float);
    my_int = *((unsigned int *) &my_float);
    ck_assert_int_eq(result_int, my_int);
    ck_assert_int_eq(result_error, my_error);
#test S21_FROM_DECIMAL_TO_FLOAT_ADDITION_1_150
    s21_decimal number;
    int result_int = 0;
    int result_error = 0;
    int my_error = 0;
    int my_int = 0;
    float my_float = 0;
    // decimal: 32323465785678987654
    // float: 3.232346E+19
    // int: 1608534530
    number.bits[0] = 0b00000000111000111000000110000110;
    number.bits[1] = 0b11000000100101000000010011100000;
    number.bits[2] = 0b00000000000000000000000000000001;
    number.bits[3] = 0b00000000000000000000000000000000;
    result_int = 1608534530;
    result_error = 0;
    my_error = s21_from_decimal_to_float(number, &my_float);
    my_int = *((unsigned int *) &my_float);
    ck_assert_int_eq(result_int, my_int);
    ck_assert_int_eq(result_error, my_error);
#test S21_FROM_DECIMAL_TO_FLOAT_ADDITION_1_151
    s21_decimal number;
    int result_int = 0;
    int result_error = 0;
    int my_error = 0;
    int my_int = 0;
    float my_float = 0;
    // decimal: -784510454.7989898652154545652
    // float: -7.845105E+08
    // int: -834991432
    number.bits[0] = 0b00110101111110110100010111110100;
    number.bits[1] = 0b10110111000111111011101111011100;
    number.bits[2] = 0b00011001010110010101000110000001;
    number.bits[3] = 0b10000000000100110000000000000000;
    result_int = -834991432;
    result_error = 0;
    my_error = s21_from_decimal_to_float(number, &my_float);
    my_int = *((unsigned int *) &my_float);
    ck_assert_int_eq(result_int, my_int);
    ck_assert_int_eq(result_error, my_error);
#test S21_FROM_DECIMAL_TO_FLOAT_ADDITION_1_152
    s21_decimal number;
    int result_int = 0;
    int result_error = 0;
    int my_error = 0;
    int my_int = 0;
    float my_float = 0;
    // decimal: 0.324524
    // float: 0.324524
    // int: 1051076610
    number.bits[0] = 0b00000000000001001111001110101100;
    number.bits[1] = 0b00000000000000000000000000000000;
    number.bits[2] = 0b00000000000000000000000000000000;
    number.bits[3] = 0b00000000000001100000000000000000;
    result_int = 1051076610;
    result_error = 0;
    my_error = s21_from_decimal_to_float(number, &my_float);
    my_int = *((unsigned int *) &my_float);
    ck_assert_int_eq(result_int, my_int);
    ck_assert_int_eq(result_error, my_error);

#test S21_FROM_DECIMAL_TO_FLOAT_ADDITION_1_153
    s21_decimal number;
    int result_error = 0;
    int my_error = 0;
    float my_float = 0;
    // float: 10000000.5
    number.bits[0] = 0b01010100000010111110010000000000;
    number.bits[1] = 0b00000000000000000000000000000010;
    number.bits[2] = 0b00000000000000000000000000000000;
    number.bits[3] = 0b00000000000000000000000000000000;
    result_error = 0;
    my_error = s21_from_decimal_to_float(number, &my_float);
    ck_assert_float_eq(10000000000, my_float);
    ck_assert_int_eq(result_error, my_error);
#test S21_FROM_DECIMAL_TO_FLOAT_ADDITION_1_154
    s21_decimal number;
    int result_error = 0;
    int my_error = 0;
    float my_float = 0;
    // float: 1
    number.bits[0] = 0b00000000000000000000000000000001;
    number.bits[1] = 0b00000000000000000000000000000000;
    number.bits[2] = 0b00000000000000000000000000000000;
    number.bits[3] = 0b00000000000000000000000000000000;
    result_error = 0;
    my_error = s21_from_decimal_to_float(number, &my_float);
    ck_assert_float_eq(1, my_float);
    ck_assert_int_eq(result_error, my_error);
#test S21_FROM_DECIMAL_TO_FLOAT_ADDITION_1_155
    s21_decimal number;
    int result_error = 0;
    int my_error = 0;
    float my_float = 0;
    // float: 100000000
    number.bits[0] = 0b00000101111101011110000100000000;
    number.bits[1] = 0b00000000000000000000000000000000;
    number.bits[2] = 0b00000000000000000000000000000000;
    number.bits[3] = 0b00000000000000000000000000000000;
    result_error = 0;
    my_error = s21_from_decimal_to_float(number, &my_float);
    ck_assert_float_eq(100000000, my_float);
    ck_assert_int_eq(result_error, my_error);
#test S21_FROM_DECIMAL_TO_FLOAT_ADDITION_1_156
    s21_decimal number;
    int result_error = 0;
    int my_error = 0;
    float my_float = 0;
    // float: 10000000000
    number.bits[0] = 0b01010100000010111110010000000000;
    number.bits[1] = 0b00000000000000000000000000000010;
    number.bits[2] = 0b00000000000000000000000000000000;
    number.bits[3] = 0b00000000000000000000000000000000;
    result_error = 0;
    my_error = s21_from_decimal_to_float(number, &my_float);
    ck_assert_float_eq(10000000000, my_float);
    ck_assert_int_eq(result_error, my_error);
#test S21_FROM_DECIMAL_TO_FLOAT_ADDITION_1_157
    s21_decimal number;
    int result_error = 0;
    int my_error = 0;
    float my_float = 0;
    // float: 10000000000
    number.bits[0] = 0b01010100000010111110010000000000;
    number.bits[1] = 0b00000000000000000000000000000010;
    number.bits[2] = 0b00000000000000000000000000000000;
    number.bits[3] = 0x00030000;
    result_error = 0;
    my_error = s21_from_decimal_to_float(number, &my_float);
    ck_assert_float_eq(10000000, my_float);
    ck_assert_int_eq(result_error, my_error);



#test S21_FROM_DECIMAL_TO_INT
    s21_decimal value_01 = {{4294967295, 4294967295, 4294967295, 0x80000000}};    // -79 228 162 514 264 337 593 543 950 335
    s21_decimal value_02 = {{0, 4294967295, 4294967295, 0x80000000}};             // -79 228 162 514 264 337 589 248 983 040
    s21_decimal value_03 = {{0, 0, 4294967295, 0x80000000}};                      // -79 228 162 495 817 593 519 834 398 720
    s21_decimal value_04 = {{4294967295, 4294967295, 536870911, 0x80000000}};     // -9 903 520 314 283 042 199 192 993 791
    s21_decimal value_05 = {{4294967295, 4294967295, 0, 0x80000000}};             // -18 446 744 073 709 551 615
    s21_decimal value_06 = {{0, 4294967295, 0, 0x80000000}};                      // -18 446 744 069 414 584 320
    s21_decimal value_07 = {{4294967295, 0, 0, 0x80000000}};                      // -4 294 967 295
    s21_decimal value_08 = {{2147483649, 0, 0, 0x80000000}};                      // -2 147 483 649
    s21_decimal value_09 = {{2147483648, 0, 0, 0x80000000}};                      // -2 147 483 648
    s21_decimal value_10 = {{1, 0, 0, 0x80000000}};                               // -1
    s21_decimal value_11 = {{4294967295, 4294967295, 0, 0x801C0000}};             // -18 446 744 073 709 551 615                    -28
    s21_decimal value_13 = {{4294967295, 4294967295, 4294967295, 0x801C0000}};    // -79 228 162 514 264 337 593 543 950 335        -28
    s21_decimal value_14 = {{4294967295, 4294967295, 536870911, 0x80190000}};     // -9 903 520 314 283 042 199 192 993 791         -25
    s21_decimal value_15 = {{1410065408, 705032706, 1, 0x800A0000}};              // -2 147 483 649 000 000 000 0                   -10
    s21_decimal value_16 = {{0, 705032704, 1, 0x800A0000}};                       // -2 147 483 648 000 000 000 0                   -10
    s21_decimal value_17 = {{0, 0, 0, 0x80000000}};                               // -0
    s21_decimal value_18 = {{0, 0, 0, 0x00000000}};                               //  0
    s21_decimal value_20 = {{1, 0, 0, 0x00000000}};                               //  1
    s21_decimal value_21 = {{2147483647, 0, 0, 0}};                               //  2 147 483 647
    s21_decimal value_22 = {{4294967295, 0, 0, 0x00000000}};                      //  4 294 967 295
    s21_decimal value_23 = {{0, 705032704, 1, 0x00000000}};                       //  2 147 483 648 000 000 000 0                   -10
    s21_decimal value_24 = {{0, 4294967295, 0, 0x00000000}};                      //  18 446 744 069 414 584 320
    s21_decimal value_25 = {{4294967295, 4294967295, 536870911, 0x00000000}};     //  9 903 520 314 283 042 199 192 993 791
    s21_decimal value_26 = {{0, 0, 4294967295, 0x00000000}};                      //  79 228 162 495 817 593 519 834 398 720
    s21_decimal value_27 = {{0, 4294967295, 4294967295, 0x00000000}};             //  79 228 162 514 264 337 589 248 983 040
    s21_decimal value_29 = {{0, 0, 0, 0x80FF0000}};                               // -INF
    s21_decimal value_30 = {{0, 0, 0, 0x00FF0000}};                               // +INF
    s21_decimal value_31 = {{1431655765, 1431655765, 1431655765, 0x80FF0000}};    //  NaN (диапазон от (-1)*10^(-28) до (-1)*10^(-28), но !=0)
    int dst_01 = 0;
    int dst_02 = 0;
    int dst_03 = 0;
    int dst_04 = 0;
    int dst_05 = 0;
    int dst_06 = 0;
    int dst_07 = 0;
    int dst_08 = 0;
    int dst_09 = 0;
    int dst_10 = 0;
    int dst_11 = 0;
    int dst_13 = 0;
    int dst_14 = 0;
    int dst_15 = 0;
    int dst_16 = 0;
    int dst_17 = 0;
    int dst_18 = 0;
    int dst_20 = 0;
    int dst_21 = 0;
    int dst_22 = 0;
    int dst_23 = 0;
    int dst_24 = 0;
    int dst_25 = 0;
    int dst_26 = 0;
    int dst_27 = 0;
    int dst_29 = 0;
    int dst_30 = 0;
    int dst_31 = 0;
    ck_assert_int_eq(s21_from_decimal_to_int(value_01, &dst_01), 1);
    ck_assert_int_eq(dst_01,  0);

    ck_assert_int_eq(s21_from_decimal_to_int(value_02, &dst_02), 1);
    ck_assert_int_eq(dst_02, 0);

    ck_assert_int_eq(s21_from_decimal_to_int(value_03, &dst_03), 1);
    ck_assert_int_eq(dst_03, 0);
    
    ck_assert_int_eq(s21_from_decimal_to_int(value_04, &dst_04), 1);
    ck_assert_int_eq(dst_04,  0);

    ck_assert_int_eq(s21_from_decimal_to_int(value_05, &dst_05), 1);
    ck_assert_int_eq(dst_05, 0);

    ck_assert_int_eq(s21_from_decimal_to_int(value_06, &dst_06), 1);
    ck_assert_int_eq(dst_06, 0);

    ck_assert_int_eq(s21_from_decimal_to_int(value_07, &dst_07), 1);
    ck_assert_int_eq(dst_07,  0);

    ck_assert_int_eq(s21_from_decimal_to_int(value_08, &dst_08), 1);
    ck_assert_int_eq(dst_08, 0);

    ck_assert_int_eq(s21_from_decimal_to_int(value_09, &dst_09), 0);
    ck_assert_int_eq(dst_09, -2147483648);
    
    ck_assert_int_eq(s21_from_decimal_to_int(value_10, &dst_10), 0);
    ck_assert_int_eq(dst_10,  -1);

    ck_assert_int_eq(s21_from_decimal_to_int(value_11, &dst_11), 0);
    ck_assert_int_eq(dst_11,  0);

    // ck_assert_int_eq(s21_from_decimal_to_int(value_12, &dst_12), 1);
    // ck_assert_int_eq(dst_12, 0);

    ck_assert_int_eq(s21_from_decimal_to_int(value_13, &dst_13), 0);
    ck_assert_int_eq(dst_13, -7);
    
    ck_assert_int_eq(s21_from_decimal_to_int(value_14, &dst_14), 0);
    ck_assert_int_eq(dst_14, -990);

    ck_assert_int_eq(s21_from_decimal_to_int(value_15, &dst_15), 1);
    ck_assert_int_eq(dst_15, 0);

    ck_assert_int_eq(s21_from_decimal_to_int(value_16, &dst_16), 0);
    ck_assert_int_eq(dst_16, -2147483648);

    ck_assert_int_eq(s21_from_decimal_to_int(value_17, &dst_17), 0);
    ck_assert_int_eq(dst_17,  0);

    ck_assert_int_eq(s21_from_decimal_to_int(value_18, &dst_18), 0);
    ck_assert_int_eq(dst_18, 0);
    
    // ck_assert_int_eq(s21_from_decimal_to_int(value_19, &dst_19), 1);
    // ck_assert_int_eq(dst_19, 0);

    ck_assert_int_eq(s21_from_decimal_to_int(value_20, &dst_20), 0);
    ck_assert_int_eq(dst_20, 1);
    
    ck_assert_int_eq(s21_from_decimal_to_int(value_21, &dst_21), 0);
    ck_assert_int_eq(dst_21, 2147483647);

    ck_assert_int_eq(s21_from_decimal_to_int(value_22, &dst_22), 1);
    ck_assert_int_eq(dst_22, 0);

    ck_assert_int_eq(s21_from_decimal_to_int(value_23, &dst_23), 1);
    ck_assert_int_eq(dst_23, 0);

    ck_assert_int_eq(s21_from_decimal_to_int(value_24, &dst_24), 1);
    ck_assert_int_eq(dst_24, 0);

    ck_assert_int_eq(s21_from_decimal_to_int(value_25, &dst_25), 1);
    ck_assert_int_eq(dst_25, 0);

    ck_assert_int_eq(s21_from_decimal_to_int(value_26, &dst_26), 1);
    ck_assert_int_eq(dst_26, 0);

    ck_assert_int_eq(s21_from_decimal_to_int(value_27, &dst_27), 1);
    ck_assert_int_eq(dst_27, 0);

    // ck_assert_int_eq(s21_from_decimal_to_int(value_28, &dst_28), 0);
    // ck_assert_int_eq(dst_28, 7922);

    ck_assert_int_eq(s21_from_decimal_to_int(value_29, &dst_29), 1);
    ck_assert_int_eq(dst_29, 0);

    ck_assert_int_eq(s21_from_decimal_to_int(value_30, &dst_30), 1);
    ck_assert_int_eq(dst_30, 0);

    ck_assert_int_eq(s21_from_decimal_to_int(value_31, &dst_31), 1);
    ck_assert_int_eq(dst_31, 0);



#test S21_FROM_FLOAT_TO_DECIMAL
    float src_01 = 12345;               //  12345
    float src_02 = 1234567;             //  1234567
    float src_03 = 12345670000000;      //  12345670000000
    float src_04 = 12345671234567;      //  12345670000000
    float src_05 = 12345675123457;      //  12345670000000
    float src_06 = 12345675423457;      //  12345680000000
    float src_07 = 0.25;                //  25          -2
    float src_08 = 0.1;                 //  1           -1
    float src_09 = 0.1234567;           //  1234567     -7
    float src_10 = 0.12345670000000;    //  1234567     -7
    float src_11 = 0.12345671234567;    //  1234567     -7
    float src_12 = 0.12345675123457;    //  1234568     -7
    float src_13 = 0.000000012345671234567; // 1234567  -14
    float src_14 = 0.0000000000000000000000000001;    //  1   -28
    float src_15 = 0.00000000000000000000000000001;   //  1   -29  (Функция вернет ошибку так как скейл < -28)
    float src_16 = 0;                   //  0
    float src_17 = -0;                  //  -0
    float src_18 = -0.0000000000000000000000000001;   //  1   -28
    float src_19 = -0.00000000000000000000000000001;  //  1   -29  (Функция вернет ошибку так как скейл < -28)
    float src_20 = -12345670000000;      //  -12345670000000
    float src_21 = -12345671234567;      //  -12345670000000
    float src_22 = -1e29;     // -1   29  (Функция вернет ошибку так как скейл > 28)
    float src_23 = 1e29;      //  1   29  (Функция вернет ошибку так как скейл > 28)
    
    s21_decimal value_01 = {{0b00000000000000000011000000111001, 0b00000000000000000000000000000000, 0b00000000000000000000000000000000, 0b00000000000000000000000000000000}};  // 12345
    s21_decimal dst1 = {{0}};
    ck_assert_int_eq(s21_from_float_to_decimal(src_01, &dst1), 0);
    ck_assert_int_eq(s21_is_equal(dst1, value_01), 1);

    s21_decimal value_02 = {{0b00000000000100101101011010000111, 0b00000000000000000000000000000000, 0b00000000000000000000000000000000, 0b00000000000000000000000000000000}};  // 1234567
    s21_decimal dst2 = {{0}};
    ck_assert_int_eq(s21_from_float_to_decimal(src_02, &dst2), 0);
    ck_assert_int_eq(s21_is_equal(dst2, value_02), 1);

    s21_decimal value_03 = {{0b01110011010001100101110110000000, 0b00000000000000000000101100111010, 0b00000000000000000000000000000000, 0b00000000000000000000000000000000}};  // 12345670000000
    s21_decimal dst3 = {{0}};
    ck_assert_int_eq(s21_from_float_to_decimal(src_03, &dst3), 0);
    ck_assert_int_eq(s21_is_equal(dst3, value_03), 1);

    s21_decimal value_04 = {{0b01110011010001100101110110000000, 0b00000000000000000000101100111010, 0b00000000000000000000000000000000, 0b00000000000000000000000000000000}};  // 12345670000000
    s21_decimal dst4 = {{0}};
    ck_assert_int_eq(s21_from_float_to_decimal(src_04, &dst4), 0);
    ck_assert_int_eq(s21_is_equal(dst4, value_04), 1);

    s21_decimal value_05 = {{0b01110011010001100101110110000000, 0b00000000000000000000101100111010, 0b00000000000000000000000000000000, 0b00000000000000000000000000000000}};  // 12345670000000
    s21_decimal dst5 = {{0}};
    ck_assert_int_eq(s21_from_float_to_decimal(src_05, &dst5), 0);
    ck_assert_int_eq(s21_is_equal(dst5, value_05), 1);

    s21_decimal value_06 = {{0b01110011110111101111010000000000, 0b00000000000000000000101100111010, 0b00000000000000000000000000000000, 0b00000000000000000000000000000000}};  // 12345680000000
    s21_decimal dst6 = {{0}};
    ck_assert_int_eq(s21_from_float_to_decimal(src_06, &dst6), 0);
    ck_assert_int_eq(s21_is_equal(dst6, value_06), 1);

    s21_decimal value_07 = {{0b0000000000000000000000000011001, 0b00000000000000000000000000000000, 0b00000000000000000000000000000000, 0b00000000000000100000000000000000}};  // 25  -2
    s21_decimal dst7 = {{0}};
    ck_assert_int_eq(s21_from_float_to_decimal(src_07, &dst7), 0);
    ck_assert_int_eq(s21_is_equal(dst7, value_07), 1);

    s21_decimal value_08 = {{0b00000000000000000000000000000001, 0b00000000000000000000000000000000, 0b00000000000000000000000000000000, 0b00000000000000010000000000000000}};  // 1  -1
    s21_decimal dst8 = {{0}};
    ck_assert_int_eq(s21_from_float_to_decimal(src_08, &dst8), 0);
    ck_assert_int_eq(s21_is_equal(dst8, value_08), 1);

    s21_decimal value_09 = {{0b00000000000100101101011010000111, 0b00000000000000000000000000000000, 0b00000000000000000000000000000000, 0b00000000000001110000000000000000}};  // 1234567  -1
    s21_decimal dst9 = {{0}};
    ck_assert_int_eq(s21_from_float_to_decimal(src_09, &dst9), 0);
    ck_assert_int_eq(s21_is_equal(dst9, value_09), 1);

    s21_decimal value_10 = {{0b00000000000100101101011010000111, 0b00000000000000000000000000000000, 0b00000000000000000000000000000000, 0b00000000000001110000000000000000}};  // 1234567  -1
    s21_decimal dst10 = {{0}};
    ck_assert_int_eq(s21_from_float_to_decimal(src_10, &dst10), 0);
    ck_assert_int_eq(s21_is_equal(dst10, value_10), 1);

    s21_decimal value_11 = {{0b00000000000100101101011010000111, 0b00000000000000000000000000000000, 0b00000000000000000000000000000000, 0b00000000000001110000000000000000}};  // 1234567  -1
    s21_decimal dst11 = {{0}};
    ck_assert_int_eq(s21_from_float_to_decimal(src_11, &dst11), 0);
    ck_assert_int_eq(s21_is_equal(dst11, value_11), 1);

    s21_decimal value_12 = {{0b00000000000100101101011010001000, 0b00000000000000000000000000000000, 0b00000000000000000000000000000000, 0b00000000000001110000000000000000}};  // 1234568  -7
    s21_decimal dst12 = {{0}};
    ck_assert_int_eq(s21_from_float_to_decimal(src_12, &dst12), 0);
    ck_assert_int_eq(s21_is_equal(dst12, value_12), 1);

    s21_decimal value_13 = {{0b00000000000100101101011010000111, 0b00000000000000000000000000000000, 0b00000000000000000000000000000000, 0b00000000000011100000000000000000}};  // 1234567  -14
    s21_decimal dst13 = {{0}};
    ck_assert_int_eq(s21_from_float_to_decimal(src_13, &dst13), 0);
    ck_assert_int_eq(s21_is_equal(dst13, value_13), 1);

    s21_decimal value_14 = {{0b00000000000000000000000000000001, 0b00000000000000000000000000000000, 0b00000000000000000000000000000000, 0b00000000000111000000000000000000}};  // 1   -28
    s21_decimal dst14 = {{0}};
    ck_assert_int_eq(s21_from_float_to_decimal(src_14, &dst14), 0);
    ck_assert_int_eq(s21_is_equal(dst14, value_14), 1);
    
    s21_decimal value_15 = {{0b00000000000000000000000000000000, 0b00000000000000000000000000000000, 0b00000000000000000000000000000000, 0b00000000000000000000000000000000}};  // 0
    s21_decimal dst15 = {{0}};
    ck_assert_int_eq(s21_from_float_to_decimal(src_15, &dst15), 1);  //  1   -29  (Функция вернет ошибку так как скейл < -28) decimal останется равным 0
    ck_assert_int_eq(s21_is_equal(dst15, value_15), 1);

    s21_decimal value_16 = {{0b00000000000000000000000000000000, 0b00000000000000000000000000000000, 0b00000000000000000000000000000000, 0b00000000000000000000000000000000}};  // 0
    s21_decimal dst16 = {{0}};
    ck_assert_int_eq(s21_from_float_to_decimal(src_16, &dst16), 0);
    ck_assert_int_eq(s21_is_equal(dst16, value_16), 1);
    
    s21_decimal value_17 = {{0b00000000000000000000000000000000, 0b00000000000000000000000000000000, 0b00000000000000000000000000000000, 0b00000000000000000000000000000000}};  // -0
    s21_decimal dst17 = {{0}};
    ck_assert_int_eq(s21_from_float_to_decimal(src_17, &dst17), 0);
    ck_assert_int_eq(s21_is_equal(dst17, value_17), 1);
    
    s21_decimal value_18 = {{0b00000000000000000000000000000001, 0b00000000000000000000000000000000, 0b00000000000000000000000000000000, 0b10000000000111000000000000000000}};  // -1   -28
    s21_decimal dst18 = {{0}};
    ck_assert_int_eq(s21_from_float_to_decimal(src_18, &dst18), 0);
    ck_assert_int_eq(s21_is_equal(dst18, value_18), 1);

    s21_decimal value_19 = {{0b00000000000000000000000000000000, 0b00000000000000000000000000000000, 0b00000000000000000000000000000000, 0b00000000000000000000000000000000}};  // 0
    s21_decimal dst19 = {{0}};
    ck_assert_int_eq(s21_from_float_to_decimal(src_19, &dst19), 1);  //  1   -29  (Функция вернет ошибку так как скейл < -28) decimal останется равным 0
    ck_assert_int_eq(s21_is_equal(dst19, value_19), 1);

    s21_decimal value_20 = {{0b01110011010001100101110110000000, 0b00000000000000000000101100111010, 0b00000000000000000000000000000000, 0b10000000000000000000000000000000}};  // -12345670000000
    s21_decimal dst20 = {{0}};
    ck_assert_int_eq(s21_from_float_to_decimal(src_20, &dst20), 0);
    ck_assert_int_eq(s21_is_equal(dst20, value_20), 1);

    s21_decimal value_21 = {{0b01110011010001100101110110000000, 0b00000000000000000000101100111010, 0b00000000000000000000000000000000, 0b10000000000000000000000000000000}};  // -12345670000000
    s21_decimal dst21 = {{0}};
    ck_assert_int_eq(s21_from_float_to_decimal(src_21, &dst21), 0);
    ck_assert_int_eq(s21_is_equal(dst21, value_21), 1);

    s21_decimal dst22 = {{0}};
    ck_assert_int_eq(s21_from_float_to_decimal(src_22, &dst22), 1);  //  -1   29  (Функция вернет ошибку так как скейл > 28) decimal останется равным 0
    ck_assert_int_eq(s21_is_equal(dst21, value_21), 1);

    s21_decimal value_23 = {{0b00000000000000000000000000000000, 0b00000000000000000000000000000000, 0b00000000000000000000000000000000, 0b00000000000000000000000000000000}};  // 0
    s21_decimal dst23 = {{0}};
    ck_assert_int_eq(s21_from_float_to_decimal(src_23, &dst23), 1);  //  1   29  (Функция вернет ошибку так как скейл > 28) decimal останется равным 0
    ck_assert_int_eq(s21_is_equal(dst23, value_23), 1);

#test s21_from_float_to_decimal_1

  // f = 12345
  // (float)f = 12345
  // decimal etflon = 12345
  s21_decimal result;
  s21_decimal etflon;
  int error = 0;
  float f = (float)12345;
  s21_from_float_to_decimal(f, &result);
  etflon.bits[0] = 0b00000000000000000011000000111001;
  etflon.bits[1] = 0b00000000000000000000000000000000;
  etflon.bits[2] = 0b00000000000000000000000000000000;
  etflon.bits[3] = 0b00000000000000000000000000000000;
  ck_assert_int_eq(result.bits[3], etflon.bits[3]);
  ck_assert_int_eq(result.bits[2], etflon.bits[2]);
  ck_assert_int_eq(result.bits[1], etflon.bits[1]);
  ck_assert_int_eq(result.bits[0], etflon.bits[0]);
  ck_assert_int_eq(error, VALUE_OK);

#test s21_from_float_to_decimal_4
  // f = 79228162514264337593543.950335
  // (float)f = 79228162314232456544256.0
  // decimal etflon = 79228160000000000000000
  s21_decimal result;
  s21_decimal etflon;
  int error = 0;
  float f = (float)79228162514264337593543.950335;
  error = s21_from_float_to_decimal(f, &result);
  etflon.bits[0] = 0b11000100100000000000000000000000;
  etflon.bits[1] = 0b11110111100101111100011100110111;
  etflon.bits[2] = 0b00000000000000000001000011000110;
  etflon.bits[3] = 0x00000000;
  ck_assert_int_eq(result.bits[3], etflon.bits[3]);
  ck_assert_int_eq(result.bits[2], etflon.bits[2]);
  ck_assert_int_eq(result.bits[1], etflon.bits[1]);
  ck_assert_int_eq(result.bits[0], etflon.bits[0]);
  ck_assert_int_eq(error, VALUE_OK);

#test s21_from_float_to_decimal_5
  // f = 1.0F / 0.0
  // (float)f = inf
  // decimal etflon = 0
  s21_decimal result;
  s21_decimal etflon;
  int error = 0;
  float f = (float)1.0F / 0.0;
  error = s21_from_float_to_decimal(f, &result);
  etflon.bits[0] = 0b00000000000000000000000000000000;
  etflon.bits[1] = 0b00000000000000000000000000000000;
  etflon.bits[2] = 0b00000000000000000000000000000000;
  etflon.bits[3] = 0x00000000;
  ck_assert_int_eq(result.bits[3], etflon.bits[3]);
  ck_assert_int_eq(result.bits[2], etflon.bits[2]);
  ck_assert_int_eq(result.bits[1], etflon.bits[1]);
  ck_assert_int_eq(result.bits[0], etflon.bits[0]);
  ck_assert_int_eq(error, VALUE_ERROR);

#test s21_from_float_to_decimal_6
  // f = -1.0F / 0.0
  // (float)f = -inf
  // decimal etflon = 0
  s21_decimal result;
  s21_decimal etflon;
  int error = 0;
  float f = (float)-1.0F / 0.0;
  error = s21_from_float_to_decimal(f, &result);
  etflon.bits[0] = 0b00000000000000000000000000000000;
  etflon.bits[1] = 0b00000000000000000000000000000000;
  etflon.bits[2] = 0b00000000000000000000000000000000;
  etflon.bits[3] = 0x00000000;
  ck_assert_int_eq(result.bits[3], etflon.bits[3]);
  ck_assert_int_eq(result.bits[2], etflon.bits[2]);
  ck_assert_int_eq(result.bits[1], etflon.bits[1]);
  ck_assert_int_eq(result.bits[0], etflon.bits[0]);
  ck_assert_int_eq(error, VALUE_ERROR);

#test s21_from_float_to_decimal_7
  // f = NAN
  // (float)f = nan
  // decimal etflon = 0
  s21_decimal result;
  s21_decimal etflon;
  int error = 0;
  float f = (float)NAN;
  error = s21_from_float_to_decimal(f, &result);
  etflon.bits[0] = 0b00000000000000000000000000000000;
  etflon.bits[1] = 0b00000000000000000000000000000000;
  etflon.bits[2] = 0b00000000000000000000000000000000;
  etflon.bits[3] = 0x00000000;
  ck_assert_int_eq(result.bits[3], etflon.bits[3]);
  ck_assert_int_eq(result.bits[2], etflon.bits[2]);
  ck_assert_int_eq(result.bits[1], etflon.bits[1]);
  ck_assert_int_eq(result.bits[0], etflon.bits[0]);
  ck_assert_int_eq(error, VALUE_ERROR);

#test s21_from_float_to_decimal_8
  // f = 9e28
  // (float)f = 90000003243218552936760082432.0
  // decimal etflon = 0
  s21_decimal result;
  s21_decimal etflon;
  int error = 0;
  float f = (float)9e28;
  error = s21_from_float_to_decimal(f, &result);
  etflon.bits[0] = 0b00000000000000000000000000000000;
  etflon.bits[1] = 0b00000000000000000000000000000000;
  etflon.bits[2] = 0b00000000000000000000000000000000;
  etflon.bits[3] = 0x00000000;
  ck_assert_int_eq(result.bits[3], etflon.bits[3]);
  ck_assert_int_eq(result.bits[2], etflon.bits[2]);
  ck_assert_int_eq(result.bits[1], etflon.bits[1]);
  ck_assert_int_eq(result.bits[0], etflon.bits[0]);
  ck_assert_int_eq(error, VALUE_ERROR);

#test s21_from_float_to_decimal_9
  // f = -9e28
  // (float)f = -90000003243218552936760082432.0
  // decimal etflon = 0
  s21_decimal result;
  s21_decimal etflon;
  int error = 0;
  float f = (float)-9e28;
  error = s21_from_float_to_decimal(f, &result);
  etflon.bits[0] = 0b00000000000000000000000000000000;
  etflon.bits[1] = 0b00000000000000000000000000000000;
  etflon.bits[2] = 0b00000000000000000000000000000000;
  etflon.bits[3] = 0x00000000;
  ck_assert_int_eq(result.bits[3], etflon.bits[3]);
  ck_assert_int_eq(result.bits[2], etflon.bits[2]);
  ck_assert_int_eq(result.bits[1], etflon.bits[1]);
  ck_assert_int_eq(result.bits[0], etflon.bits[0]);
  ck_assert_int_eq(error, VALUE_ERROR);

#test s21_from_float_to_decimal_10
  // f = 9e-28
  // (float)f = 0.00000000000000000000000000089999997
  // decimal etflon = 0.0000000000000000000000000009
  s21_decimal result;
  s21_decimal etflon;
  int error = 0;
  float f = (float)9e-28;
  error = s21_from_float_to_decimal(f, &result);
  etflon.bits[0] = 0b00000000000000000000000000001001;
  etflon.bits[1] = 0b00000000000000000000000000000000;
  etflon.bits[2] = 0b00000000000000000000000000000000;
  etflon.bits[3] = 0x001C0000;
  ck_assert_int_eq(result.bits[3], etflon.bits[3]);
  ck_assert_int_eq(result.bits[2], etflon.bits[2]);
  ck_assert_int_eq(result.bits[1], etflon.bits[1]);
  ck_assert_int_eq(result.bits[0], etflon.bits[0]);
  ck_assert_int_eq(error, VALUE_OK);

#test s21_from_float_to_decimal_11
  // f = -987654321.123456789
  // (float)f = -987654336.0
  // decimal etflon = -987654300
  s21_decimal result;
  s21_decimal etflon;
  int error = 0;
  float f = (float)-987654321.123456789;
  error = s21_from_float_to_decimal(f, &result);
  etflon.bits[0] = 0b00111010110111100110100010011100;
  etflon.bits[1] = 0b00000000000000000000000000000000;
  etflon.bits[2] = 0b00000000000000000000000000000000;
  etflon.bits[3] = 0x80000000;
  ck_assert_int_eq(result.bits[3], etflon.bits[3]);
  ck_assert_int_eq(result.bits[2], etflon.bits[2]);
  ck_assert_int_eq(result.bits[1], etflon.bits[1]);
  ck_assert_int_eq(result.bits[0], etflon.bits[0]);
  ck_assert_int_eq(error, VALUE_OK);

#test s21_from_float_to_decimal_12
  // f = 123e-31
  // (float)f = 1.23E-29
  // decimal etflon = 0
  s21_decimal result;
  s21_decimal etflon;
  int error = 0;
  float f = (float)123e-31;
  error = s21_from_float_to_decimal(f, &result);
  etflon.bits[0] = 0b00000000000000000000000000000000;
  etflon.bits[1] = 0b00000000000000000000000000000000;
  etflon.bits[2] = 0b00000000000000000000000000000000;
  etflon.bits[3] = 0x00000000;
  ck_assert_int_eq(result.bits[3], etflon.bits[3]);
  ck_assert_int_eq(result.bits[2], etflon.bits[2]);
  ck_assert_int_eq(result.bits[1], etflon.bits[1]);
  ck_assert_int_eq(result.bits[0], etflon.bits[0]);
  ck_assert_int_eq(error, VALUE_ERROR);

#test s21_from_float_to_decimal_13
  // f = 123e-29
  // (float)f = 1.23E-27
  // decimal etflon = 0.0000000000000000000000000012
  s21_decimal result;
  s21_decimal etflon;
  int error = 0;
  float f = (float)123e-29;
  error = s21_from_float_to_decimal(f, &result);
  etflon.bits[0] = 0b00000000000000000000000000001100;
  etflon.bits[1] = 0b00000000000000000000000000000000;
  etflon.bits[2] = 0b00000000000000000000000000000000;
  etflon.bits[3] = 0b00000000000111000000000000000000;
  ck_assert_int_eq(result.bits[3], etflon.bits[3]);
  ck_assert_int_eq(result.bits[2], etflon.bits[2]);
  ck_assert_int_eq(result.bits[1], etflon.bits[1]);
  ck_assert_int_eq(result.bits[0], etflon.bits[0]);
  ck_assert_int_eq(error, VALUE_OK);

#test s21_from_float_to_decimal_14
  // f = 123e-30
  // (float)f = 1.23E-28
  // decimal etflon = 0.0000000000000000000000000001
  s21_decimal result;
  s21_decimal etflon;
  int error = 0;
  float f = (float)123e-30;
  error = s21_from_float_to_decimal(f, &result);
  etflon.bits[0] = 0b00000000000000000000000000000001;
  etflon.bits[1] = 0b00000000000000000000000000000000;
  etflon.bits[2] = 0b00000000000000000000000000000000;
  etflon.bits[3] = 0b00000000000111000000000000000000;
  ck_assert_int_eq(result.bits[3], etflon.bits[3]);
  ck_assert_int_eq(result.bits[2], etflon.bits[2]);
  ck_assert_int_eq(result.bits[1], etflon.bits[1]);
  ck_assert_int_eq(result.bits[0], etflon.bits[0]);
  ck_assert_int_eq(error, VALUE_OK);

#test s21_from_float_to_decimal_15
  // f = 123e-29
  // (float)f = 1.23E-27
  // decimal etflon = 0.0000000000000000000000000012
  s21_decimal result;
  s21_decimal etflon;
  int error = 0;
  float f = (float)125e-29;
  error = s21_from_float_to_decimal(f, &result);
  etflon.bits[0] = 0b00000000000000000000000000001101;
  etflon.bits[1] = 0b00000000000000000000000000000000;
  etflon.bits[2] = 0b00000000000000000000000000000000;
  etflon.bits[3] = 0b00000000000111000000000000000000;
  ck_assert_int_eq(result.bits[3], etflon.bits[3]);
  ck_assert_int_eq(result.bits[2], etflon.bits[2]);
  ck_assert_int_eq(result.bits[1], etflon.bits[1]);
  ck_assert_int_eq(result.bits[0], etflon.bits[0]);
  ck_assert_int_eq(error, VALUE_OK);


#test S21_FROM_INT_TO_DECIMAL
    int src[7] = {
        -2147483648,    /* {2147483648, 0, 0, 0x80000000}}; */
        -2147483647,    /* {2147483647, 0, 0, 0x80000000}}; */
        -1,             /* {         1, 0, 0, 0x80000000}}; */
        -0,             /* {         0, 0, 0, 0x00000000}}; */
         0,             /* {         0, 0, 0, 0x00000000}}; */
         1,             /* {         1, 0, 0, 0x00000000}}; */
         2147483647,    /* {2147483647, 0, 0, 0x00000000}}; */
    };
    unsigned int correct[7][4] = {
        {2147483648, 0, 0, 0x80000000},
        {2147483647, 0, 0, 0x80000000},
        {         1, 0, 0, 0x80000000},
        {         0, 0, 0, 0x00000000},
        {         0, 0, 0, 0x00000000},
        {         1, 0, 0, 0x00000000},
        {2147483647, 0, 0, 0x00000000},
    };
    s21_decimal dst = {0};
    for (int i = 0; i < 7; i++) {
        s21_from_int_to_decimal(src[i], &dst);
        ck_assert_int_eq(dst.bits[0], correct[i][0]);
        ck_assert_int_eq(dst.bits[1], correct[i][1]);
        ck_assert_int_eq(dst.bits[2], correct[i][2]);
        ck_assert_int_eq(dst.bits[3], correct[i][3]);
    }

#test s21_from_int_to_decimal_testing

  s21_decimal result, origin;
  int src = 1;
  origin.bits[0] = 0b00000000000000000000000000000001;
  origin.bits[1] = 0b00000000000000000000000000000000;
  origin.bits[2] = 0b00000000000000000000000000000000;
  origin.bits[3] = 0b00000000000000000000000000000000;
  int result_error = 0;
  int my_error = s21_from_int_to_decimal(src, &result);
  ck_assert_int_eq(origin.bits[3], result.bits[3]);
  ck_assert_int_eq(origin.bits[2], result.bits[2]);
  ck_assert_int_eq(origin.bits[1], result.bits[1]);
  ck_assert_int_eq(origin.bits[0], result.bits[0]);
  ck_assert_int_eq(result_error, my_error);

  src = 2147483647;
  origin.bits[0] = 0b01111111111111111111111111111111;
  origin.bits[1] = 0b00000000000000000000000000000000;
  origin.bits[2] = 0b00000000000000000000000000000000;
  origin.bits[3] = 0b00000000000000000000000000000000;
  result_error = 0;
  my_error = s21_from_int_to_decimal(src, &result);
  ck_assert_int_eq(origin.bits[3], result.bits[3]);
  ck_assert_int_eq(origin.bits[2], result.bits[2]);
  ck_assert_int_eq(origin.bits[1], result.bits[1]);
  ck_assert_int_eq(origin.bits[0], result.bits[0]);
  ck_assert_int_eq(result_error, my_error);

  src = 0b10000000000000000000000000000001;
  origin.bits[0] = 0b01111111111111111111111111111111;
  origin.bits[1] = 0b00000000000000000000000000000000;
  origin.bits[2] = 0b00000000000000000000000000000000;
  origin.bits[3] = 0b10000000000000000000000000000000;
  result_error = 0;
  my_error = s21_from_int_to_decimal(src, &result);
  ck_assert_int_eq(origin.bits[3], result.bits[3]);
  ck_assert_int_eq(origin.bits[2], result.bits[2]);
  ck_assert_int_eq(origin.bits[1], result.bits[1]);
  ck_assert_int_eq(origin.bits[0], result.bits[0]);
  ck_assert_int_eq(result_error, my_error);

  src = -89725264;
  origin.bits[0] = 0b00000101010110010001100101010000;
  origin.bits[1] = 0b00000000000000000000000000000000;
  origin.bits[2] = 0b00000000000000000000000000000000;
  origin.bits[3] = 0b10000000000000000000000000000000;
  result_error = 0;
  my_error = s21_from_int_to_decimal(src, &result);
  ck_assert_int_eq(origin.bits[3], result.bits[3]);
  ck_assert_int_eq(origin.bits[2], result.bits[2]);
  ck_assert_int_eq(origin.bits[1], result.bits[1]);
  ck_assert_int_eq(origin.bits[0], result.bits[0]);
  ck_assert_int_eq(result_error, my_error);

  src = 546783;
  origin.bits[0] = 0b00000000000010000101011111011111;
  origin.bits[1] = 0b00000000000000000000000000000000;
  origin.bits[2] = 0b00000000000000000000000000000000;
  origin.bits[3] = 0b00000000000000000000000000000000;
  result_error = 0;
  my_error = s21_from_int_to_decimal(src, &result);
  ck_assert_int_eq(origin.bits[3], result.bits[3]);
  ck_assert_int_eq(origin.bits[2], result.bits[2]);
  ck_assert_int_eq(origin.bits[1], result.bits[1]);
  ck_assert_int_eq(origin.bits[0], result.bits[0]);
  ck_assert_int_eq(result_error, my_error);

  src = 0;
  origin.bits[0] = 0b00000000000000000000000000000000;
  origin.bits[1] = 0b00000000000000000000000000000000;
  origin.bits[2] = 0b00000000000000000000000000000000;
  origin.bits[3] = 0b00000000000000000000000000000000;
  result_error = 0;
  my_error = s21_from_int_to_decimal(src, &result);
  ck_assert_int_eq(origin.bits[3], result.bits[3]);
  ck_assert_int_eq(origin.bits[2], result.bits[2]);
  ck_assert_int_eq(origin.bits[1], result.bits[1]);
  ck_assert_int_eq(origin.bits[0], result.bits[0]);
  ck_assert_int_eq(result_error, my_error);

  src = 0;
  origin.bits[0] = 0b00000000000000000000000000000000;
  origin.bits[1] = 0b00000000000000000000000000000000;
  origin.bits[2] = 0b00000000000000000000000000000000;
  origin.bits[3] = 0b00000000000000000000000000000000;
  result_error = 0;
  my_error = s21_from_int_to_decimal(src, &result);
  ck_assert_int_eq(origin.bits[3], result.bits[3]);
  ck_assert_int_eq(origin.bits[2], result.bits[2]);
  ck_assert_int_eq(origin.bits[1], result.bits[1]);
  ck_assert_int_eq(origin.bits[0], result.bits[0]);
  ck_assert_int_eq(result_error, my_error);

  src = -1;
  origin.bits[0] = 0b00000000000000000000000000000001;
  origin.bits[1] = 0b00000000000000000000000000000000;
  origin.bits[2] = 0b00000000000000000000000000000000;
  origin.bits[3] = 0b10000000000000000000000000000000;
  result_error = 0;
  my_error = s21_from_int_to_decimal(src, &result);
  ck_assert_int_eq(origin.bits[3], result.bits[3]);
  ck_assert_int_eq(origin.bits[2], result.bits[2]);
  ck_assert_int_eq(origin.bits[1], result.bits[1]);
  ck_assert_int_eq(origin.bits[0], result.bits[0]);
  ck_assert_int_eq(result_error, my_error);

  src = 2147483647;
  origin.bits[0] = 0b01111111111111111111111111111111;
  origin.bits[1] = 0b00000000000000000000000000000000;
  origin.bits[2] = 0b00000000000000000000000000000000;
  origin.bits[3] = 0b00000000000000000000000000000000;
  result_error = 0;
  my_error = s21_from_int_to_decimal(src, &result);
  ck_assert_int_eq(origin.bits[3], result.bits[3]);
  ck_assert_int_eq(origin.bits[2], result.bits[2]);
  ck_assert_int_eq(origin.bits[1], result.bits[1]);
  ck_assert_int_eq(origin.bits[0], result.bits[0]);
  ck_assert_int_eq(result_error, my_error);

  src = -2147483647;
  origin.bits[0] = 0b01111111111111111111111111111111;
  origin.bits[1] = 0b00000000000000000000000000000000;
  origin.bits[2] = 0b00000000000000000000000000000000;
  origin.bits[3] = 0b10000000000000000000000000000000;
  result_error = 0;
  my_error = s21_from_int_to_decimal(src, &result);
  ck_assert_int_eq(origin.bits[3], result.bits[3]);
  ck_assert_int_eq(origin.bits[2], result.bits[2]);
  ck_assert_int_eq(origin.bits[1], result.bits[1]);
  ck_assert_int_eq(origin.bits[0], result.bits[0]);
  ck_assert_int_eq(result_error, my_error);

  src = -12345;
  origin.bits[0] = 0b00000000000000000011000000111001;
  origin.bits[1] = 0b00000000000000000000000000000000;
  origin.bits[2] = 0b00000000000000000000000000000000;
  origin.bits[3] = 0b10000000000000000000000000000000;
  result_error = 0;
  my_error = s21_from_int_to_decimal(src, &result);
  ck_assert_int_eq(origin.bits[3], result.bits[3]);
  ck_assert_int_eq(origin.bits[2], result.bits[2]);
  ck_assert_int_eq(origin.bits[1], result.bits[1]);
  ck_assert_int_eq(origin.bits[0], result.bits[0]);
  ck_assert_int_eq(result_error, my_error);

  src = -12345;
  origin.bits[0] = 0b00000000000000000011000000111001;
  origin.bits[1] = 0b00000000000000000000000000000000;
  origin.bits[2] = 0b00000000000000000000000000000000;
  origin.bits[3] = 0b10000000000000000000000000000000;
  result_error = 0;
  my_error = s21_from_int_to_decimal(src, &result);
  ck_assert_int_eq(origin.bits[3], result.bits[3]);
  ck_assert_int_eq(origin.bits[2], result.bits[2]);
  ck_assert_int_eq(origin.bits[1], result.bits[1]);
  ck_assert_int_eq(origin.bits[0], result.bits[0]);
  ck_assert_int_eq(result_error, my_error);

  src = 0;
  origin.bits[0] = 0b00000000000000000000000000000000;
  origin.bits[1] = 0b00000000000000000000000000000000;
  origin.bits[2] = 0b00000000000000000000000000000000;
  origin.bits[3] = 0b00000000000000000000000000000000;
  result_error = 0;
  my_error = s21_from_int_to_decimal(src, &result);
  ck_assert_int_eq(origin.bits[3], result.bits[3]);
  ck_assert_int_eq(origin.bits[2], result.bits[2]);
  ck_assert_int_eq(origin.bits[1], result.bits[1]);
  ck_assert_int_eq(origin.bits[0], result.bits[0]);
  ck_assert_int_eq(result_error, my_error);

  src = 45678;
  origin.bits[0] = 0b00000000000000001011001001101110;
  origin.bits[1] = 0b00000000000000000000000000000000;
  origin.bits[2] = 0b00000000000000000000000000000000;
  origin.bits[3] = 0b00000000000000000000000000000000;
  result_error = 0;
  my_error = s21_from_int_to_decimal(src, &result);
  ck_assert_int_eq(origin.bits[3], result.bits[3]);
  ck_assert_int_eq(origin.bits[2], result.bits[2]);
  ck_assert_int_eq(origin.bits[1], result.bits[1]);
  ck_assert_int_eq(origin.bits[0], result.bits[0]);
  ck_assert_int_eq(result_error, my_error);

  src = -45678;
  origin.bits[0] = 0b00000000000000001011001001101110;
  origin.bits[1] = 0b00000000000000000000000000000000;
  origin.bits[2] = 0b00000000000000000000000000000000;
  origin.bits[3] = 0b10000000000000000000000000000000;
  result_error = 0;
  my_error = s21_from_int_to_decimal(src, &result);
  ck_assert_int_eq(origin.bits[3], result.bits[3]);
  ck_assert_int_eq(origin.bits[2], result.bits[2]);
  ck_assert_int_eq(origin.bits[1], result.bits[1]);
  ck_assert_int_eq(origin.bits[0], result.bits[0]);
  ck_assert_int_eq(result_error, my_error);

  src = 5555555;
  origin.bits[0] = 0b00000000010101001100010101100011;
  origin.bits[1] = 0b00000000000000000000000000000000;
  origin.bits[2] = 0b00000000000000000000000000000000;
  origin.bits[3] = 0b00000000000000000000000000000000;
  result_error = 0;
  my_error = s21_from_int_to_decimal(src, &result);
  ck_assert_int_eq(origin.bits[3], result.bits[3]);
  ck_assert_int_eq(origin.bits[2], result.bits[2]);
  ck_assert_int_eq(origin.bits[1], result.bits[1]);
  ck_assert_int_eq(origin.bits[0], result.bits[0]);
  ck_assert_int_eq(result_error, my_error);

  src = -5555555;
  origin.bits[0] = 0b00000000010101001100010101100011;
  origin.bits[1] = 0b00000000000000000000000000000000;
  origin.bits[2] = 0b00000000000000000000000000000000;
  origin.bits[3] = 0b10000000000000000000000000000000;
  result_error = 0;
  my_error = s21_from_int_to_decimal(src, &result);
  ck_assert_int_eq(origin.bits[3], result.bits[3]);
  ck_assert_int_eq(origin.bits[2], result.bits[2]);
  ck_assert_int_eq(origin.bits[1], result.bits[1]);
  ck_assert_int_eq(origin.bits[0], result.bits[0]);
  ck_assert_int_eq(result_error, my_error);

  src = 127;
  origin.bits[0] = 0b00000000000000000000000001111111;
  origin.bits[1] = 0b00000000000000000000000000000000;
  origin.bits[2] = 0b00000000000000000000000000000000;
  origin.bits[3] = 0b00000000000000000000000000000000;
  result_error = 0;
  my_error = s21_from_int_to_decimal(src, &result);
  ck_assert_int_eq(origin.bits[3], result.bits[3]);
  ck_assert_int_eq(origin.bits[2], result.bits[2]);
  ck_assert_int_eq(origin.bits[1], result.bits[1]);
  ck_assert_int_eq(origin.bits[0], result.bits[0]);
  ck_assert_int_eq(result_error, my_error);

  src = -127;
  origin.bits[0] = 0b00000000000000000000000001111111;
  origin.bits[1] = 0b00000000000000000000000000000000;
  origin.bits[2] = 0b00000000000000000000000000000000;
  origin.bits[3] = 0b10000000000000000000000000000000;
  result_error = 0;
  my_error = s21_from_int_to_decimal(src, &result);
  ck_assert_int_eq(origin.bits[3], result.bits[3]);
  ck_assert_int_eq(origin.bits[2], result.bits[2]);
  ck_assert_int_eq(origin.bits[1], result.bits[1]);
  ck_assert_int_eq(origin.bits[0], result.bits[0]);
  ck_assert_int_eq(result_error, my_error);

  src = 34567898;
  origin.bits[0] = 0b00000010000011110111011011011010;
  origin.bits[1] = 0b00000000000000000000000000000000;
  origin.bits[2] = 0b00000000000000000000000000000000;
  origin.bits[3] = 0b00000000000000000000000000000000;
  result_error = 0;
  my_error = s21_from_int_to_decimal(src, &result);
  ck_assert_int_eq(origin.bits[3], result.bits[3]);
  ck_assert_int_eq(origin.bits[2], result.bits[2]);
  ck_assert_int_eq(origin.bits[1], result.bits[1]);
  ck_assert_int_eq(origin.bits[0], result.bits[0]);
  ck_assert_int_eq(result_error, my_error);

  src = -34567898;
  origin.bits[0] = 0b00000010000011110111011011011010;
  origin.bits[1] = 0b00000000000000000000000000000000;
  origin.bits[2] = 0b00000000000000000000000000000000;
  origin.bits[3] = 0b10000000000000000000000000000000;
  result_error = 0;
  my_error = s21_from_int_to_decimal(src, &result);
  ck_assert_int_eq(origin.bits[3], result.bits[3]);
  ck_assert_int_eq(origin.bits[2], result.bits[2]);
  ck_assert_int_eq(origin.bits[1], result.bits[1]);
  ck_assert_int_eq(origin.bits[0], result.bits[0]);
  ck_assert_int_eq(result_error, my_error);

  src = 999;
  origin.bits[0] = 0b00000000000000000000001111100111;
  origin.bits[1] = 0b00000000000000000000000000000000;
  origin.bits[2] = 0b00000000000000000000000000000000;
  origin.bits[3] = 0b00000000000000000000000000000000;
  result_error = 0;
  my_error = s21_from_int_to_decimal(src, &result);
  ck_assert_int_eq(origin.bits[3], result.bits[3]);
  ck_assert_int_eq(origin.bits[2], result.bits[2]);
  ck_assert_int_eq(origin.bits[1], result.bits[1]);
  ck_assert_int_eq(origin.bits[0], result.bits[0]);
  ck_assert_int_eq(result_error, my_error);

  src = -999;
  origin.bits[0] = 0b00000000000000000000001111100111;
  origin.bits[1] = 0b00000000000000000000000000000000;
  origin.bits[2] = 0b00000000000000000000000000000000;
  origin.bits[3] = 0b10000000000000000000000000000000;
  result_error = 0;
  my_error = s21_from_int_to_decimal(src, &result);
  ck_assert_int_eq(origin.bits[3], result.bits[3]);
  ck_assert_int_eq(origin.bits[2], result.bits[2]);
  ck_assert_int_eq(origin.bits[1], result.bits[1]);
  ck_assert_int_eq(origin.bits[0], result.bits[0]);
  ck_assert_int_eq(result_error, my_error);

  src = -3254754;
  origin.bits[0] = 0b00000000001100011010100111100010;
  origin.bits[1] = 0b00000000000000000000000000000000;
  origin.bits[2] = 0b00000000000000000000000000000000;
  origin.bits[3] = 0b10000000000000000000000000000000;
  result_error = 0;
  my_error = s21_from_int_to_decimal(src, &result);
  ck_assert_int_eq(origin.bits[3], result.bits[3]);
  ck_assert_int_eq(origin.bits[2], result.bits[2]);
  ck_assert_int_eq(origin.bits[1], result.bits[1]);
  ck_assert_int_eq(origin.bits[0], result.bits[0]);
  ck_assert_int_eq(result_error, my_error);

  src = 3436425;
  origin.bits[0] = 0b00000000001101000110111110001001;
  origin.bits[1] = 0b00000000000000000000000000000000;
  origin.bits[2] = 0b00000000000000000000000000000000;
  origin.bits[3] = 0b00000000000000000000000000000000;
  result_error = 0;
  my_error = s21_from_int_to_decimal(src, &result);
  ck_assert_int_eq(origin.bits[3], result.bits[3]);
  ck_assert_int_eq(origin.bits[2], result.bits[2]);
  ck_assert_int_eq(origin.bits[1], result.bits[1]);
  ck_assert_int_eq(origin.bits[0], result.bits[0]);
  ck_assert_int_eq(result_error, my_error);

  src = 222222222;
  origin.bits[0] = 0b00001101001111101101011110001110;
  origin.bits[1] = 0b00000000000000000000000000000000;
  origin.bits[2] = 0b00000000000000000000000000000000;
  origin.bits[3] = 0b00000000000000000000000000000000;
  result_error = 0;
  my_error = s21_from_int_to_decimal(src, &result);
  ck_assert_int_eq(origin.bits[3], result.bits[3]);
  ck_assert_int_eq(origin.bits[2], result.bits[2]);
  ck_assert_int_eq(origin.bits[1], result.bits[1]);
  ck_assert_int_eq(origin.bits[0], result.bits[0]);
  ck_assert_int_eq(result_error, my_error);



#test S21_IS_EQUAL
    // !!!!! Тест готовый, написан правильно !!!!!
    //         == |  0.000000  1.000000 -1.000000       inf      -inf      -nan
    // -------------------------------------------------------------------------
    //   0.000000 |      TRUE     FALSE     FALSE     FALSE     FALSE     FALSE
    //   1.000000 |     FALSE      TRUE     FALSE     FALSE     FALSE     FALSE
    //  -1.000000 |     FALSE     FALSE      TRUE     FALSE     FALSE     FALSE
    //        inf |     FALSE     FALSE     FALSE      TRUE     FALSE     FALSE
    //       -inf |     FALSE     FALSE     FALSE     FALSE      TRUE     FALSE
    //       -nan |     FALSE     FALSE     FALSE     FALSE     FALSE     FALSE
    s21_decimal value_01 = {{4294967295, 4294967295, 4294967295, 0x80000000}};  // -79 228 162 514 264 337 593 543 950 335
    s21_decimal value_09 = {{1, 0, 0, 0x80000000}};                             // -1
    s21_decimal value_10 = {{0, 0, 0, 0x80000000}};                             // -0
    s21_decimal value_11 = {{0, 0, 0, 0x00000000}};                             //  0
    s21_decimal value_12 = {{1, 0, 0, 0x00000000}};                             //  1
    s21_decimal value_20 = {{4294967295, 4294967295, 4294967295, 0x00000000}};  //  79 228 162 514 264 337 593 543 950 335
    s21_decimal value_21 = {{0, 0, 0, 0x80FF0000}};                             // -INF
    s21_decimal value_22 = {{0, 0, 0, 0x00FF0000}};                             // +INF
    s21_decimal value_23 = {{1431655765, 1431655765, 1431655765, 0x80FF0000}};  //  NaN (диапазон от (-1)*10^(-28) до (-1)*10^(-28), но !=0)
    s21_decimal value_24 = {{254, 0, 0, 0x00010000}};                           //  25,4
    s21_decimal value_25 = {{10, 0, 0, 0x00000000}};                            //  10
    s21_decimal value_26 = {{2147483647, 2147483647, 2147483647, 0x001B0000}};  //  9, 903 520 314 283 042 199 192 993 791
    s21_decimal value_27 = {{108903, 0, 0, 0x00010000}};                        //  108 90,3
    s21_decimal value_28 = {{254, 0, 0, 0x00010000}};                           //  25,4
    s21_decimal value_29 = {{10, 0, 0, 0x80000000}};                            //  -10
    s21_decimal value_30 = {{2147483647, 2147483647, 2147483647, 0x001B0000}};  //  -9, 903 520 314 283 042 199 192 993 791
    s21_decimal value_31 = {{108903, 0, 0, 0x00010000}};                        //  108 90,3
    s21_decimal value_32 = {{254, 0, 0, 0x80010000}};                           //  -25,4
    s21_decimal value_33 = {{10, 0, 0, 0x80000000}};                            //  -10
    s21_decimal value_34 = {{2147483647, 2147483647, 2147483647, 0x801B0000}};  //  -9, 903 520 314 283 042 199 192 993 791
    s21_decimal value_35 = {{108903, 0, 0, 0x80010000}};                        //  -108 90,3
    s21_decimal value_36 = {{3456, 0, 0, 0x00020000}};                          //  34,56
    s21_decimal value_37 = {{345600, 0, 0, 0x00040000}};                        //  34,5600
    s21_decimal value_38 = {{1000, 0, 0, 0x00030000}};                          //  1,000
    s21_decimal value_39 = {{100, 0, 0, 0x00020000}};                           //  1,00
    s21_decimal value_40 = {{100000, 0, 0, 0x00050000}};                        //  1,00000
    s21_decimal value_41 = {{0, 567, 0, 0x00050000}};                           //  24 352 464,568 32
    // 0 - FALSE (первое значаение меньше или больше второго). 1 -  TRUE (первое значение равно второму).
    ck_assert_int_eq(s21_is_equal(value_01, value_01), 1);  // 1: -79 228 162 514 264 337 593 543 950 335 == -79 228 162 514 264 337 593 543 950 335
    ck_assert_int_eq(s21_is_equal(value_01, value_20), 0);  // 0: -79 228 162 514 264 337 593 543 950 335 < 79 228 162 514 264 337 593 543 950 335
    ck_assert_int_eq(s21_is_equal(value_20, value_01), 0);  // 0:  79 228 162 514 264 337 593 543 950 335 > -79 228 162 514 264 337 593 543 950 335
    ck_assert_int_eq(s21_is_equal(value_10, value_11), 1);  // 1: -0 == +0
    ck_assert_int_eq(s21_is_equal(value_10, value_10), 1);  // 1: -0 == -0
    ck_assert_int_eq(s21_is_equal(value_11, value_11), 1);  // 1: +0 == +0
    ck_assert_int_eq(s21_is_equal(value_11, value_12), 0);  // 0: 0 < 1
    ck_assert_int_eq(s21_is_equal(value_11, value_09), 0);  // 0: 0 > -1
    ck_assert_int_eq(s21_is_equal(value_11, value_22), 0);  // 0: 0 < +INF   тест настроен правильно, не дописана функция s21_is_great либо s21_is_equal
    ck_assert_int_eq(s21_is_equal(value_11, value_21), 0);  // 0: 0 > -INF   тест настроен правильно, не дописана функция s21_is_great либо s21_is_equal
    ck_assert_int_eq(s21_is_equal(value_11, value_23), 0);  // 0: 0 !< NaN   тест настроен правильно, не дописана функция s21_is_great либо s21_is_equal
    ck_assert_int_eq(s21_is_equal(value_12, value_11), 0);  // 0: 1 > 0
    ck_assert_int_eq(s21_is_equal(value_12, value_12), 1);  // 1: 1 == 1
    ck_assert_int_eq(s21_is_equal(value_12, value_09), 0);  // 0: 1 > -1
    ck_assert_int_eq(s21_is_equal(value_12, value_22), 0);  // 0: 1 < +INF
    ck_assert_int_eq(s21_is_equal(value_12, value_21), 0);  // 0: 1 > -INF   тест настроен правильно, не дописана функция s21_is_great либо s21_is_equal
    ck_assert_int_eq(s21_is_equal(value_12, value_23), 0);  // 0: 1 != NaN
    ck_assert_int_eq(s21_is_equal(value_09, value_11), 0);  // 0: -1 < 0
    ck_assert_int_eq(s21_is_equal(value_09, value_12), 0);  // 0: -1 < 1
    ck_assert_int_eq(s21_is_equal(value_09, value_09), 1);  // 1: -1 == -1
    ck_assert_int_eq(s21_is_equal(value_09, value_22), 0);  // 0: -1 < +INF
    ck_assert_int_eq(s21_is_equal(value_09, value_21), 0);  // 0: -1 > -INF   тест настроен правильно, не дописана функция s21_is_great либо s21_is_equal
    ck_assert_int_eq(s21_is_equal(value_09, value_23), 0);  // 0: -1 != NaN
    ck_assert_int_eq(s21_is_equal(value_22, value_11), 0);  // 0: +INF > 0   тест настроен правильно, не дописана функция s21_is_great либо s21_is_equal
    ck_assert_int_eq(s21_is_equal(value_22, value_12), 0);  // 0: +INF > 1
    ck_assert_int_eq(s21_is_equal(value_22, value_09), 0);  // 0: +INF > -1
    ck_assert_int_eq(s21_is_equal(value_22, value_22), 1);  // 1: +INF == +INF
    ck_assert_int_eq(s21_is_equal(value_22, value_21), 0);  // 0: +INF > -INF   тест настроен правильно, не дописана функция s21_is_great либо s21_is_equal
    ck_assert_int_eq(s21_is_equal(value_22, value_23), 0);  // 0: +INF !< NaN   тест настроен правильно, не дописана функция s21_is_great либо s21_is_equal
    ck_assert_int_eq(s21_is_equal(value_21, value_11), 0);  // 0: -INF < 0   тест настроен правильно, не дописана функция s21_is_great либо s21_is_equal
    ck_assert_int_eq(s21_is_equal(value_21, value_12), 0);  // 0: -INF < 1   тест настроен правильно, не дописана функция s21_is_great либо s21_is_equal
    ck_assert_int_eq(s21_is_equal(value_21, value_09), 0);  // 0: -INF < -1   тест настроен правильно, не дописана функция s21_is_great либо s21_is_equal
    ck_assert_int_eq(s21_is_equal(value_21, value_22), 0);  // 0: -INF < +INF   тест настроен правильно, не дописана функция s21_is_great либо s21_is_equal
    ck_assert_int_eq(s21_is_equal(value_21, value_21), 1);  // 1: -INF == -INF
    ck_assert_int_eq(s21_is_equal(value_21, value_23), 0);  // 0: -INF !< NaN   тест настроен правильно, не дописана функция s21_is_great либо s21_is_equal
    ck_assert_int_eq(s21_is_equal(value_23, value_11), 0);  // 0: NaN !< 0   тест настроен правильно, не дописана функция s21_is_great либо s21_is_equal
    ck_assert_int_eq(s21_is_equal(value_23, value_12), 0);  // 0: NaN !< 1
    ck_assert_int_eq(s21_is_equal(value_23, value_09), 0);  // 0: NaN !< -1
    ck_assert_int_eq(s21_is_equal(value_23, value_22), 0);  // 0: NaN !< +INF   тест настроен правильно, не дописана функция s21_is_great либо s21_is_equal
    ck_assert_int_eq(s21_is_equal(value_23, value_21), 0);  // 0: NaN !< -INF   тест настроен правильно, не дописана функция s21_is_great либо s21_is_equal
    ck_assert_int_eq(s21_is_equal(value_23, value_23), 0);  // 0: NaN !< NaN   тест настроен правильно, не дописана функция s21_is_great либо s21_is_equal
    ck_assert_int_eq(s21_is_equal(value_24, value_25), 0);  // 0: 25,4 > 10
    ck_assert_int_eq(s21_is_equal(value_25, value_24), 0);  // 0: 10 < 25,4
    ck_assert_int_eq(s21_is_equal(value_26, value_27), 0);  // 0: 9, 903 520 314 283 042 199 192 993 791 < 108 90,3
    ck_assert_int_eq(s21_is_equal(value_27, value_26), 0);  // 0: 108 90,3 > 9, 903 520 314 283 042 199 192 993 791
    ck_assert_int_eq(s21_is_equal(value_28, value_29), 0);  // 0: 25,4 > -10
    ck_assert_int_eq(s21_is_equal(value_29, value_28), 0);  // 0: -10 < 25,4
    ck_assert_int_eq(s21_is_equal(value_30, value_31), 0);  // 0: -9, 903 520 314 283 042 199 192 993 791 < 108 90,3
    ck_assert_int_eq(s21_is_equal(value_31, value_30), 0);  // 0: 108 90,3 > -9, 903 520 314 283 042 199 192 993 791
    ck_assert_int_eq(s21_is_equal(value_32, value_33), 0);  // 0: -25,4 < -10
    ck_assert_int_eq(s21_is_equal(value_33, value_32), 0);  // 0: -10 > -25,4
    ck_assert_int_eq(s21_is_equal(value_34, value_35), 0);  // 0: -9, 903 520 314 283 042 199 192 993 791 > -108 90,3
    ck_assert_int_eq(s21_is_equal(value_35, value_34), 0);  // 0: -108 90,3 < -9, 903 520 314 283 042 199 192 993 791
    ck_assert_int_eq(s21_is_equal(value_36, value_37), 1);  // 1: 34,56 == 34,5600
    ck_assert_int_eq(s21_is_equal(value_38, value_12), 1);  // 1: 1,000 == 1
    ck_assert_int_eq(s21_is_equal(value_38, value_39), 1);  // 1: 1,000 == 1,00
    ck_assert_int_eq(s21_is_equal(value_38, value_40), 1);  // 1: 1,000 == 1,00000
    ck_assert_int_eq(s21_is_equal(value_41, value_11), 0);  // 0: 24 352 464,568 32 > 0,00000
    
    

#test S21_IS_GREATER_OR_EQUAL
    // !!!!! Тест готовый, написан правильно !!!!!
    //         >= |  0.000000  1.000000 -1.000000       inf      -inf      -nan
    // -------------------------------------------------------------------------
    //   0.000000 |      TRUE     FALSE      TRUE     FALSE      TRUE     FALSE
    //   1.000000 |      TRUE      TRUE      TRUE     FALSE      TRUE     FALSE
    //  -1.000000 |     FALSE     FALSE      TRUE     FALSE      TRUE     FALSE
    //        inf |      TRUE      TRUE      TRUE      TRUE      TRUE     FALSE
    //       -inf |     FALSE     FALSE     FALSE     FALSE      TRUE     FALSE
    //       -nan |     FALSE     FALSE     FALSE     FALSE     FALSE     FALSE
    s21_decimal value_01 = {{4294967295, 4294967295, 4294967295, 0x80000000}};  // -79 228 162 514 264 337 593 543 950 335
    s21_decimal value_09 = {{1, 0, 0, 0x80000000}};                             // -1
    s21_decimal value_10 = {{0, 0, 0, 0x80000000}};                             // -0
    s21_decimal value_11 = {{0, 0, 0, 0x00000000}};                             //  0
    s21_decimal value_12 = {{1, 0, 0, 0x00000000}};                             //  1
    s21_decimal value_20 = {{4294967295, 4294967295, 4294967295, 0x00000000}};  //  79 228 162 514 264 337 593 543 950 335
    s21_decimal value_21 = {{0, 0, 0, 0x80FF0000}};                             // -INF
    s21_decimal value_22 = {{0, 0, 0, 0x00FF0000}};                             // +INF
    s21_decimal value_23 = {{1431655765, 1431655765, 1431655765, 0x80FF0000}};  //  NaN (диапазон от (-1)*10^(-28) до (-1)*10^(-28), но !=0)
    s21_decimal value_24 = {{254, 0, 0, 0x00010000}};                           //  25,4
    s21_decimal value_25 = {{10, 0, 0, 0x00000000}};                            //  10
    s21_decimal value_26 = {{2147483647, 2147483647, 2147483647, 0x001B0000}};  //  9, 903 520 314 283 042 199 192 993 791
    s21_decimal value_27 = {{108903, 0, 0, 0x00010000}};                        //  108 90,3
    s21_decimal value_28 = {{254, 0, 0, 0x00010000}};                           //  25,4
    s21_decimal value_29 = {{10, 0, 0, 0x80000000}};                            //  -10
    s21_decimal value_30 = {{2147483647, 2147483647, 2147483647, 0x001B0000}};  //  -9, 903 520 314 283 042 199 192 993 791
    s21_decimal value_31 = {{108903, 0, 0, 0x00010000}};                        //  108 90,3
    s21_decimal value_32 = {{254, 0, 0, 0x80010000}};                           //  -25,4
    s21_decimal value_33 = {{10, 0, 0, 0x80000000}};                            //  -10
    s21_decimal value_34 = {{2147483647, 2147483647, 2147483647, 0x801B0000}};  //  -9, 903 520 314 283 042 199 192 993 791
    s21_decimal value_35 = {{108903, 0, 0, 0x80010000}};                        //  -108 90,3
    s21_decimal value_36 = {{3456, 0, 0, 0x00020000}};                          //  34,56
    s21_decimal value_37 = {{345600, 0, 0, 0x00040000}};                        //  34,5600
    // 0 - FALSE (первое значаение меньше второго). 1 -  TRUE (первое значение больше или равно второму).
    ck_assert_int_eq(s21_is_greater_or_equal(value_01, value_01), 1);  // 1: -79 228 162 514 264 337 593 543 950 335 == -79 228 162 514 264 337 593 543 950 335
    ck_assert_int_eq(s21_is_greater_or_equal(value_01, value_20), 0);  // 0: -79 228 162 514 264 337 593 543 950 335 < 79 228 162 514 264 337 593 543 950 335
    ck_assert_int_eq(s21_is_greater_or_equal(value_20, value_01), 1);  // 1:  79 228 162 514 264 337 593 543 950 335 > -79 228 162 514 264 337 593 543 950 335
    ck_assert_int_eq(s21_is_greater_or_equal(value_10, value_11), 1);  // 0: -0 == +0
    ck_assert_int_eq(s21_is_greater_or_equal(value_10, value_10), 1);  // 0: -0 == -0
    ck_assert_int_eq(s21_is_greater_or_equal(value_11, value_11), 1);  // 0: +0 == +0
    ck_assert_int_eq(s21_is_greater_or_equal(value_11, value_12), 0);  // 0: 0 < 1
    ck_assert_int_eq(s21_is_greater_or_equal(value_11, value_09), 1);  // 1: 0 > -1
    ck_assert_int_eq(s21_is_greater_or_equal(value_11, value_22), 0);  // 0: 0 < +INF   тест настроен правильно, не дописана функция s21_is_great либо s21_is_equal
    ck_assert_int_eq(s21_is_greater_or_equal(value_11, value_21), 1);  // 0: 1 > -INF
    ck_assert_int_eq(s21_is_greater_or_equal(value_11, value_23), 0);  // 0: 0 !< NaN   тест настроен правильно, не дописана функция s21_is_great либо s21_is_equal
    ck_assert_int_eq(s21_is_greater_or_equal(value_12, value_11), 1);  // 1: 1 > 0
    ck_assert_int_eq(s21_is_greater_or_equal(value_12, value_12), 1);  // 1: 1 == 1
    ck_assert_int_eq(s21_is_greater_or_equal(value_12, value_09), 1);  // 1: 1 > -1
    ck_assert_int_eq(s21_is_greater_or_equal(value_12, value_22), 0);  // 0: 1 < +INF
    ck_assert_int_eq(s21_is_greater_or_equal(value_12, value_21), 1);  // 1: 1 > -INF
    ck_assert_int_eq(s21_is_greater_or_equal(value_12, value_23), 0);  // 0: 1 != NaN
    ck_assert_int_eq(s21_is_greater_or_equal(value_09, value_11), 0);  // 0: -1 < 0
    ck_assert_int_eq(s21_is_greater_or_equal(value_09, value_12), 0);  // 0: -1 < 1
    ck_assert_int_eq(s21_is_greater_or_equal(value_09, value_09), 1);  // 1: -1 == -1
    ck_assert_int_eq(s21_is_greater_or_equal(value_09, value_22), 0);  // 0: -1 < +INF
    ck_assert_int_eq(s21_is_greater_or_equal(value_09, value_21), 1);  // 1: -1 > -INF   тест настроен правильно, не дописана функция s21_is_great либо s21_is_equal
    ck_assert_int_eq(s21_is_greater_or_equal(value_09, value_23), 0);  // 0: -1 != NaN
    ck_assert_int_eq(s21_is_greater_or_equal(value_22, value_11), 1);  // 1: +INF > 0
    ck_assert_int_eq(s21_is_greater_or_equal(value_22, value_12), 1);  // 1: +INF > 1   тест настроен правильно, не дописана функция s21_is_great либо s21_is_equal
    ck_assert_int_eq(s21_is_greater_or_equal(value_22, value_09), 1);  // 1: +INF > -1
    ck_assert_int_eq(s21_is_greater_or_equal(value_22, value_22), 1);  // 1: +INF == +INF
    ck_assert_int_eq(s21_is_greater_or_equal(value_22, value_21), 1);  // 1: +INF > -INF
    ck_assert_int_eq(s21_is_greater_or_equal(value_22, value_23), 0);  // 0: +INF !< NaN   тест настроен правильно, не дописана функция s21_is_great либо s21_is_equal
    ck_assert_int_eq(s21_is_greater_or_equal(value_21, value_11), 0);  // 0: -INF < 0   тест настроен правильно, не дописана функция s21_is_great либо s21_is_equal
    ck_assert_int_eq(s21_is_greater_or_equal(value_21, value_12), 0);  // 0: -INF < 1   тест настроен правильно, не дописана функция s21_is_great либо s21_is_equal
    ck_assert_int_eq(s21_is_greater_or_equal(value_21, value_09), 0);  // 0: -INF < -1   тест настроен правильно, не дописана функция s21_is_great либо s21_is_equal
    ck_assert_int_eq(s21_is_greater_or_equal(value_21, value_22), 0);  // 0: -INF < +INF   тест настроен правильно, не дописана функция s21_is_great либо s21_is_equal
    ck_assert_int_eq(s21_is_greater_or_equal(value_21, value_21), 1);  // 1: -INF == -INF
    ck_assert_int_eq(s21_is_greater_or_equal(value_21, value_23), 0);  // 0: -INF !< NaN    тест настроен правильно, не дописана функция s21_is_great либо s21_is_equal
    ck_assert_int_eq(s21_is_greater_or_equal(value_23, value_11), 0);  // 0: NaN !< 0    тест настроен правильно, не дописана функция s21_is_great либо s21_is_equal
    ck_assert_int_eq(s21_is_greater_or_equal(value_23, value_12), 0);  // 0: NaN !< 1
    ck_assert_int_eq(s21_is_greater_or_equal(value_23, value_09), 0);  // 0: NaN !< -1    тест настроен правильно, не дописана функция s21_is_great либо s21_is_equal
    ck_assert_int_eq(s21_is_greater_or_equal(value_23, value_22), 0);  // 0: NaN !< +INF    тест настроен правильно, не дописана функция s21_is_great либо s21_is_equal
    ck_assert_int_eq(s21_is_greater_or_equal(value_23, value_21), 0);  // 0: NaN !< -INF    тест настроен правильно, не дописана функция s21_is_great либо s21_is_equal
    ck_assert_int_eq(s21_is_greater_or_equal(value_23, value_23), 0);  // 0: NaN !< NaN    тест настроен правильно, не дописана функция s21_is_great либо s21_is_equal
    ck_assert_int_eq(s21_is_greater_or_equal(value_24, value_25), 1);  // 0: 25,4 > 10
    ck_assert_int_eq(s21_is_greater_or_equal(value_25, value_24), 0);  // 0: 10 < 25,4
    ck_assert_int_eq(s21_is_greater_or_equal(value_26, value_27), 0);  // 0: 9, 903 520 314 283 042 199 192 993 791 < 108 90,3
    ck_assert_int_eq(s21_is_greater_or_equal(value_27, value_26), 1);  // 0: 108 90,3 > 9, 903 520 314 283 042 199 192 993 791
    ck_assert_int_eq(s21_is_greater_or_equal(value_28, value_29), 1);  // 0: 25,4 > -10
    ck_assert_int_eq(s21_is_greater_or_equal(value_29, value_28), 0);  // 0: -10 < 25,4
    ck_assert_int_eq(s21_is_greater_or_equal(value_30, value_31), 0);  // 0: -9, 903 520 314 283 042 199 192 993 791 < 108 90,3
    ck_assert_int_eq(s21_is_greater_or_equal(value_31, value_30), 1);  // 0: 108 90,3 > -9, 903 520 314 283 042 199 192 993 791
    ck_assert_int_eq(s21_is_greater_or_equal(value_32, value_33), 0);  // 0: -25,4 < -10
    ck_assert_int_eq(s21_is_greater_or_equal(value_33, value_32), 1);  // 0: -10 > -25,4
    ck_assert_int_eq(s21_is_greater_or_equal(value_34, value_35), 1);  // 0: -9, 903 520 314 283 042 199 192 993 791 > -108 90,3
    ck_assert_int_eq(s21_is_greater_or_equal(value_35, value_34), 0);  // 0: -108 90,3 < -9, 903 520 314 283 042 199 192 993 791
    ck_assert_int_eq(s21_is_greater_or_equal(value_36, value_37), 1);  // 1: 34,56 == 34,5600



#test S21_IS_GREATER
    // !!!!! Тест готовый, написан правильно !!!!!
    //          > |  0.000000  1.000000 -1.000000       inf      -inf      -nan
    // -------------------------------------------------------------------------
    //   0.000000 |     FALSE     FALSE      TRUE     FALSE      TRUE     FALSE
    //   1.000000 |      TRUE     FALSE      TRUE     FALSE      TRUE     FALSE
    //  -1.000000 |     FALSE     FALSE     FALSE     FALSE      TRUE     FALSE
    //        inf |      TRUE      TRUE      TRUE     FALSE      TRUE     FALSE
    //       -inf |     FALSE     FALSE     FALSE     FALSE     FALSE     FALSE
    //       -nan |     FALSE     FALSE     FALSE     FALSE     FALSE     FALSE
    s21_decimal value_01 = {{4294967295, 4294967295, 4294967295, 0x80000000}};  // -79 228 162 514 264 337 593 543 950 335
    s21_decimal value_09 = {{1, 0, 0, 0x80000000}};                             // -1
    s21_decimal value_10 = {{0, 0, 0, 0x80000000}};                             // -0
    s21_decimal value_11 = {{0, 0, 0, 0x00000000}};                             //  0
    s21_decimal value_12 = {{1, 0, 0, 0x00000000}};                             //  1
    s21_decimal value_20 = {{4294967295, 4294967295, 4294967295, 0x00000000}};  //  79 228 162 514 264 337 593 543 950 335
    s21_decimal value_21 = {{0, 0, 0, 0x80FF0000}};                             // -INF
    s21_decimal value_22 = {{0, 0, 0, 0x00FF0000}};                             // +INF
    s21_decimal value_23 = {{1431655765, 1431655765, 1431655765, 0x80FF0000}};  //  NaN (диапазон от (-1)*10^(-28) до (-1)*10^(-28), но !=0)
    s21_decimal value_24 = {{254, 0, 0, 0x00010000}};                           //  25,4
    s21_decimal value_25 = {{10, 0, 0, 0x00000000}};                            //  10
    s21_decimal value_26 = {{2147483647, 2147483647, 2147483647, 0x001B0000}};  //  9, 903 520 314 283 042 199 192 993 791
    s21_decimal value_27 = {{108903, 0, 0, 0x00010000}};                        //  108 90,3
    s21_decimal value_28 = {{254, 0, 0, 0x00010000}};                           //  25,4
    s21_decimal value_29 = {{10, 0, 0, 0x80000000}};                            //  -10
    s21_decimal value_30 = {{2147483647, 2147483647, 2147483647, 0x001B0000}};  //  -9, 903 520 314 283 042 199 192 993 791
    s21_decimal value_31 = {{108903, 0, 0, 0x00010000}};                        //  108 90,3
    s21_decimal value_32 = {{254, 0, 0, 0x80010000}};                           //  -25,4
    s21_decimal value_33 = {{10, 0, 0, 0x80000000}};                            //  -10
    s21_decimal value_34 = {{2147483647, 2147483647, 2147483647, 0x801B0000}};  //  -9, 903 520 314 283 042 199 192 993 791
    s21_decimal value_35 = {{108903, 0, 0, 0x80010000}};                        //  -108 90,3
    s21_decimal value_36 = {{4567891, 0, 0, 0x80060000}};                       //  -4,567 891
    s21_decimal value_37 = {{9753181, 0, 0, 0x80060000}};                       //  -9,753 181
    s21_decimal value_38 = {{560, 0, 0, 0x80010000}};                           //  -56,0
    s21_decimal value_39 = {{5600, 0, 0, 0x80020000}};                          //  -56,00
    // 0 - FALSE (первое значаение меньше или равно второму). 1 -  TRUE (первое значение больше).
    ck_assert_int_eq(s21_is_greater(value_01, value_01), 0);  // 0: -79 228 162 514 264 337 593 543 950 335 == -79 228 162 514 264 337 593 543 950 335
    ck_assert_int_eq(s21_is_greater(value_01, value_20), 0);  // 0: -79 228 162 514 264 337 593 543 950 335 < 79 228 162 514 264 337 593 543 950 335
    ck_assert_int_eq(s21_is_greater(value_20, value_01), 1);  // 1:  79 228 162 514 264 337 593 543 950 335 > -79 228 162 514 264 337 593 543 950 335
    ck_assert_int_eq(s21_is_greater(value_10, value_11), 0);  // 0: -0 == +0
    ck_assert_int_eq(s21_is_greater(value_10, value_10), 0);  // 0: -0 == -0
    ck_assert_int_eq(s21_is_greater(value_11, value_11), 0);  // 0: +0 == +0
    ck_assert_int_eq(s21_is_greater(value_11, value_12), 0);  // 0: 0 < 1
    ck_assert_int_eq(s21_is_greater(value_11, value_09), 1);  // 1: 0 > -1
    ck_assert_int_eq(s21_is_greater(value_11, value_22), 0);  // 0: 0 < +INF
    ck_assert_int_eq(s21_is_greater(value_11, value_21), 1);  // 1: 0 > -INF
    ck_assert_int_eq(s21_is_greater(value_11, value_23), 0);  // 0: 0 !< NaN
    ck_assert_int_eq(s21_is_greater(value_12, value_11), 1);  // 1: 1 > 0
    ck_assert_int_eq(s21_is_greater(value_12, value_12), 0);  // 0: 1 == 1
    ck_assert_int_eq(s21_is_greater(value_12, value_09), 1);  // 1: 1 > -1
    ck_assert_int_eq(s21_is_greater(value_12, value_22), 0);  // 0: 1 < +INF
    ck_assert_int_eq(s21_is_greater(value_12, value_21), 1);  // 1: 1 > -INF
    ck_assert_int_eq(s21_is_greater(value_12, value_23), 0);  // 0: 1 != NaN
    ck_assert_int_eq(s21_is_greater(value_09, value_11), 0);  // 0: -1 < 0
    ck_assert_int_eq(s21_is_greater(value_09, value_12), 0);  // 0: -1 < 1
    ck_assert_int_eq(s21_is_greater(value_09, value_09), 0);  // 0: -1 == -1
    ck_assert_int_eq(s21_is_greater(value_09, value_22), 0);  // 0: -1 < +INF
    ck_assert_int_eq(s21_is_greater(value_09, value_21), 1);  // 1: -1 > -INF   тест настроен правильно, не дописана функция s21_is_great либо s21_is_equal
    ck_assert_int_eq(s21_is_greater(value_09, value_23), 0);  // 0: -1 != NaN
    ck_assert_int_eq(s21_is_greater(value_22, value_11), 1);  // 1: +INF > 0   тест настроен правильно, не дописана функция s21_is_great либо s21_is_equal
    ck_assert_int_eq(s21_is_greater(value_22, value_12), 1);  // 1: +INF > 1   тест настроен правильно, не дописана функция s21_is_great либо s21_is_equal
    ck_assert_int_eq(s21_is_greater(value_22, value_09), 1);  // 1: +INF > -1
    ck_assert_int_eq(s21_is_greater(value_22, value_22), 0);  // 0: +INF == +INF
    ck_assert_int_eq(s21_is_greater(value_22, value_21), 1);  // 1: +INF > -INF
    ck_assert_int_eq(s21_is_greater(value_22, value_23), 0);  // 0: +INF !< NaN
    ck_assert_int_eq(s21_is_greater(value_21, value_11), 0);  // 0: -INF < 0
    ck_assert_int_eq(s21_is_greater(value_21, value_12), 0);  // 0: -INF < 1
    ck_assert_int_eq(s21_is_greater(value_21, value_09), 0);  // 0: -INF < -1
    ck_assert_int_eq(s21_is_greater(value_21, value_22), 0);  // 0: -INF < +INF
    ck_assert_int_eq(s21_is_greater(value_21, value_21), 0);  // 0: -INF == -INF
    ck_assert_int_eq(s21_is_greater(value_21, value_23), 0);  // 0: -INF !< NaN 
    ck_assert_int_eq(s21_is_greater(value_23, value_11), 0);  // 0: NaN !< 0
    ck_assert_int_eq(s21_is_greater(value_23, value_12), 0);  // 0: NaN !< 1
    ck_assert_int_eq(s21_is_greater(value_23, value_09), 0);  // 0: NaN !< -1   тест настроен правильно, не дописана функция s21_is_great либо s21_is_equal
    ck_assert_int_eq(s21_is_greater(value_23, value_22), 0);  // 0: NaN !< +INF
    ck_assert_int_eq(s21_is_greater(value_23, value_21), 0);  // 0: NaN !< -INF   тест настроен правильно, не дописана функция s21_is_great либо s21_is_equal
    ck_assert_int_eq(s21_is_greater(value_23, value_23), 0);  // 0: NaN !< NaN
    ck_assert_int_eq(s21_is_greater(value_24, value_25), 1);  // 1: 25,4 > 10
    ck_assert_int_eq(s21_is_greater(value_25, value_24), 0);  // 0: 10 < 25,4
    ck_assert_int_eq(s21_is_greater(value_26, value_27), 0);  // 0: 9, 903 520 314 283 042 199 192 993 791 < 108 90,3
    ck_assert_int_eq(s21_is_greater(value_27, value_26), 1);  // 1: 108 90,3 > 9, 903 520 314 283 042 199 192 993 791
    ck_assert_int_eq(s21_is_greater(value_28, value_29), 1);  // 1: 25,4 > -10
    ck_assert_int_eq(s21_is_greater(value_29, value_28), 0);  // 0: -10 < 25,4
    ck_assert_int_eq(s21_is_greater(value_30, value_31), 0);  // 0: -9, 903 520 314 283 042 199 192 993 791 < 108 90,3
    ck_assert_int_eq(s21_is_greater(value_31, value_30), 1);  // 1: 108 90,3 > -9, 903 520 314 283 042 199 192 993 791
    ck_assert_int_eq(s21_is_greater(value_32, value_33), 0);  // 0: -25,4 < -10
    ck_assert_int_eq(s21_is_greater(value_33, value_32), 1);  // 1: -10 > -25,4
    ck_assert_int_eq(s21_is_greater(value_34, value_35), 1);  // 1: -9, 903 520 314 283 042 199 192 993 791 > -108 90,3
    ck_assert_int_eq(s21_is_greater(value_35, value_34), 0);  // 0: -108 90,3 < -9, 903 520 314 283 042 199 192 993 791
    ck_assert_int_eq(s21_is_greater(value_36, value_37), 1);  // 1: -4,567 891 > -9,753 181
    ck_assert_int_eq(s21_is_greater(value_37, value_36), 0);  // 0: -9,753 181 < -4,567 891
    ck_assert_int_eq(s21_is_greater(value_38, value_39), 0);  // 0: -56,0 == -56,00



#test S21_IS_LESS_OR_EQUAL
    // !!!!! Тест готовый, написан правильно !!!!!
    //         <= |  0.000000  1.000000 -1.000000       inf      -inf      -nan
    // -------------------------------------------------------------------------
    //   0.000000 |      TRUE      TRUE     FALSE      TRUE     FALSE     FALSE
    //   1.000000 |     FALSE      TRUE     FALSE      TRUE     FALSE     FALSE
    //  -1.000000 |      TRUE      TRUE      TRUE      TRUE     FALSE     FALSE
    //        inf |     FALSE     FALSE     FALSE      TRUE     FALSE     FALSE
    //       -inf |      TRUE      TRUE      TRUE      TRUE      TRUE     FALSE
    //       -nan |     FALSE     FALSE     FALSE     FALSE     FALSE     FALSE
    s21_decimal value_01 = {{4294967295, 4294967295, 4294967295, 0x80000000}};  // -79 228 162 514 264 337 593 543 950 335
    s21_decimal value_09 = {{1, 0, 0, 0x80000000}};                             // -1
    s21_decimal value_10 = {{0, 0, 0, 0x80000000}};                             // -0
    s21_decimal value_11 = {{0, 0, 0, 0x00000000}};                             //  0
    s21_decimal value_12 = {{1, 0, 0, 0x00000000}};                             //  1
    s21_decimal value_20 = {{4294967295, 4294967295, 4294967295, 0x00000000}};  //  79 228 162 514 264 337 593 543 950 335
    s21_decimal value_21 = {{0, 0, 0, 0x80FF0000}};                             // -INF
    s21_decimal value_22 = {{0, 0, 0, 0x00FF0000}};                             // +INF
    s21_decimal value_23 = {{1431655765, 1431655765, 1431655765, 0x80FF0000}};  //  NaN (диапазон от (-1)*10^(-28) до (-1)*10^(-28), но !=0)
    // 0 - FALSE (первое значаение больше второго). 1 -  TRUE (первое значение меньше или равно второму).
    ck_assert_int_eq(s21_is_less_or_equal(value_01, value_01), 1);  // 1: -79 228 162 514 264 337 593 543 950 335 == -79 228 162 514 264 337 593 543 950 335
    ck_assert_int_eq(s21_is_less_or_equal(value_01, value_20), 1);  // 1: -79 228 162 514 264 337 593 543 950 335 < 79 228 162 514 264 337 593 543 950 335   тест настроен правильно, не дописана функция s21_is_great либо s21_is_equal
    ck_assert_int_eq(s21_is_less_or_equal(value_20, value_01), 0);  // 0:  79 228 162 514 264 337 593 543 950 335 > -79 228 162 514 264 337 593 543 950 335
    ck_assert_int_eq(s21_is_less_or_equal(value_10, value_11), 1);  // 0: -0 == +0
    ck_assert_int_eq(s21_is_less_or_equal(value_10, value_10), 1);  // 0: -0 == -0
    ck_assert_int_eq(s21_is_less_or_equal(value_11, value_11), 1);  // 0: +0 == +0
    ck_assert_int_eq(s21_is_less_or_equal(value_11, value_12), 1);  // 1: 0 < 1   тест настроен правильно, не дописана функция s21_is_great либо s21_is_equal
    ck_assert_int_eq(s21_is_less_or_equal(value_11, value_09), 0);  // 0: 0 > -1
    ck_assert_int_eq(s21_is_less_or_equal(value_11, value_22), 1);  // 1: 0 < +INF
    ck_assert_int_eq(s21_is_less_or_equal(value_11, value_21), 0);  // 0: 0 > -INF   тест настроен правильно, не дописана функция s21_is_great либо s21_is_equal
    ck_assert_int_eq(s21_is_less_or_equal(value_11, value_23), 0);  // 0: 0 !< NaN   тест настроен правильно, не дописана функция s21_is_great либо s21_is_equal
    ck_assert_int_eq(s21_is_less_or_equal(value_12, value_11), 0);  // 0: 1 > 0
    ck_assert_int_eq(s21_is_less_or_equal(value_12, value_12), 1);  // 1: 1 == 1
    ck_assert_int_eq(s21_is_less_or_equal(value_12, value_09), 0);  // 0: 1 > -1
    ck_assert_int_eq(s21_is_less_or_equal(value_12, value_22), 1);  // 1: 1 < +INF   тест настроен правильно, не дописана функция s21_is_great либо s21_is_equal
    ck_assert_int_eq(s21_is_less_or_equal(value_12, value_21), 0);  // 0: 1 > -INF   тест настроен правильно, не дописана функция s21_is_great либо s21_is_equal
    ck_assert_int_eq(s21_is_less_or_equal(value_12, value_23), 0);  // 0: 1 != NaN
    ck_assert_int_eq(s21_is_less_or_equal(value_09, value_11), 1);  // 1: -1 < 0   тест настроен правильно, не дописана функция s21_is_great либо s21_is_equal
    ck_assert_int_eq(s21_is_less_or_equal(value_09, value_12), 1);  // 1: -1 < 1   тест настроен правильно, не дописана функция s21_is_great либо s21_is_equal
    ck_assert_int_eq(s21_is_less_or_equal(value_09, value_09), 1);  // 1: -1 == -1
    ck_assert_int_eq(s21_is_less_or_equal(value_09, value_22), 1);  // 1: -1 < +INF   тест настроен правильно, не дописана функция s21_is_great либо s21_is_equal
    ck_assert_int_eq(s21_is_less_or_equal(value_09, value_21), 0);  // 0: -1 > -INF   тест настроен правильно, не дописана функция s21_is_great либо s21_is_equal
    ck_assert_int_eq(s21_is_less_or_equal(value_09, value_23), 0);  // 0: -1 != NaN
    ck_assert_int_eq(s21_is_less_or_equal(value_22, value_11), 0);  // 0: +INF > 0   тест настроен правильно, не дописана функция s21_is_great либо s21_is_equal
    ck_assert_int_eq(s21_is_less_or_equal(value_22, value_12), 0);  // 0: +INF > 1
    ck_assert_int_eq(s21_is_less_or_equal(value_22, value_09), 0);  // 0: +INF > -1
    ck_assert_int_eq(s21_is_less_or_equal(value_22, value_22), 1);  // 1: +INF == +INF
    ck_assert_int_eq(s21_is_less_or_equal(value_22, value_21), 0);  // 0: +INF > -INF   тест настроен правильно, не дописана функция s21_is_great либо s21_is_equal
    ck_assert_int_eq(s21_is_less_or_equal(value_22, value_23), 0);  // 0: +INF !< NaN   тест настроен правильно, не дописана функция s21_is_great либо s21_is_equal
    ck_assert_int_eq(s21_is_less_or_equal(value_21, value_11), 1);  // 1: -INF < 0
    ck_assert_int_eq(s21_is_less_or_equal(value_21, value_12), 1);  // 1: -INF < 1   тест настроен правильно, не дописана функция s21_is_great либо s21_is_equal
    ck_assert_int_eq(s21_is_less_or_equal(value_21, value_09), 1);  // 1: -INF < -1   тест настроен правильно, не дописана функция s21_is_great либо s21_is_equal
    ck_assert_int_eq(s21_is_less_or_equal(value_21, value_22), 1);  // 1: -INF < +INF
    ck_assert_int_eq(s21_is_less_or_equal(value_21, value_21), 1);  // 1: -INF == -INF
    ck_assert_int_eq(s21_is_less_or_equal(value_21, value_23), 0);  // 0: -INF !< NaN    тест настроен правильно, не дописана функция s21_is_great либо s21_is_equal
    ck_assert_int_eq(s21_is_less_or_equal(value_23, value_11), 0);  // 0: NaN !< 0    тест настроен правильно, не дописана функция s21_is_great либо s21_is_equal
    ck_assert_int_eq(s21_is_less_or_equal(value_23, value_12), 0);  // 0: NaN !< 1
    ck_assert_int_eq(s21_is_less_or_equal(value_23, value_09), 0);  // 0: NaN !< -1
    ck_assert_int_eq(s21_is_less_or_equal(value_23, value_22), 0);  // 0: NaN !< +INF    тест настроен правильно, не дописана функция s21_is_great либо s21_is_equal
    ck_assert_int_eq(s21_is_less_or_equal(value_23, value_21), 0);  // 0: NaN !< -INF    тест настроен правильно, не дописана функция s21_is_great либо s21_is_equal
    ck_assert_int_eq(s21_is_less_or_equal(value_23, value_23), 0);  // 0: NaN !< NaN    тест настроен правильно, не дописана функция s21_is_great либо s21_is_equal



#test S21_IS_LESS
    // !!!!! Тест готовый, написан правильно !!!!!
    //        < |  0.000000  1.000000 -1.000000       inf      -inf      -nan
    //  -------------------------------------------------------------------------
    // 0.000000 |     FALSE      TRUE     FALSE      TRUE     FALSE     FALSE
    // 1.000000 |     FALSE     FALSE     FALSE      TRUE     FALSE     FALSE
    //-1.000000 |      TRUE      TRUE     FALSE      TRUE     FALSE     FALSE
    //      inf |     FALSE     FALSE     FALSE     FALSE     FALSE     FALSE
    //     -inf |      TRUE      TRUE      TRUE      TRUE     FALSE     FALSE
    //     -nan |     FALSE     FALSE     FALSE     FALSE     FALSE     FALSE
    s21_decimal value_01 = {{4294967295, 4294967295, 4294967295, 0x80000000}};  // -79 228 162 514 264 337 593 543 950 335
    s21_decimal value_09 = {{1, 0, 0, 0x80000000}};                             // -1
    s21_decimal value_10 = {{0, 0, 0, 0x80000000}};                             // -0
    s21_decimal value_11 = {{0, 0, 0, 0x00000000}};                             //  0
    s21_decimal value_12 = {{1, 0, 0, 0x00000000}};                             //  1
    s21_decimal value_20 = {{4294967295, 4294967295, 4294967295, 0x00000000}};  //  79 228 162 514 264 337 593 543 950 335
    s21_decimal value_21 = {{0, 0, 0, 0x80FF0000}};                             // -INF
    s21_decimal value_22 = {{0, 0, 0, 0x00FF0000}};                             // +INF
    s21_decimal value_23 = {{1431655765, 1431655765, 1431655765, 0x80FF0000}};  //  NaN (диапазон от (-1)*10^(-28) до (-1)*10^(-28), но !=0)
    // 0 - FALSE (первое значаение больше или равно второму). 1 -  TRUE (первое значение меньше).
    ck_assert_int_eq(s21_is_less(value_01, value_01), 0);  // 0: -79 228 162 514 264 337 593 543 950 335 == -79 228 162 514 264 337 593 543 950 335
    ck_assert_int_eq(s21_is_less(value_01, value_20), 1);  // 1: -79 228 162 514 264 337 593 543 950 335 < 79 228 162 514 264 337 593 543 950 335   тест настроен правильно, не дописана функция s21_is_great либо s21_is_equal
    ck_assert_int_eq(s21_is_less(value_20, value_01), 0);  // 0:  79 228 162 514 264 337 593 543 950 335 > -79 228 162 514 264 337 593 543 950 335    
    ck_assert_int_eq(s21_is_less(value_10, value_11), 0);  // 0: -0 == +0
    ck_assert_int_eq(s21_is_less(value_10, value_10), 0);  // 0: -0 == -0
    ck_assert_int_eq(s21_is_less(value_11, value_11), 0);  // 0: +0 == +0
    ck_assert_int_eq(s21_is_less(value_11, value_12), 1);  // 1: 0 < 1   тест настроен правильно, не дописана функция s21_is_great либо s21_is_equal
    ck_assert_int_eq(s21_is_less(value_11, value_09), 0);  // 0: 0 > -1   тест настроен правильно, не дописана функция s21_is_great либо s21_is_equal
    ck_assert_int_eq(s21_is_less(value_11, value_22), 1);  // 1: 0 < +INF   тест настроен правильно, не дописана функция s21_is_great либо s21_is_equal
    ck_assert_int_eq(s21_is_less(value_11, value_21), 0);  // 0: 0 > -INF
    ck_assert_int_eq(s21_is_less(value_11, value_23), 0);  // 0: 0 !< NaN
    ck_assert_int_eq(s21_is_less(value_12, value_11), 0);  // 0: 1 > 0
    ck_assert_int_eq(s21_is_less(value_12, value_12), 0);  // 0: 1 == 1
    ck_assert_int_eq(s21_is_less(value_12, value_09), 0);  // 0: 1 > -1
    ck_assert_int_eq(s21_is_less(value_12, value_22), 1);  // 1: 1 < +INF   тест настроен правильно, не дописана функция s21_is_great либо s21_is_equal
    ck_assert_int_eq(s21_is_less(value_12, value_21), 0);  // 0: 1 > -INF
    ck_assert_int_eq(s21_is_less(value_12, value_23), 0);  // 0: 1 != NaN
    ck_assert_int_eq(s21_is_less(value_09, value_11), 1);  // 1: -1 < 0   тест настроен правильно, не дописана функция s21_is_great либо s21_is_equal
    ck_assert_int_eq(s21_is_less(value_09, value_12), 1);  // 1: -1 < 1   тест настроен правильно, не дописана функция s21_is_great либо s21_is_equal
    ck_assert_int_eq(s21_is_less(value_09, value_09), 0);  // 0: -1 == -1
    ck_assert_int_eq(s21_is_less(value_09, value_22), 1);  // 1: -1 < +INF   тест настроен правильно, не дописана функция s21_is_great либо s21_is_equal
    ck_assert_int_eq(s21_is_less(value_09, value_21), 0);  // 0: -1 > -INF   тест настроен правильно, не дописана функция s21_is_great либо s21_is_equal
    ck_assert_int_eq(s21_is_less(value_09, value_23), 0);  // 0: -1 != NaN
    ck_assert_int_eq(s21_is_less(value_22, value_11), 0);  // 0: +INF > 0
    ck_assert_int_eq(s21_is_less(value_22, value_12), 0);  // 0: +INF > 1
    ck_assert_int_eq(s21_is_less(value_22, value_09), 0);  // 0: +INF > -1
    ck_assert_int_eq(s21_is_less(value_22, value_22), 0);  // 0: +INF == +INF
    ck_assert_int_eq(s21_is_less(value_22, value_21), 0);  // 0: +INF > -INF
    ck_assert_int_eq(s21_is_less(value_22, value_23), 0);  // 0: +INF !< NaN
    ck_assert_int_eq(s21_is_less(value_21, value_11), 1);  // 1: -INF < 0   тест настроен правильно, не дописана функция s21_is_great либо s21_is_equal
    ck_assert_int_eq(s21_is_less(value_21, value_12), 1);  // 1: -INF < 1   тест настроен правильно, не дописана функция s21_is_great либо s21_is_equal
    ck_assert_int_eq(s21_is_less(value_21, value_09), 1);  // 1: -INF < -1    тест настроен правильно, не дописана функция s21_is_great либо s21_is_equal
    ck_assert_int_eq(s21_is_less(value_21, value_22), 1);  // 1: -INF < +INF   тест настроен правильно, не дописана функция s21_is_great либо s21_is_equal
    ck_assert_int_eq(s21_is_less(value_21, value_21), 0);  // 0: -INF == -INF
    ck_assert_int_eq(s21_is_less(value_21, value_23), 0);  // 0: -INF !< NaN 
    ck_assert_int_eq(s21_is_less(value_23, value_11), 0);  // 0: NaN !< 0 
    ck_assert_int_eq(s21_is_less(value_23, value_12), 0);  // 0: NaN !< 1 
    ck_assert_int_eq(s21_is_less(value_23, value_09), 0);  // 0: NaN !< -1
    ck_assert_int_eq(s21_is_less(value_23, value_22), 0);  // 0: NaN !< +INF
    ck_assert_int_eq(s21_is_less(value_23, value_21), 0);  // 0: NaN !< -INF
    ck_assert_int_eq(s21_is_less(value_23, value_23), 0);  // 0: NaN !< NaN



#test S21_IS_NOT_EQUEL
    // !!!!! Тест готовый, написан правильно !!!!!
    //         != |  0.000000  1.000000 -1.000000       inf      -inf      -nan
    // -------------------------------------------------------------------------
    //   0.000000 |     FALSE      TRUE      TRUE      TRUE      TRUE      TRUE
    //   1.000000 |      TRUE     FALSE      TRUE      TRUE      TRUE      TRUE
    //  -1.000000 |      TRUE      TRUE     FALSE      TRUE      TRUE      TRUE
    //        inf |      TRUE      TRUE      TRUE     FALSE      TRUE      TRUE
    //       -inf |      TRUE      TRUE      TRUE      TRUE     FALSE      TRUE
    //       -nan |      TRUE      TRUE      TRUE      TRUE      TRUE      TRUE
    s21_decimal value_01 = {{4294967295, 4294967295, 4294967295, 0x80000000}};  // -79 228 162 514 264 337 593 543 950 335
    s21_decimal value_09 = {{1, 0, 0, 0x80000000}};                             // -1
    s21_decimal value_10 = {{0, 0, 0, 0x80000000}};                             // -0
    s21_decimal value_11 = {{0, 0, 0, 0x00000000}};                             //  0
    s21_decimal value_12 = {{1, 0, 0, 0x00000000}};                             //  1
    s21_decimal value_20 = {{4294967295, 4294967295, 4294967295, 0x00000000}};  //  79 228 162 514 264 337 593 543 950 335
    s21_decimal value_21 = {{0, 0, 0, 0x80FF0000}};                             // -INF
    s21_decimal value_22 = {{0, 0, 0, 0x00FF0000}};                             // +INF
    s21_decimal value_23 = {{1431655765, 1431655765, 1431655765, 0x80FF0000}};  //  NaN (диапазон от (-1)*10^(-28) до (-1)*10^(-28), но !=0)
    s21_decimal value_24 = {{254, 0, 0, 0x00010000}};                           //  25,4
    s21_decimal value_25 = {{10, 0, 0, 0x00000000}};                            //  10
    s21_decimal value_26 = {{2147483647, 2147483647, 2147483647, 0x001B0000}};  //  9, 903 520 314 283 042 199 192 993 791
    s21_decimal value_27 = {{108903, 0, 0, 0x00010000}};                        //  108 90,3
    s21_decimal value_28 = {{254, 0, 0, 0x00010000}};                           //  25,4
    s21_decimal value_29 = {{10, 0, 0, 0x80000000}};                            //  -10
    s21_decimal value_30 = {{2147483647, 2147483647, 2147483647, 0x001B0000}};  //  -9, 903 520 314 283 042 199 192 993 791
    s21_decimal value_31 = {{108903, 0, 0, 0x00010000}};                        //  108 90,3
    s21_decimal value_32 = {{254, 0, 0, 0x80010000}};                           //  -25,4
    s21_decimal value_33 = {{10, 0, 0, 0x80000000}};                            //  -10
    s21_decimal value_34 = {{2147483647, 2147483647, 2147483647, 0x801B0000}};  //  -9, 903 520 314 283 042 199 192 993 791
    s21_decimal value_35 = {{108903, 0, 0, 0x80010000}};                        //  -108 90,3
    s21_decimal value_36 = {{3456, 0, 0, 0x00020000}};                          //  34,56
    s21_decimal value_37 = {{345600, 0, 0, 0x00040000}};                        //  34,5600
    // 0 - FALSE (первое значаение равно второму). 1 -  TRUE (первое значение не равно второму).
    ck_assert_int_eq(s21_is_not_equal(value_01, value_01), 0);  // 0: -79 228 162 514 264 337 593 543 950 335 == -79 228 162 514 264 337 593 543 950 335
    ck_assert_int_eq(s21_is_not_equal(value_01, value_20), 1);  // 1: -79 228 162 514 264 337 593 543 950 335 < 79 228 162 514 264 337 593 543 950 335
    ck_assert_int_eq(s21_is_not_equal(value_20, value_01), 1);  // 1:  79 228 162 514 264 337 593 543 950 335 > -79 228 162 514 264 337 593 543 950 335
    ck_assert_int_eq(s21_is_not_equal(value_10, value_11), 0);  // 0: -0 == +0
    ck_assert_int_eq(s21_is_not_equal(value_10, value_10), 0);  // 0: -0 == -0
    ck_assert_int_eq(s21_is_not_equal(value_11, value_11), 0);  // 0: +0 == +0
    ck_assert_int_eq(s21_is_not_equal(value_11, value_12), 1);  // 1: 0 < 1
    ck_assert_int_eq(s21_is_not_equal(value_11, value_09), 1);  // 1: 0 > -1
    ck_assert_int_eq(s21_is_not_equal(value_11, value_22), 1);  // 1: 0 < +INF   тест настроен правильно, не дописана функция s21_is_great либо s21_is_equal
    ck_assert_int_eq(s21_is_not_equal(value_11, value_21), 1);  // 1: 0 > -INF   тест настроен правильно, не дописана функция s21_is_great либо s21_is_equal
    ck_assert_int_eq(s21_is_not_equal(value_11, value_23), 1);  // 1: 0 !< NaN   тест настроен правильно, не дописана функция s21_is_great либо s21_is_equal
    ck_assert_int_eq(s21_is_not_equal(value_12, value_11), 1);  // 1: 1 > 0
    ck_assert_int_eq(s21_is_not_equal(value_12, value_12), 0);  // 0: 1 == 1
    ck_assert_int_eq(s21_is_not_equal(value_12, value_09), 1);  // 1: 1 > -1
    ck_assert_int_eq(s21_is_not_equal(value_12, value_22), 1);  // 1: 1 < +INF
    ck_assert_int_eq(s21_is_not_equal(value_12, value_21), 1);  // 1: 1 > -INF   тест настроен правильно, не дописана функция s21_is_great либо s21_is_equal
    ck_assert_int_eq(s21_is_not_equal(value_12, value_23), 1);  // 1: 1 != NaN
    ck_assert_int_eq(s21_is_not_equal(value_09, value_11), 1);  // 1: -1 < 0
    ck_assert_int_eq(s21_is_not_equal(value_09, value_12), 1);  // 1: -1 < 1
    ck_assert_int_eq(s21_is_not_equal(value_09, value_09), 0);  // 0: -1 == -1
    ck_assert_int_eq(s21_is_not_equal(value_09, value_22), 1);  // 1: -1 < +INF
    ck_assert_int_eq(s21_is_not_equal(value_09, value_21), 1);  // 1: -1 > -INF   тест настроен правильно, не дописана функция s21_is_great либо s21_is_equal
    ck_assert_int_eq(s21_is_not_equal(value_09, value_23), 1);  // 1: -1 != NaN
    ck_assert_int_eq(s21_is_not_equal(value_22, value_11), 1);  // 1: +INF > 0   тест настроен правильно, не дописана функция s21_is_great либо s21_is_equal
    ck_assert_int_eq(s21_is_not_equal(value_22, value_12), 1);  // 1: +INF > 1
    ck_assert_int_eq(s21_is_not_equal(value_22, value_09), 1);  // 1: +INF > -1
    ck_assert_int_eq(s21_is_not_equal(value_22, value_22), 0);  // 0: +INF == +INF
    ck_assert_int_eq(s21_is_not_equal(value_22, value_21), 1);  // 1: +INF > -INF   тест настроен правильно, не дописана функция s21_is_great либо s21_is_equal
    ck_assert_int_eq(s21_is_not_equal(value_22, value_23), 1);  // 1: +INF !< NaN   тест настроен правильно, не дописана функция s21_is_great либо s21_is_equal
    ck_assert_int_eq(s21_is_not_equal(value_21, value_11), 1);  // 1: -INF < 0   тест настроен правильно, не дописана функция s21_is_great либо s21_is_equal
    ck_assert_int_eq(s21_is_not_equal(value_21, value_12), 1);  // 1: -INF < 1   тест настроен правильно, не дописана функция s21_is_great либо s21_is_equal
    ck_assert_int_eq(s21_is_not_equal(value_21, value_09), 1);  // 1: -INF < -1   тест настроен правильно, не дописана функция s21_is_great либо s21_is_equal
    ck_assert_int_eq(s21_is_not_equal(value_21, value_22), 1);  // 1: -INF < +INF   тест настроен правильно, не дописана функция s21_is_great либо s21_is_equal
    ck_assert_int_eq(s21_is_not_equal(value_21, value_21), 0);  // 0: -INF == -INF
    ck_assert_int_eq(s21_is_not_equal(value_21, value_23), 1);  // 1: -INF !< NaN   тест настроен правильно, не дописана функция s21_is_great либо s21_is_equal
    ck_assert_int_eq(s21_is_not_equal(value_23, value_11), 1);  // 1: NaN !< 0 
    ck_assert_int_eq(s21_is_not_equal(value_23, value_12), 1);  // 1: NaN !< 1
    ck_assert_int_eq(s21_is_not_equal(value_23, value_09), 1);  // 1: NaN !< -1
    ck_assert_int_eq(s21_is_not_equal(value_23, value_22), 1);  // 1: NaN !< +INF
    ck_assert_int_eq(s21_is_not_equal(value_23, value_21), 1);  // 1: NaN !< -INF
    ck_assert_int_eq(s21_is_not_equal(value_23, value_23), 1);  // 1: NaN !< NaN
    ck_assert_int_eq(s21_is_not_equal(value_24, value_25), 1);  // 1: 25,4 > 10
    ck_assert_int_eq(s21_is_not_equal(value_25, value_24), 1);  // 1: 10 < 25,4
    ck_assert_int_eq(s21_is_not_equal(value_26, value_27), 1);  // 1: 9, 903 520 314 283 042 199 192 993 791 < 108 90,3
    ck_assert_int_eq(s21_is_not_equal(value_27, value_26), 1);  // 1: 108 90,3 > 9, 903 520 314 283 042 199 192 993 791
    ck_assert_int_eq(s21_is_not_equal(value_28, value_29), 1);  // 1: 25,4 > -10
    ck_assert_int_eq(s21_is_not_equal(value_29, value_28), 1);  // 1: -10 < 25,4
    ck_assert_int_eq(s21_is_not_equal(value_30, value_31), 1);  // 1: -9, 903 520 314 283 042 199 192 993 791 < 108 90,3
    ck_assert_int_eq(s21_is_not_equal(value_31, value_30), 1);  // 1: 108 90,3 > -9, 903 520 314 283 042 199 192 993 791
    ck_assert_int_eq(s21_is_not_equal(value_32, value_33), 1);  // 1: -25,4 < -10
    ck_assert_int_eq(s21_is_not_equal(value_33, value_32), 1);  // 1: -10 > -25,4
    ck_assert_int_eq(s21_is_not_equal(value_34, value_35), 1);  // 1: -9, 903 520 314 283 042 199 192 993 791 > -108 90,3
    ck_assert_int_eq(s21_is_not_equal(value_35, value_34), 1);  // 1: -108 90,3 < -9, 903 520 314 283 042 199 192 993 791
    ck_assert_int_eq(s21_is_not_equal(value_36, value_37), 0);  // 0: 34,56 == 34,5600



#test S21_MOD
    s21_decimal result = {{0}};                                                 //  0
    //          % |  0.000000  1.000000 -1.000000       inf      -inf      -nan
    // -------------------------------------------------------------------------
    //   0.000000 |      -nan  0.000000  0.000000  0.000000  0.000000      -nan
    //   1.000000 |      -nan  0.000000  0.000000  1.000000  1.000000      -nan
    //  -1.000000 |      -nan -0.000000 -0.000000 -1.000000 -1.000000      -nan
    //        inf |      -nan      -nan      -nan      -nan      -nan      -nan
    //       -inf |      -nan      -nan      -nan      -nan      -nan      -nan
    //       -nan |      -nan      -nan      -nan      -nan      -nan      -nan
    s21_decimal value_11 = {{0, 0, 0, 0x00000000}};                             //  0
    s21_decimal value_12 = {{543, 0, 0, 0x0000000}};                            //  543
    s21_decimal value_13 = {{879, 0, 0, 0x80000000}};                           // -879
    s21_decimal value_14 = {{0, 0, 0, 0x00FF0000}};                             //  INF
    s21_decimal value_15 = {{0, 0, 0, 0x80FF0000}};                             // -INF
    s21_decimal value_16 = {{9, 32, 876, 0x80FF0000}};                          // -NAN
    s21_decimal value_21 = {{0, 0, 0, 0x00000000}};                             //  0
    s21_decimal value_22 = {{234, 0, 0, 0x0000000}};                            //  543
    s21_decimal value_23 = {{121, 0, 0, 0x80000000}};                           // -879
    s21_decimal value_24 = {{0, 0, 0, 0x00FF0000}};                             //  INF
    s21_decimal value_25 = {{0, 0, 0, 0x80FF0000}};                             // -INF
    s21_decimal value_26 = {{659, 42, 876, 0x80FF0000}};                        // -NAN
    s21_decimal value_12n = {{543, 0, 0, 0x80000000}};                          // -54
    s21_decimal value_27 = {{0, 0, 0, 0x80000000}};                             // -0
    decimal_reset(&result);
    ck_assert_int_eq(s21_mod(value_11, value_21, &result), 3);
    ck_assert_int_eq(num_is_nan(result), 1);
    decimal_reset(&result);
    ck_assert_int_eq(s21_mod(value_11, value_26, &result), 3);
    ck_assert_int_eq(num_is_nan(result), 1);
    decimal_reset(&result);
    ck_assert_int_eq(s21_mod(value_12, value_21, &result), 3);
    ck_assert_int_eq(num_is_nan(result), 1);
    decimal_reset(&result);
    ck_assert_int_eq(s21_mod(value_12, value_26, &result), 3);
    ck_assert_int_eq(num_is_nan(result), 1);
    decimal_reset(&result);
    ck_assert_int_eq(s21_mod(value_13, value_21, &result), 3);
    ck_assert_int_eq(num_is_nan(result), 1);
    decimal_reset(&result);
    ck_assert_int_eq(s21_mod(value_13, value_26, &result), 3);
    ck_assert_int_eq(num_is_nan(result), 1);
    decimal_reset(&result);
    ck_assert_int_eq(s21_mod(value_14, value_21, &result), 3);
    ck_assert_int_eq(num_is_nan(result), 1);
    decimal_reset(&result);
    ck_assert_int_eq(s21_mod(value_14, value_22, &result), 3);
    ck_assert_int_eq(num_is_nan(result), 1);
    decimal_reset(&result);
    ck_assert_int_eq(s21_mod(value_14, value_23, &result), 3);
    ck_assert_int_eq(num_is_nan(result), 1);
    decimal_reset(&result);
    ck_assert_int_eq(s21_mod(value_14, value_24, &result), 3);
    ck_assert_int_eq(num_is_nan(result), 1);
    decimal_reset(&result);
    ck_assert_int_eq(s21_mod(value_14, value_25, &result), 3);
    ck_assert_int_eq(num_is_nan(result), 1);
    decimal_reset(&result);
    ck_assert_int_eq(s21_mod(value_14, value_26, &result), 3);
    ck_assert_int_eq(num_is_nan(result), 1);
    decimal_reset(&result);
    ck_assert_int_eq(s21_mod(value_15, value_21, &result), 3);
    ck_assert_int_eq(num_is_nan(result), 1);
    decimal_reset(&result);
    ck_assert_int_eq(s21_mod(value_15, value_22, &result), 3);
    ck_assert_int_eq(num_is_nan(result), 1);
    decimal_reset(&result);
    ck_assert_int_eq(s21_mod(value_15, value_23, &result), 3);
    ck_assert_int_eq(num_is_nan(result), 1);
    decimal_reset(&result);
    ck_assert_int_eq(s21_mod(value_15, value_24, &result), 3);
    ck_assert_int_eq(num_is_nan(result), 1);
    decimal_reset(&result);
    ck_assert_int_eq(s21_mod(value_15, value_25, &result), 3);
    ck_assert_int_eq(num_is_nan(result), 1);
    decimal_reset(&result);
    ck_assert_int_eq(s21_mod(value_15, value_26, &result), 3);
    ck_assert_int_eq(num_is_nan(result), 1);
    decimal_reset(&result);
    ck_assert_int_eq(s21_mod(value_16, value_21, &result), 3);
    ck_assert_int_eq(num_is_nan(result), 1);
    decimal_reset(&result);
    ck_assert_int_eq(s21_mod(value_16, value_22, &result), 3);
    ck_assert_int_eq(num_is_nan(result), 1);
    decimal_reset(&result);
    ck_assert_int_eq(s21_mod(value_16, value_23, &result), 3);
    ck_assert_int_eq(num_is_nan(result), 1);
    decimal_reset(&result);
    ck_assert_int_eq(s21_mod(value_16, value_24, &result), 3);
    ck_assert_int_eq(num_is_nan(result), 1);
    decimal_reset(&result);
    ck_assert_int_eq(s21_mod(value_16, value_25, &result), 3);
    ck_assert_int_eq(num_is_nan(result), 1);
    decimal_reset(&result);
    ck_assert_int_eq(s21_mod(value_16, value_26, &result), 3);
    ck_assert_int_eq(num_is_nan(result), 1);
    decimal_reset(&result);
    ck_assert_int_eq(s21_mod(value_11, value_12, &result), 0);   //  0 % 543 = 0
    ck_assert_int_eq(num_is_zero(result), 1);
    decimal_reset(&result);
    ck_assert_int_eq(s21_mod(value_11, value_12n, &result), 0);  //  0 % -543 = 0
    ck_assert_int_eq(num_is_zero(result), 1);
    decimal_reset(&result);
    ck_assert_int_eq(s21_mod(value_11, value_14, &result), 0);   //  0 % INF = 0
    ck_assert_int_eq(num_is_zero(result), 1);
    decimal_reset(&result);
    ck_assert_int_eq(s21_mod(value_27, value_14, &result), 0);   // -0 % INF = 0
    ck_assert_int_eq(num_is_zero(result), 1);
    decimal_reset(&result);
    ck_assert_int_eq(s21_mod(value_11, value_15, &result), 0);   //  0 % -INF = 0
    ck_assert_int_eq(num_is_zero(result), 1);
    decimal_reset(&result);
    ck_assert_int_eq(s21_mod(value_27, value_15, &result), 0);   // -0 % -INF = 0
    ck_assert_int_eq(num_is_zero(result), 1);
    decimal_reset(&result);
    s21_decimal value_30 = {{620, 0, 0, 0x00020000}};                           //  6,20
    s21_decimal value_31 = {{62, 0, 0, 0x00010000}};                            //  6,2
    s21_decimal correct_answer_01 = {{0, 0, 0, 0x00000000}};                    //  0
    decimal_reset(&result);
    ck_assert_int_eq(s21_mod(value_30, value_31, &result), 0);
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_01.bits[i]);
    }
    s21_decimal value_32 = {{620, 0, 0, 0x00020000}};                           // -6,20
    s21_decimal value_33 = {{62, 0, 0, 0x00010000}};                            //  6,2
    s21_decimal correct_answer_02 = {{0, 0, 0, 0x00000000}};                    //  0
    decimal_reset(&result);
    ck_assert_int_eq(s21_mod(value_32, value_33, &result), 0);
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_02.bits[i]);
    }
    s21_decimal value_34 = {{0, 0, 0, 0x00000000}};                             //  0
    s21_decimal value_35 = {{6, 0, 0, 0x00000000}};                             //  6
    s21_decimal correct_answer_03 = {{0, 0, 0, 0x00000000}};                    //  0
    decimal_reset(&result);
    ck_assert_int_eq(s21_mod(value_34, value_35, &result), 0);
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_03.bits[i]);
    }
    s21_decimal value_36 = {{0, 0, 0, 0x00000000}};                             //  0
    s21_decimal value_37 = {{6, 0, 0, 0x80000000}};                             // -6
    s21_decimal correct_answer_04 = {{0, 0, 0, 0x00000000}};                    //  0
    decimal_reset(&result);
    ck_assert_int_eq(s21_mod(value_36, value_37, &result), 0);
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_04.bits[i]);
    }
    s21_decimal value_38 = {{0, 0, 0, 0x80000000}};                             // -0
    s21_decimal value_39 = {{6, 0, 0, 0x00000000}};                             //  6
    s21_decimal correct_answer_05 = {{0, 0, 0, 0x80000000}};                    //  0
    decimal_reset(&result);
    ck_assert_int_eq(s21_mod(value_38, value_39, &result), 0);
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_05.bits[i]);
    }
    s21_decimal value_40 = {{0, 0, 0, 0x80000000}};                             // -0
    s21_decimal value_41 = {{6, 0, 0, 0x80000000}};                             // -6
    s21_decimal correct_answer_06 = {{0, 0, 0, 0x80000000}};                    //  0
    decimal_reset(&result);
    ck_assert_int_eq(s21_mod(value_40, value_41, &result), 0);
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_06.bits[i]);
    }
    s21_decimal value_42 = {{62, 0, 0, 0x00000000}};                            //  62
    s21_decimal value_43 = {{80, 0, 0, 0x00000000}};                            //  80
    s21_decimal correct_answer_07 = {{62, 0, 0, 0x00000000}};                   //  62
    decimal_reset(&result);
    ck_assert_int_eq(s21_mod(value_42, value_43, &result), 0);
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_07.bits[i]);
    }
    s21_decimal value_44 = {{62, 0, 0, 0x80000000}};                            // -62
    s21_decimal value_45 = {{80, 0, 0, 0x00000000}};                            //  80
    s21_decimal correct_answer_08 = {{62, 0, 0, 0x80000000}};                   // -62
    decimal_reset(&result);
    ck_assert_int_eq(s21_mod(value_44, value_45, &result), 0);
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_08.bits[i]);
    }
    s21_decimal value_46 = {{62, 0, 0, 0x00000000}};                            //  62
    s21_decimal value_47 = {{0, 0, 0, 0x00FF0000}};                             //  INF
    s21_decimal correct_answer_09 = {{62, 0, 0, 0x00000000}};                   //  62
    decimal_reset(&result);
    ck_assert_int_eq(s21_mod(value_46, value_47, &result), 0);
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_09.bits[i]);
    }
    s21_decimal value_48 = {{62, 0, 0, 0x80000000}};                            // -62
    s21_decimal value_49 = {{0, 0, 0, 0x00FF0000}};                             //  INF
    s21_decimal correct_answer_10 = {{62, 0, 0, 0x80000000}};                   // -62
    decimal_reset(&result);
    ck_assert_int_eq(s21_mod(value_48, value_49, &result), 0);
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_10.bits[i]);
    }
    s21_decimal value_50 = {{62, 0, 0, 0x00000000}};                            //  62
    s21_decimal value_51 = {{0, 0, 0, 0x80FF0000}};                             // -INF
    s21_decimal correct_answer_11 = {{62, 0, 0, 0x00000000}};                   //  62
    decimal_reset(&result);
    ck_assert_int_eq(s21_mod(value_50, value_51, &result), 0);
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_11.bits[i]);
    }
    s21_decimal value_52 = {{62, 0, 0, 0x80000000}};                            // -62
    s21_decimal value_53 = {{0, 0, 0, 0x80FF0000}};                             // -INF
    s21_decimal correct_answer_12 = {{62, 0, 0, 0x80000000}};                   // -62
    decimal_reset(&result);
    ck_assert_int_eq(s21_mod(value_52, value_53, &result), 0);
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_12.bits[i]);
    }
    s21_decimal value_54 = {{62, 0, 0, 0x00000000}};                            //  62
    s21_decimal value_55 = {{60, 0, 0, 0x00000000}};                            //  60
    s21_decimal correct_answer_13 = {{2, 0, 0, 0x00000000}};                    //  2
    decimal_reset(&result);
    ck_assert_int_eq(s21_mod(value_54, value_55, &result), 0);
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_13.bits[i]);
    }
    s21_decimal value_56 = {{62, 0, 0, 0x80000000}};                            // -62
    s21_decimal value_57 = {{60, 0, 0, 0x00000000}};                            //  60
    s21_decimal correct_answer_14 = {{2, 0, 0, 0x80000000}};                    // -2
    decimal_reset(&result);
    ck_assert_int_eq(s21_mod(value_56, value_57, &result), 0);
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_14.bits[i]);
    }
    s21_decimal value_58 = {{62, 0, 0, 0x00000000}};                            //  62
    s21_decimal value_59 = {{60, 0, 0, 0x80000000}};                            //  60
    s21_decimal correct_answer_15 = {{2, 0, 0, 0x00000000}};                    //  2
    decimal_reset(&result);
    ck_assert_int_eq(s21_mod(value_58, value_59, &result), 0);
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_15.bits[i]);
    }
    s21_decimal value_60 = {{62, 0, 0, 0x80000000}};                            // -62
    s21_decimal value_61 = {{60, 0, 0, 0x80000000}};                            //  60
    s21_decimal correct_answer_16 = {{2, 0, 0, 0x80000000}};                    // -2
    decimal_reset(&result);
    ck_assert_int_eq(s21_mod(value_60, value_61, &result), 0);
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_16.bits[i]);
    }
    s21_decimal value_62 = {{62, 0, 0, 0x00010000}};                            //  6,2
    s21_decimal value_63 = {{6, 0, 0, 0x00000000}};                             //  6
    s21_decimal correct_answer_17 = {{2, 0, 0, 0x00010000}};                    //  0,2
    decimal_reset(&result);
    ck_assert_int_eq(s21_mod(value_62, value_63, &result), 0);
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_17.bits[i]);
    }
    s21_decimal value_64 = {{62, 0, 0, 0x80010000}};                            // -6,2
    s21_decimal value_65 = {{6, 0, 0, 0x00000000}};                             //  6
    s21_decimal correct_answer_18 = {{2, 0, 0, 0x80010000}};                    // -0,2
    decimal_reset(&result);
    ck_assert_int_eq(s21_mod(value_64, value_65, &result), 0);
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_18.bits[i]);
    }
    s21_decimal value_66 = {{62, 0, 0, 0x00010000}};                            //  6,2
    s21_decimal value_67 = {{124, 0, 0, 0x00020000}};                           //  1,24
    s21_decimal correct_answer_19 = {{0, 0, 0, 0x00000000}};                    //  5
    decimal_reset(&result);
    ck_assert_int_eq(s21_mod(value_66, value_67, &result), 0);
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_19.bits[i]);
    }
    s21_decimal value_68 = {{62, 0, 0, 0x80010000}};                            // -6,2
    s21_decimal value_69 = {{124, 0, 0, 0x00020000}};                           //  1,24
    s21_decimal correct_answer_20 = {{0, 0, 0, 0x00000000}};                    // -5
    decimal_reset(&result);
    ck_assert_int_eq(s21_mod(value_68, value_69, &result), 0);
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_20.bits[i]);
    }

#test S21_MOD_ADDITION_1

  s21_decimal src1, src2, res_mod;
  int a = 3;
  int b = 2;
  int res_origin = a % b;
  int res = 0;
  s21_from_int_to_decimal(a, &src1);
  s21_from_int_to_decimal(b, &src2);
  s21_mod(src1, src2, &res_mod);
  s21_from_decimal_to_int(res_mod, &res);
  ck_assert_int_eq(res_origin, res);

  a = -98765;
  b = 1234;
  res_origin = a % b;
  res = 0;
  s21_from_int_to_decimal(a, &src1);
  s21_from_int_to_decimal(b, &src2);
  s21_mod(src1, src2, &res_mod);
  s21_from_decimal_to_int(res_mod, &res);
  ck_assert_int_eq(res_origin, res);


  a = 30198;
  b = 20210;
  res_origin = a % b;
  res = 0;
  s21_from_int_to_decimal(a, &src1);
  s21_from_int_to_decimal(b, &src2);
  s21_mod(src1, src2, &res_mod);
  s21_from_decimal_to_int(res_mod, &res);
  ck_assert_int_eq(res_origin, res);

  a = -98765;
  b = -1234;
  res_origin = a % b;
  res = 0;
  s21_from_int_to_decimal(a, &src1);
  s21_from_int_to_decimal(b, &src2);
  s21_mod(src1, src2, &res_mod);
  s21_from_decimal_to_int(res_mod, &res);
  ck_assert_int_eq(res_origin, res);

  a = 98765;
  b = 127234;
  res_origin = a % b;
  res = 0;
  s21_from_int_to_decimal(a, &src1);
  s21_from_int_to_decimal(b, &src2);
  s21_mod(src1, src2, &res_mod);
  s21_from_decimal_to_int(res_mod, &res);
  ck_assert_int_eq(res_origin, res);

  a = 342576;
  b = 1542134;
  res_origin = a % b;
  res = 0;
  s21_from_int_to_decimal(a, &src1);
  s21_from_int_to_decimal(b, &src2);
  s21_mod(src1, src2, &res_mod);
  s21_from_decimal_to_int(res_mod, &res);
  ck_assert_int_eq(res_origin, res);

  a = 12;
  b = 0;
  s21_from_int_to_decimal(a, &src1);
  s21_from_int_to_decimal(b, &src2);
  int check = s21_mod(src1, src2, &res_mod);
  ck_assert_int_eq(check, 3);

  a = 12;
  float c = 0.0000;
  s21_from_int_to_decimal(a, &src1);
  s21_from_float_to_decimal(c, &src2);
  check = s21_mod(src1, src2, &res_mod);
  ck_assert_int_eq(check, 3);

#test S21_MOD_ADDITION_1_01
    s21_decimal src1, src2, res_mod;
    s21_decimal origin = {{0}};
    int value_type_result = 0;
    int value_type_origin = 0;
    // src1 = 0;
    // src2 = 8976545415646545.5746845454;
    // origin_result = 0
    src1.bits[0] = 0b00000000000000000000000000000000;
    src1.bits[1] = 0b00000000000000000000000000000000;
    src1.bits[2] = 0b00000000000000000000000000000000;
    src1.bits[3] = 0b00000000000000000000000000000000;
    src2.bits[0] = 0b11011101111000010000101100001110;
    src2.bits[1] = 0b00000101010000010110101000000010;
    src2.bits[2] = 0b00000000010010100100000010010011;
    src2.bits[3] = 0b00000000000010100000000000000000;
    value_type_result = s21_mod(src1, src2, &res_mod);
    value_type_origin = 0;
    origin.bits[0] = 0b00000000000000000000000000000000;
    origin.bits[1] = 0b00000000000000000000000000000000;
    origin.bits[2] = 0b00000000000000000000000000000000;
    origin.bits[3] = 0b00000000000000000000000000000000;
    ck_assert_int_eq(origin.bits[3], res_mod.bits[3]);
    ck_assert_int_eq(origin.bits[2], res_mod.bits[2]);
    ck_assert_int_eq(origin.bits[1], res_mod.bits[1]);
    ck_assert_int_eq(origin.bits[0], res_mod.bits[0]);
    ck_assert_int_eq(value_type_result, value_type_origin);

#test S21_MOD_ADDITION_1_02
    s21_decimal src1, src2, res_mod;
    s21_decimal origin = {{0}};
    int value_type_result = 0;
    int value_type_origin = 0;
    // src1 = 178324.4353453454;
    // src2 = 19.87;
    // origin_result = 11.0553453454
    src1.bits[0] = 0b11101110001111000011110110001110;
    src1.bits[1] = 0b00000000000001100101010111011001;
    src1.bits[2] = 0b00000000000000000000000000000000;
    src1.bits[3] = 0b00000000000010100000000000000000;
    src2.bits[0] = 0b00000000000000000000011111000011;
    src2.bits[1] = 0b00000000000000000000000000000000;
    src2.bits[2] = 0b00000000000000000000000000000000;
    src2.bits[3] = 0b00000000000000100000000000000000;
    value_type_result = s21_mod(src1, src2, &res_mod);
    value_type_origin = 0;
    origin.bits[0] = 0b10111101011111111101001110001110;
    origin.bits[1] = 0b00000000000000000000000000011001;
    origin.bits[2] = 0b00000000000000000000000000000000;
    origin.bits[3] = 0b00000000000010100000000000000000;
    ck_assert_int_eq(origin.bits[3], res_mod.bits[3]);
    ck_assert_int_eq(origin.bits[2], res_mod.bits[2]);
    ck_assert_int_eq(origin.bits[1], res_mod.bits[1]);
    ck_assert_int_eq(origin.bits[0], res_mod.bits[0]);
    ck_assert_int_eq(value_type_result, value_type_origin);

// #test S21_MOD_ADDITION_1_03
//     s21_decimal src1, src2, res_mod;
//     s21_decimal origin = {{0}};
//     int value_type_result = 0;
//     int value_type_origin = 0; 
//     // src1 = -1783244353453454.71; {260574143, 41519393, 0, 0x80020000}
//     // src2 = 4e-28;                {4, 0, 0, 0x001C0000}
//     // origin_result = 0 (-0.0e-28) {0, 0, 0, 0x801C0000}         = 0.0000000000000000 => 0
//     src1.bits[0] = 0b00001111100010000000101110111111;
//     src1.bits[1] = 0b00000010011110011000100100100001;
//     src1.bits[2] = 0b00000000000000000000000000000000;
//     src1.bits[3] = 0b10000000000000100000000000000000;
//     src2.bits[0] = 0b00000000000000000000000000000100;
//     src2.bits[1] = 0b00000000000000000000000000000000;
//     src2.bits[2] = 0b00000000000000000000000000000000;
//     src2.bits[3] = 0b00000000000111000000000000000000;
//     value_type_result = s21_mod(src1, src2, &res_mod);
//     value_type_origin = 0;
//     origin.bits[0] = 0b00000000000000000000000000000000;
//     origin.bits[1] = 0b00000000000000000000000000000000;
//     origin.bits[2] = 0b00000000000000000000000000000000;
//     origin.bits[3] = 0b10000000000111000000000000000000;
//     ck_assert_int_eq(origin.bits[3], res_mod.bits[3]);
//     ck_assert_int_eq(origin.bits[2], res_mod.bits[2]);
//     ck_assert_int_eq(origin.bits[1], res_mod.bits[1]);
//     ck_assert_int_eq(origin.bits[0], res_mod.bits[0]);
//     ck_assert_int_eq(value_type_result, value_type_origin);

// #test S21_MOD_ADDITION_1_04
//     s21_decimal src1, src2, res_mod;
//     s21_decimal origin = {{0}};
//     int value_type_result = 0;
//     int value_type_origin = 0;
//     // src1 = 70000000000000000000000000000;
//     // src2 = 0.001;
//     // origin_result = 0 (0.0e-3)
//     src1.bits[0] = 0b01110000000000000000000000000000;
//     src1.bits[1] = 0b10110011000000110001000010100111;
//     src1.bits[2] = 0b11100010001011101010010010010011;
//     src1.bits[3] = 0b00000000000000000000000000000000;
//     src2.bits[0] = 0b00000000000000000000000000000001;
//     src2.bits[1] = 0b00000000000000000000000000000000;
//     src2.bits[2] = 0b00000000000000000000000000000000;
//     src2.bits[3] = 0b00000000000000110000000000000000;
//     value_type_result = s21_mod(src1, src2, &res_mod);
//     value_type_origin = 0;
//     origin.bits[0] = 0b00000000000000000000000000000000;
//     origin.bits[1] = 0b00000000000000000000000000000000;
//     origin.bits[2] = 0b00000000000000000000000000000000;
//     origin.bits[3] = 0b00000000000000110000000000000000;
//     ck_assert_int_eq(origin.bits[3], res_mod.bits[3]);
//     ck_assert_int_eq(origin.bits[2], res_mod.bits[2]);
//     ck_assert_int_eq(origin.bits[1], res_mod.bits[1]);
//     ck_assert_int_eq(origin.bits[0], res_mod.bits[0]);
//     ck_assert_int_eq(value_type_result, value_type_origin);

#test S21_MOD_ADDITION_1_05
    s21_decimal src1, src2, res_mod;
    s21_decimal origin = {{0}};
    int value_type_result = 0;
    int value_type_origin = 0;
    // src1 = 79228162514264337593543950335;
    // src2 = 79228162514.26433759354;
    // origin_result = 3950335.00000000000
    src1.bits[0] = 0b11111111111111111111111111111111;
    src1.bits[1] = 0b11111111111111111111111111111111;
    src1.bits[2] = 0b11111111111111111111111111111111;
    src1.bits[3] = 0b00000000000000000000000000000000;
    src2.bits[0] = 0b11110100100001010111100001111010;
    src2.bits[1] = 0b01111111001010011010101111001010;
    src2.bits[2] = 0b00000000000000000000000110101101;
    src2.bits[3] = 0b00000000000010110000000000000000;
    value_type_result = s21_mod(src1, src2, &res_mod);
    value_type_origin = 0;
    origin.bits[0] = 0b00010001111000010001100000000000;
    origin.bits[1] = 0b00000101011110110111000011100000;
    origin.bits[2] = 0b00000000000000000000000000000000;
    origin.bits[3] = 0b00000000000010110000000000000000;
    ck_assert_int_eq(origin.bits[3], res_mod.bits[3]);
    ck_assert_int_eq(origin.bits[2], res_mod.bits[2]);
    ck_assert_int_eq(origin.bits[1], res_mod.bits[1]);
    ck_assert_int_eq(origin.bits[0], res_mod.bits[0]);
    ck_assert_int_eq(value_type_result, value_type_origin);

#test S21_MOD_ADDITION_1_06
    s21_decimal src1, src2, res_mod;
    s21_decimal origin = {{0}};
    int value_type_result = 0;
    int value_type_origin = 0;
    // src1 = 79228162514264337593543950335;
    // src2 = 7922816251426433759354395033.5;
    // origin_result = 0.0
    src1.bits[0] = 0b11111111111111111111111111111111;
    src1.bits[1] = 0b11111111111111111111111111111111;
    src1.bits[2] = 0b11111111111111111111111111111111;
    src1.bits[3] = 0b00000000000000000000000000000000;
    src2.bits[0] = 0b11111111111111111111111111111111;
    src2.bits[1] = 0b11111111111111111111111111111111;
    src2.bits[2] = 0b11111111111111111111111111111111;
    src2.bits[3] = 0b00000000000000010000000000000000;
    value_type_result = s21_mod(src1, src2, &res_mod);
    value_type_origin = 0;
    origin.bits[0] = 0b00000000000000000000000000000000;
    origin.bits[1] = 0b00000000000000000000000000000000;
    origin.bits[2] = 0b00000000000000000000000000000000;
    origin.bits[3] = 0b00000000000000000000000000000000;
    ck_assert_int_eq(origin.bits[3], res_mod.bits[3]);
    ck_assert_int_eq(origin.bits[2], res_mod.bits[2]);
    ck_assert_int_eq(origin.bits[1], res_mod.bits[1]);
    ck_assert_int_eq(origin.bits[0], res_mod.bits[0]);
    ck_assert_int_eq(value_type_result, value_type_origin);

#test S21_MOD_ADDITION_1_07
    s21_decimal src1, src2, res_mod;
    s21_decimal origin = {{0}};
    int value_type_result = 0;
    int value_type_origin = 0;
    // src1 = 79228162514264337593543950335;
    // src2 = 1;
    // origin_result = 0
    src1.bits[0] = 0b11111111111111111111111111111111;
    src1.bits[1] = 0b11111111111111111111111111111111;
    src1.bits[2] = 0b11111111111111111111111111111111;
    src1.bits[3] = 0b00000000000000000000000000000000;
    src2.bits[0] = 0b00000000000000000000000000000001;
    src2.bits[1] = 0b00000000000000000000000000000000;
    src2.bits[2] = 0b00000000000000000000000000000000;
    src2.bits[3] = 0b00000000000000000000000000000000;
    value_type_result = s21_mod(src1, src2, &res_mod);
    value_type_origin = 0;
    origin.bits[0] = 0b00000000000000000000000000000000;
    origin.bits[1] = 0b00000000000000000000000000000000;
    origin.bits[2] = 0b00000000000000000000000000000000;
    origin.bits[3] = 0b00000000000000000000000000000000;
    ck_assert_int_eq(origin.bits[3], res_mod.bits[3]);
    ck_assert_int_eq(origin.bits[2], res_mod.bits[2]);
    ck_assert_int_eq(origin.bits[1], res_mod.bits[1]);
    ck_assert_int_eq(origin.bits[0], res_mod.bits[0]);
    ck_assert_int_eq(value_type_result, value_type_origin);



#test S21_MUL
    //          * |  0.000000  1.000000 -1.000000       inf      -inf      -nan
    // -------------------------------------------------------------------------
    //   0.000000 |  0.000000  0.000000 -0.000000      -nan      -nan      -nan
    //   1.000000 |  0.000000  1.000000 -1.000000       inf      -inf      -nan
    //  -1.000000 | -0.000000 -1.000000  1.000000      -inf       inf      -nan
    //        inf |      -nan       inf      -inf       inf      -inf      -nan
    //       -inf |      -nan      -inf       inf      -inf       inf      -nan
    //       -nan |      -nan      -nan      -nan      -nan      -nan      -nan
    s21_decimal result = {{0}};                                                 //  0
    s21_decimal value_01 = {{0, 0, 0, 0x00000000}};                             //  0
    s21_decimal value_02 = {{0, 0, 0, 0x00000000}};                             //  0
    s21_decimal correct_answer_01 = {{0, 0, 0, 0x00000000}};                    //  0
    decimal_reset(&result);
    ck_assert_int_eq(s21_mul(value_01, value_02, &result), 0);                //  0 * 0 = 0
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_01.bits[i]);
    }
    s21_decimal value_03 = {{0, 0, 0, 0x00000000}};                             //  0
    s21_decimal value_04 = {{0, 0, 0, 0x80000000}};                             // -0
    s21_decimal correct_answer_02 = {{0, 0, 0, 0x00000000}};                    //  0
    decimal_reset(&result);
    ck_assert_int_eq(s21_mul(value_03, value_04, &result), 0);                //  0 * (-0) = 0
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_02.bits[i]);
    }
    s21_decimal value_05 = {{0, 0, 0, 0x00000000}};                             //  0
    s21_decimal value_06 = {{25, 0, 0, 0x00000000}};                            //  25
    s21_decimal correct_answer_03 = {{0, 0, 0, 0x00000000}};                    //  0
    decimal_reset(&result);
    ck_assert_int_eq(s21_mul(value_05, value_06, &result), 0);                //  0 * 25 = 0
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_03.bits[i]);
    }
    s21_decimal value_07 = {{0, 0, 0, 0x00000000}};                             //  0
    s21_decimal value_08 = {{25, 0, 0, 0x80000000}};                            // -25
    s21_decimal correct_answer_04 = {{0, 0, 0, 0x00000000}};                    //  0
    decimal_reset(&result);
    ck_assert_int_eq(s21_mul(value_07, value_08, &result), 0);                //  0 * (-25) = 0
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_04.bits[i]);
    }
    s21_decimal value_09 = {{0, 0, 0, 0x00000000}};                                      //  0
    s21_decimal value_10 = {{0, 0, 0, 0x00FF0000}};                                      //  INF
    s21_decimal correct_answer_05 = {{1431655765, 1431655765, 1431655765, 0x80FF0000}};  // -NAN
    decimal_reset(&result);
    ck_assert_int_eq(s21_mul(value_09, value_10, &result), 3);                         //  0 * INF = -NAN
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_05.bits[i]);
    }
    s21_decimal value_11 = {{0, 0, 0, 0x00000000}};                                      //  0
    s21_decimal value_12 = {{0, 0, 0, 0x80FF0000}};                                      // -INF
    s21_decimal correct_answer_06 = {{1431655765, 1431655765, 1431655765, 0x80FF0000}};  // -NAN
    decimal_reset(&result);
    ck_assert_int_eq(s21_mul(value_11, value_12, &result), 3);                         //  0 * (-INF) = -NAN
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_06.bits[i]);
    }
    s21_decimal value_13 = {{0, 0, 0, 0x00000000}};                                      //  0
    s21_decimal value_14 = {{1, 345, 4, 0x80FF0000}};                                    // -NAN
    decimal_reset(&result);
    ck_assert_int_eq(s21_mul(value_13, value_14, &result), 3);                         //  0 * (-NAN) = -NAN
    ck_assert_int_eq(num_is_nan(result), 1);
    s21_decimal value_15 = {{2147483647, 0, 0, 0}};                                      //  2 147 483 647
    s21_decimal value_16 = {{0, 0, 0, 0x00000000}};                                      //  0
    s21_decimal correct_answer_08 = {{0}};                                               //  0 
    decimal_reset(&result);
    ck_assert_int_eq(s21_mul(value_15, value_16, &result), 0);                         //  2 147 483 647 * 0 = 0
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_08.bits[i]);
    }
    s21_decimal value_17 = {{2147483647, 0, 0, 0}};                                      //  2 147 483 647
    s21_decimal value_18 = {{25, 0, 0, 0x00000000}};                                     //  25
    s21_decimal correct_answer_09 = {{2147483623, 12, 0, 0x00000000}};                   //  53 687 091 175 
    decimal_reset(&result);
    ck_assert_int_eq(s21_mul(value_17, value_18, &result), 0);                         //  2 147 483 647 * 0 = 53 687 091 175
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_09.bits[i]);
    }
    s21_decimal value_19 = {{2147483647, 0, 0, 0}};                                      //  2 147 483 647
    s21_decimal value_20 = {{25, 0, 0, 0x80000000}};                                     // -25
    s21_decimal correct_answer_10 = {{2147483623, 12, 0, 0x80000000}};                   // -53 687 091 175 
    decimal_reset(&result);
    ck_assert_int_eq(s21_mul(value_19, value_20, &result), 0);                         //  2 147 483 647 * (-25) = -53 687 091 175
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_10.bits[i]);
    }
    s21_decimal value_21 = {{2147483647, 0, 0, 0}};                                      //  2 147 483 647
    s21_decimal value_22 = {{0, 0, 0, 0x00FF0000}};                                      //  INF
    s21_decimal correct_answer_11 = {{0, 0, 0, 0x00FF0000}};                             //  INF
    decimal_reset(&result);
    ck_assert_int_eq(s21_mul(value_21, value_22, &result), 1);                         //  2 147 483 647 * INF = 53 687 091 175
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_11.bits[i]);
    }
    s21_decimal value_23 = {{2147483647, 0, 0, 0}};                                      //  2 147 483 647
    s21_decimal value_24 = {{0, 0, 0, 0x80FF0000}};                                      // -INF
    s21_decimal correct_answer_12 = {{0, 0, 0, 0x80FF0000}};                             // -INF
    decimal_reset(&result);
    ck_assert_int_eq(s21_mul(value_23, value_24, &result), 2);                         //  2 147 483 647 * (-INF) = -INF
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_12.bits[i]);
    }
    s21_decimal value_25 = {{2147483647, 0, 0, 0}};                                      //  2 147 483 647
    s21_decimal value_26 = {{12, 232, 0, 0x00FF0000}};                                   //  NAN
    decimal_reset(&result);
    ck_assert_int_eq(s21_mul(value_25, value_26, &result), 3);                         //  2 147 483 647 * NAN = -NAN
    ck_assert_int_eq(num_is_nan(result), 1);
    s21_decimal value_27 = {{2147483647, 0, 0, 0x80000000}};                             // -2 147 483 647
    s21_decimal value_28 = {{0, 0, 0, 0x00000000}};                                      //  0
    s21_decimal correct_answer_14 = {{0}};                                               //  0 
    decimal_reset(&result);
    ck_assert_int_eq(s21_mul(value_27, value_28, &result), 0);                         // -2 147 483 647 * 0 = 0
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_14.bits[i]);
    }
    s21_decimal value_29 = {{2147483647, 0, 0, 0x80000000}};                             // -2 147 483 647
    s21_decimal value_30 = {{25, 0, 0, 0x00000000}};                                     //  25
    s21_decimal correct_answer_15 = {{2147483623, 12, 0, 0x80000000}};                   // -53 687 091 175 
    decimal_reset(&result);
    ck_assert_int_eq(s21_mul(value_29, value_30, &result), 0);                         // -2 147 483 647 * 25 = -53 687 091 175
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_15.bits[i]);
    }
    s21_decimal value_31 = {{2147483647, 0, 0, 0x80000000}};                             // -2 147 483 647
    s21_decimal value_32 = {{25, 0, 0, 0x80000000}};                                     // -25
    s21_decimal correct_answer_16 = {{2147483623, 12, 0, 0x00000000}};                   //  53 687 091 175 
    decimal_reset(&result);
    ck_assert_int_eq(s21_mul(value_31, value_32, &result), 0);                         // -2 147 483 647 * (-25) = 53 687 091 175
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_16.bits[i]);
    }
    s21_decimal value_33 = {{2147483647, 0, 0, 0x80000000}};                             // -2 147 483 647
    s21_decimal value_34 = {{0, 0, 0, 0x00FF0000}};                                      //  INF
    s21_decimal correct_answer_17 = {{0, 0, 0, 0x80FF0000}};                             // -INF
    decimal_reset(&result);
    ck_assert_int_eq(s21_mul(value_33, value_34, &result), 2);                         // -2 147 483 647 * INF = -INF
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_17.bits[i]);
    }
    s21_decimal value_35 = {{2147483647, 0, 0, 0x80000000}};                             // -2 147 483 647
    s21_decimal value_36 = {{0, 0, 0, 0x80FF0000}};                                      // -INF
    s21_decimal correct_answer_18 = {{0, 0, 0, 0x00FF0000}};                             //  INF
    decimal_reset(&result);
    ck_assert_int_eq(s21_mul(value_35, value_36, &result), 1);                         // -2 147 483 647 * (-INF) =  INF
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_18.bits[i]);
    }
    s21_decimal value_37 = {{2147483647, 0, 0, 0x80000000}};                             // -2 147 483 647
    s21_decimal value_38 = {{12, 232, 0, 0x00FF0000}};                                   //  NAN
    decimal_reset(&result);
    ck_assert_int_eq(s21_mul(value_37, value_38, &result), 3);                         //  2 147 483 647 * NAN = -NAN
    ck_assert_int_eq(num_is_nan(result), 1);
    s21_decimal value_39 = {{0, 0, 0, 0x00FF0000}};                                      //  INF
    s21_decimal value_40 = {{0, 0, 0, 0x00000000}};                                      //  0
    decimal_reset(&result);
    ck_assert_int_eq(s21_mul(value_39, value_40, &result), 3);                         //  INF * 0 = -NAN
    ck_assert_int_eq(num_is_nan(result), 1);
    s21_decimal value_41 = {{0, 0, 0, 0x00FF0000}};                                      //  INF
    s21_decimal value_42 = {{25, 0, 0, 0x00000000}};                                     //  25
    s21_decimal correct_answer_21 = {{0, 0, 0, 0x00FF0000}};                             //  INF
    decimal_reset(&result);
    ck_assert_int_eq(s21_mul(value_41, value_42, &result), 1);                         //  INF * 25 = INF
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_21.bits[i]);
    }
    s21_decimal value_43 = {{0, 0, 0, 0x00FF0000}};                                      //  INF
    s21_decimal value_44 = {{25, 0, 0, 0x80000000}};                                     //  -25
    s21_decimal correct_answer_22 = {{0, 0, 0, 0x80FF0000}};                             // -INF
    decimal_reset(&result);
    ck_assert_int_eq(s21_mul(value_43, value_44, &result), 2);                         //  INF * (-25) = -INF
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_22.bits[i]);
    }
    s21_decimal value_45 = {{0, 0, 0, 0x00FF0000}};                                      //  INF
    s21_decimal value_46 = {{0, 0, 0, 0x00FF0000}};                                      //  INF
    s21_decimal correct_answer_23 = {{0, 0, 0, 0x00FF0000}};                             //  INF
    decimal_reset(&result);
    ck_assert_int_eq(s21_mul(value_45, value_46, &result), 1);                         //  INF * INF = INF
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_23.bits[i]);
    }
    s21_decimal value_47 = {{0, 0, 0, 0x00FF0000}};                                      //  INF
    s21_decimal value_48 = {{0, 0, 0, 0x80FF0000}};                                      // -INF
    s21_decimal correct_answer_24 = {{0, 0, 0, 0x80FF0000}};                             // -INF
    decimal_reset(&result);
    ck_assert_int_eq(s21_mul(value_47, value_48, &result), 2);                         //  INF * -INF = -INF
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_24.bits[i]);
    }
    s21_decimal value_49 = {{0, 0, 0, 0x00FF0000}};                                      //  INF
    s21_decimal value_50 = {{1, 0, 230, 0x80FF0000}};                                    // -NAN
    decimal_reset(&result);
    ck_assert_int_eq(s21_mul(value_49, value_50, &result), 3);                         //  INF * -NAN = -NAN
    ck_assert_int_eq(num_is_nan(result), 1);
    s21_decimal value_51 = {{0, 0, 0, 0x80FF0000}};                                      // -INF
    s21_decimal value_52 = {{0, 0, 0, 0x00000000}};                                      //  0
    decimal_reset(&result);
    ck_assert_int_eq(s21_mul(value_51, value_52, &result), 3);                         // -INF * 0 = -NAN
    ck_assert_int_eq(num_is_nan(result), 1);
    s21_decimal value_53 = {{0, 0, 0, 0x80FF0000}};                                      // -INF
    s21_decimal value_54 = {{25, 0, 0, 0x00000000}};                                     //  25
    s21_decimal correct_answer_27 = {{0, 0, 0, 0x80FF0000}};                             // -INF
    decimal_reset(&result);
    ck_assert_int_eq(s21_mul(value_53, value_54, &result), 2);                         // -INF * 25 = -INF
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_27.bits[i]);
    }
    s21_decimal value_55 = {{0, 0, 0, 0x80FF0000}};                                      // -INF
    s21_decimal value_56 = {{25, 0, 0, 0x80000000}};                                     // -25
    s21_decimal correct_answer_28 = {{0, 0, 0, 0x00FF0000}};                             //  INF
    decimal_reset(&result);
    ck_assert_int_eq(s21_mul(value_55, value_56, &result), 1);                         // -INF * (-25) = INF
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_28.bits[i]);
    }
    s21_decimal value_57 = {{0, 0, 0, 0x80FF0000}};                                      // -INF
    s21_decimal value_58 = {{0, 0, 0, 0x00FF0000}};                                      //  INF
    s21_decimal correct_answer_29 = {{0, 0, 0, 0x80FF0000}};                             // -INF
    decimal_reset(&result);
    ck_assert_int_eq(s21_mul(value_57, value_58, &result), 2);                         // -INF * INF = -INF
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_29.bits[i]);
    }
    s21_decimal value_59 = {{0, 0, 0, 0x80FF0000}};                                      // -INF
    s21_decimal value_60 = {{0, 0, 0, 0x80FF0000}};                                      // -INF
    s21_decimal correct_answer_30 = {{0, 0, 0, 0x00FF0000}};                             //  INF
    decimal_reset(&result);
    ck_assert_int_eq(s21_mul(value_59, value_60, &result), 1);                         // -INF * -INF = INF
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_30.bits[i]);
    }
    s21_decimal value_61 = {{0, 0, 0, 0x80FF0000}};                                      // -INF
    s21_decimal value_62 = {{1, 0, 230, 0x80FF0000}};                                    // -NAN
    decimal_reset(&result);
    ck_assert_int_eq(s21_mul(value_61, value_62, &result), 3);                         // -INF * -NAN = -NAN
    ck_assert_int_eq(num_is_nan(result), 1);
    s21_decimal value_63 = {{1, 0, 230, 0x80FF0000}};                                    // -NAN
    s21_decimal value_64 = {{1, 0, 230, 0x80FF0000}};                                    // -NAN
    decimal_reset(&result);
    ck_assert_int_eq(s21_mul(value_63, value_64, &result), 3);                         // -INF * -NAN = -NAN
    ck_assert_int_eq(num_is_nan(result), 1);



#test S21_NEGATE
    s21_decimal result = {{0}};  
    s21_decimal value_01 = {{4294967295, 4294967295, 4294967295, 0x80000000}};           // -79 228 162 514 264 337 593 543 950 335
    s21_decimal value_02 = {{4294967295, 4294967295, 4294967295, 0x00000000}};           //  79 228 162 514 264 337 593 543 950 335
    s21_decimal correct_answer_01 = {{4294967295, 4294967295, 4294967295, 0x00000000}};  //  79 228 162 514 264 337 593 543 950 335
    s21_decimal correct_answer_02 = {{4294967295, 4294967295, 4294967295, 0x80000000}};  // -79 228 162 514 264 337 593 543 950 335
    decimal_reset(&result);
    ck_assert_int_eq(s21_negate(value_01, &result), 0);
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_01.bits[i]);
    }
    decimal_reset(&result);
    ck_assert_int_eq(s21_negate(value_02, &result), 0);
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_02.bits[i]);
    }
    


#test S21_ROUND
    s21_decimal result = {{0}};  
    s21_decimal value_01 = {{6348235, 0, 0, 0x00050000}};                                     //  63,48235
    s21_decimal value_02 = {{6348235, 0, 0, 0x80050000}};                                     // -63,48235
    s21_decimal value_03 = {{6348235, 0, 0, 0x00000000}};                                     //  6348235
    s21_decimal value_04 = {{6348235, 0, 0, 0x80000000}};                                     // -6348235
    s21_decimal value_05 = {{5, 0, 0, 0x80010000}};                                           // -0,5
    s21_decimal value_06 = {{49, 0, 0, 0x80020000}};                                          // -0,49
    s21_decimal value_07 = {{5, 0, 0, 0x00010000}};                                           //  0,5
    s21_decimal value_08 = {{44, 0, 0, 0x00020000}};                                          //  0,44
    s21_decimal value_09 = {{0, 0, 0, 0x80000000}};                                           // -0
    s21_decimal correct_answer_01 = {{64, 0, 0, 0x00000000}};                                 //  64
    s21_decimal correct_answer_02 = {{64, 0, 0, 0x80000000}};                                 // -64
    s21_decimal correct_answer_03 = {{6348235, 0, 0, 0x00000000}};                            //  6348235
    s21_decimal correct_answer_04 = {{6348235, 0, 0, 0x80000000}};                            // -6348235
    s21_decimal correct_answer_05 = {{1, 0, 0, 0x80000000}};                                  // -1
    s21_decimal correct_answer_06 = {{1, 0, 0, 0x80000000}};                                  // -1
    s21_decimal correct_answer_07 = {{1, 0, 0, 0x00000000}};                                  //  1
    s21_decimal correct_answer_08 = {{0, 0, 0, 0x00000000}};                                  //  0
    s21_decimal correct_answer_09 = {{0, 0, 0, 0x00000000}};                                  //  0
    decimal_reset(&result);
    ck_assert_int_eq(s21_round(value_01, &result), 0);
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_01.bits[i]);
    }
    decimal_reset(&result);
    ck_assert_int_eq(s21_round(value_02, &result), 0);
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_02.bits[i]);
    }
    decimal_reset(&result);
    ck_assert_int_eq(s21_round(value_03, &result), 0);
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_03.bits[i]);
    }
    decimal_reset(&result);
    ck_assert_int_eq(s21_round(value_04, &result), 0);
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_04.bits[i]);
    }
    decimal_reset(&result);
    ck_assert_int_eq(s21_round(value_05, &result), 0);
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_05.bits[i]);
    }
    decimal_reset(&result);
    ck_assert_int_eq(s21_round(value_06, &result), 0);
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_06.bits[i]);
    }
    decimal_reset(&result);
    ck_assert_int_eq(s21_round(value_07, &result), 0);
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_07.bits[i]);
    }
    decimal_reset(&result);
    ck_assert_int_eq(s21_round(value_08, &result), 0);
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_08.bits[i]);
    }
    decimal_reset(&result);
    ck_assert_int_eq(s21_round(value_09, &result), 0);
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_09.bits[i]);
    }

#test s21_ROUND_ADDITION_1
    s21_decimal num_1, num_2, num_3, num_4, dest_1, dest_2, dest_3, dest_4,
    res_1, res_2, res_3, res_4;
    /*
    *num_1 = 1.9874565432111
    */
    num_1.bits[0] = 0b01101000011010011010001100101111;
    num_1.bits[1] = 0b00000000000000000001001000010011;
    num_1.bits[2] = 0b00000000000000000000000000000000;
    num_1.bits[3] = 0b00000000000011010000000000000000;
    /*
    *num_2 = -98.78798789312
    */
    num_2.bits[0] = 0b00010110010010101110101011000000;
    num_2.bits[1] = 0b00000000000000000000100011111100;
    num_2.bits[2] = 0b00000000000000000000000000000000;
    num_2.bits[3] = 0b10000000000010110000000000000000;
    /*
    *num_3 = -545454512454545.35265454545645
    */
    num_3.bits[0] = 0b10000010111000100101101011101101;
    num_3.bits[1] = 0b11111001111010000010010110101101;
    num_3.bits[2] = 0b10110000001111101111000010010100;
    num_3.bits[3] = 0b10000000000011100000000000000000;
    /*
    *num_4 = 65658654.59
    */
    num_4.bits[0] = 0b10000111010110110010011111110011;
    num_4.bits[1] = 0b00000000000000000000000000000001;
    num_4.bits[2] = 0b00000000000000000000000000000000;
    num_4.bits[3] = 0b00000000000000100000000000000000;

    /*
    *dest_1 = 2
    */
    dest_1.bits[0] = 0b00000000000000000000000000000010;
    dest_1.bits[1] = 0b00000000000000000000000000000000;
    dest_1.bits[2] = 0b00000000000000000000000000000000;
    dest_1.bits[3] = 0b00000000000000000000000000000000;
    /*
    *dest_2 = -99
    */
    dest_2.bits[0] = 0b00000000000000000000000001100011;
    dest_2.bits[1] = 0b00000000000000000000000000000000;
    dest_2.bits[2] = 0b00000000000000000000000000000000;
    dest_2.bits[3] = 0b10000000000000000000000000000000;
    /*
    *dest_3 = -545454512454545
    */
    dest_3.bits[0] = 0b10000110011101001011101110010001;
    dest_3.bits[1] = 0b00000000000000011111000000010110;
    dest_3.bits[2] = 0b00000000000000000000000000000000;
    dest_3.bits[3] = 0b10000000000000000000000000000000;
    /*
    *dest_4 = 65658655
    */
    dest_4.bits[0] = 0b00000011111010011101111100011111;
    dest_4.bits[1] = 0b00000000000000000000000000000000;
    dest_4.bits[2] = 0b00000000000000000000000000000000;
    dest_4.bits[3] = 0b00000000000000000000000000000000;

    int value_1 = s21_round(num_1, &res_1);
    int value_2 = s21_round(num_2, &res_2);
    int value_3 = s21_round(num_3, &res_3);
    int value_4 = s21_round(num_4, &res_4);
    ck_assert_int_eq(dest_1.bits[0], res_1.bits[0]);
    ck_assert_int_eq(dest_1.bits[1], res_1.bits[1]);
    ck_assert_int_eq(dest_1.bits[2], res_1.bits[2]);
    ck_assert_int_eq(dest_1.bits[3], res_1.bits[3]);
    ck_assert_int_eq(value_1, VALUE_OK);
    ck_assert_int_eq(dest_2.bits[0], res_2.bits[0]);
    ck_assert_int_eq(dest_2.bits[1], res_2.bits[1]);
    ck_assert_int_eq(dest_2.bits[2], res_2.bits[2]);
    ck_assert_int_eq(dest_2.bits[3], res_2.bits[3]);
    ck_assert_int_eq(value_2, VALUE_OK);
    ck_assert_int_eq(dest_3.bits[0], res_3.bits[0]);
    ck_assert_int_eq(dest_3.bits[1], res_3.bits[1]);
    ck_assert_int_eq(dest_3.bits[2], res_3.bits[2]);
    ck_assert_int_eq(dest_3.bits[3], res_3.bits[3]);
    ck_assert_int_eq(value_3, VALUE_OK);
    ck_assert_int_eq(dest_4.bits[0], res_4.bits[0]);
    ck_assert_int_eq(dest_4.bits[1], res_4.bits[1]);
    ck_assert_int_eq(dest_4.bits[2], res_4.bits[2]);
    ck_assert_int_eq(dest_4.bits[3], res_4.bits[3]);
    ck_assert_int_eq(value_4, VALUE_OK);




#test S21_SUB
    //          - |  0.000000  1.000000 -1.000000       inf      -inf      -nan
    // -------------------------------------------------------------------------
    //   0.000000 |  0.000000 -1.000000  1.000000      -inf       inf      -nan
    //   1.000000 |  1.000000  0.000000  2.000000      -inf       inf      -nan
    //  -1.000000 | -1.000000 -2.000000  0.000000      -inf       inf      -nan
    //        inf |       inf       inf       inf      -nan       inf      -nan
    //       -inf |      -inf      -inf      -inf      -inf      -nan      -nan
    //       -nan |      -nan      -nan      -nan      -nan      -nan      -nan
    s21_decimal result = {{0}};
    s21_decimal value_11 = {{0, 0, 0, 0x00000000}};                             //  0
    s21_decimal value_12 = {{1, 0, 0, 0x00000000}};                             //  1
    s21_decimal value_13 = {{2147483647, 0, 0, 0}};                             //  2 147 483 647
    s21_decimal value_21 = {{0, 0, 0, 0x80FF0000}};                             // -INF
    s21_decimal value_22 = {{0, 0, 0, 0x00FF0000}};                             // +INF
    s21_decimal value_23 = {{1431655765, 1431655765, 1431655765, 0x80FF0000}};  //  NaN (диапазон от (-1)*10^(-28) до (-1)*10^(-28), но !=0)
    decimal_reset(&result);
    s21_sub(value_11, value_22, &result);                                     // 1 - +INF = -INF
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], value_21.bits[i]);
    }
    decimal_reset(&result);
    s21_sub(value_11, value_21, &result);                                     // 1 - -INF = INF
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], value_22.bits[i]);
    }
    decimal_reset(&result);
    s21_sub(value_11, value_23, &result);                                     // 1 - NaN = -NaN
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], value_23.bits[i]);
    }
    decimal_reset(&result);
    s21_sub(value_22, value_11, &result);                                     // +INF - 1 = +INF
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], value_22.bits[i]);
    }
    decimal_reset(&result);
    s21_sub(value_22, value_22, &result);                                     // +INF - +INF = -NaN
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], value_23.bits[i]);
    }
    decimal_reset(&result);
    s21_sub(value_22, value_21, &result);                                     // +INF - -INF = +INF
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], value_22.bits[i]);
    }
    decimal_reset(&result);
    s21_sub(value_22, value_23, &result);                                     // +INF - NaN = -NaN
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], value_23.bits[i]);
    }
    decimal_reset(&result);
    s21_sub(value_21, value_11, &result);                                     // -INF - 1 = -INF
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], value_21.bits[i]);
    }
    decimal_reset(&result);
    s21_sub(value_21, value_22, &result);                                     // -INF - +INF = -INF
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], value_21.bits[i]);
    }
    decimal_reset(&result);
    s21_sub(value_21, value_21, &result);                                     // -INF - -INF = -NaN
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], value_23.bits[i]);
    }
    decimal_reset(&result);
    s21_sub(value_21, value_23, &result);                                     // -INF - NaN = -NaN
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], value_23.bits[i]);
    }
    decimal_reset(&result);
    s21_sub(value_23, value_11, &result);                                     // NaN - 1 = -NaN
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], value_23.bits[i]);
    }
    decimal_reset(&result);
    s21_sub(value_23, value_22, &result);                                     // NaN - +INF = -NaN
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], value_23.bits[i]);
    }
    decimal_reset(&result);
    s21_sub(value_23, value_21, &result);                                     // NaN - -INF = -NaN
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], value_23.bits[i]);
    }
    decimal_reset(&result);
    s21_sub(value_23, value_23, &result);                                     // NaN - -NaN = -NaN
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], value_23.bits[i]);
    }
    s21_decimal correct_answer_01 = {{0, 0, 0, 0x00000000}};                    // -0 + 0 = 0
    decimal_reset(&result);
    s21_sub(value_11, value_11, &result);                                     // 0 - 0 = 0
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_01.bits[i]);
    }
    s21_decimal correct_answer_02 = {{1, 0, 0, 0x00000000}};                    //  1 - 0 = 1
    decimal_reset(&result);
    s21_sub(value_12, value_11, &result);                                     // 1 - 0 = 1
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_02.bits[i]);
    }
    s21_decimal correct_answer_03 = {{1, 0, 0, 0x80000000}};                    //  0 - 1 = -1
    decimal_reset(&result);
    s21_sub(value_11, value_12, &result);                                     // 0 - 1 = -1
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_03.bits[i]);
    }
    s21_decimal value_25 = {{200, 0, 0, 0x00020000}};                           //  2,00
    s21_decimal value_26 = {{10, 0, 0, 0x00010000}};                            //  1,0
    s21_decimal correct_answer_04 = {{100, 0, 0, 0x00020000}};                  //  2,00 - 1,0 = 1,00
    decimal_reset(&result);
    s21_sub(value_25, value_26, &result);                                     // 2,00 - 1,0 = 1,00
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_04.bits[i]);
    }
    s21_decimal value_27 = {{5000, 0, 0, 0x00000000}};                          //  5000
    s21_decimal value_28 = {{3500, 0, 0, 0x00000000}};                          //  3500
    s21_decimal correct_answer_05 = {{1500, 0, 0, 0x00000000}};                 //  1500
    decimal_reset(&result);
    s21_sub(value_27, value_28, &result);                                     // 5000 - 3500 = 1500
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_05.bits[i]);
    }
    s21_decimal value_27_2 = {{5000, 0, 0, 0x00000000}};                          //  5000
    s21_decimal value_28_2 = {{3500, 0, 0, 0x00000000}};                          //  3500
    s21_decimal correct_answer_06 = {{1500, 0, 0, 0x80000000}};                 // -1500
    decimal_reset(&result);
    s21_sub(value_28_2, value_27_2, &result);                                     // 3500 - 5000 = -1500
    for (int i = 0; i < 4; i++) { 
       ck_assert_int_eq(result.bits[i], correct_answer_06.bits[i]);
    }
    s21_decimal value_29 = {{2000, 0, 0, 0x80000000}};                          // -2000
    s21_decimal value_30 = {{3000, 0, 0, 0x80000000}};                          // -3000
    s21_decimal correct_answer_07 = {{1000, 0, 0, 0x00000000}};                 //  1000
    decimal_reset(&result);
    s21_sub(value_29, value_30, &result);                                     // -2000 - -3000 = 1000
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_07.bits[i]);
    }
    s21_decimal correct_answer_08 = {{1000, 0, 0, 0x80000000}};                 // -1000
    decimal_reset(&result);
    s21_sub(value_30, value_29, &result);                                     // -3000 - -2000 = -1000
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_08.bits[i]);
    }
    s21_decimal value_31 = {{4294967295, 4294967295, 536870911, 0x001C0000}};   //  0.9 903 520 314 283 042 199 192 993 791
    s21_decimal value_32 = {{4294967295, 4294967295, 536870911, 0x801C0000}};   // -0.9 903 520 314 283 042 199 192 993 791
    s21_decimal value_33 = {{1000005, 0, 0, 0x00010000}};                       //  100 000,5
    s21_decimal value_34 = {{1000005, 0, 0, 0x80010000}};                       // -100 000,5
    s21_decimal correct_answer_09 = {{2595986950, 167776157, 542098428, 0x00170000}};  // 99 999.509 647 968 571 695 780 080 70 = 00100000 01001111 11000011 11111100  00001010 00000000 00001111 10011101  10011010 10111011 10011110 00000110
    decimal_reset(&result);
    s21_sub(value_33, value_31, &result);                                     // 100000,5 - 0,9 903 520 314 283 042 199 192 993 791 = 99 999.509 647 968 571 695 780 080 70
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_09.bits[i]);
    }
    s21_decimal correct_answer_10 = {{2076467706, 1964103279, 542109165, 0x80170000}};// -100 001.490 352 031 428 304 219 919 30
    decimal_reset(&result);
    s21_sub(value_32, value_33, &result);                                     // -0,9 903 520 314 283 042 199 192 993 791 - 100000,5 = -100 001.490 352 031 428 304 219 919 30
    ck_assert_int_eq(s21_sub(value_32, value_33, &result), 0);
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_10.bits[i]);
    }
    s21_decimal correct_answer_11 = {{2595986950, 167776157, 542098428, 0x00170000}};  // 99 999.509 647 968 571 695 780 080 70
    decimal_reset(&result);
    s21_sub(value_32, value_34, &result);                                      // -0,9 903 520 314 283 042 199 192 993 791 - -100 000,5 = 99 999.509 647 968 571 695 780 080 70
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_11.bits[i]);
    }
    s21_decimal value_35 = {{100, 0, 0, 0x00000000}};                            //  100
    s21_decimal value_36 = {{50, 0, 0, 0x80000000}};                             // -50
    s21_decimal correct_answer_12 = {{150, 0, 0, 0x00000000}};                   // 150
    decimal_reset(&result);
    s21_sub(value_35, value_36, &result);                                      //  100 - -50 = 150
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_12.bits[i]);
    }
    decimal_reset(&result);
    s21_sub(value_13, value_13, &result);                                      // 2 147 483 647 - 2 147 483 647 = 0
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], value_11.bits[i]);
    }
    s21_decimal value_37 = {{453457, 0, 0, 0x80000000}};                            // -453457
    s21_decimal value_38 = {{4294967295, 4294967295, 4294967295, 0x00000000}};      //  79 228 162 514 264 337 593 543 950 335
    s21_decimal correct_answer_13 = {{0, 0, 0, 0x80FF0000}};                        // -INF
    decimal_reset(&result);
    ck_assert_int_eq(s21_sub(value_37, value_38, &result), 2);                                         //  100 - -50 = 150
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_13.bits[i]);
    }    

#test S21_SUB_ADDITION_1
    s21_decimal a, b, c, d, e, f, res_1, res_2, res_3, res_4, res_5, res_6, res_7, res_8;
    s21_decimal res_a_b, res_b_a, res_d_c, res_c_d, res_b_e, res_e_d;
    /*
    *a = 38765
    */
    a.bits[0] = 0b00000000000000001001011101101101;
    a.bits[1] = 0b00000000000000000000000000000000;
    a.bits[2] = 0b00000000000000000000000000000000;
    a.bits[3] = 0b00000000000000000000000000000000;
    /*
    * b = 0
    */
    b.bits[0] = 0b00000000000000000000000000000000;
    b.bits[1] = 0b00000000000000000000000000000000;
    b.bits[2] = 0b00000000000000000000000000000000;
    b.bits[3] = 0b00000000000000000000000000000000;
    /*
    *c = -453457
    */
    c.bits[0] = 0b00000000000001101110101101010001;
    c.bits[1] = 0b00000000000000000000000000000000;
    c.bits[2] = 0b00000000000000000000000000000000;
    c.bits[3] = 0b10000000000000000000000000000000;
    /*
    * d = 546784961
    */
    d.bits[0] = 0b00100000100101110100011011000001;
    d.bits[1] = 0b00000000000000000000000000000000;
    d.bits[2] = 0b00000000000000000000000000000000;
    d.bits[3] = 0b00000000000000000000000000000000;
    /*
    *e = 984564567.3246
    */
    e.bits[0] = 0b01011110001101101000001100011110;
    e.bits[1] = 0b00000000000000000000100011110100;
    e.bits[2] = 0b00000000000000000000000000000000;
    e.bits[3] = 0b00000000000001000000000000000000;
    /*
    * f = 79228162514264337593543950335
    */
    f.bits[0] = 0b11111111111111111111111111111111;
    f.bits[1] = 0b11111111111111111111111111111111;
    f.bits[2] = 0b11111111111111111111111111111111;
    f.bits[3] = 0b00000000000000000000000000000000;
    /*
    * res_a_b = 38765 - 0 = 38765
    */
    res_a_b.bits[0] = 0b00000000000000001001011101101101;
    res_a_b.bits[1] = 0b00000000000000000000000000000000;
    res_a_b.bits[2] = 0b00000000000000000000000000000000;
    res_a_b.bits[3] = 0b00000000000000000000000000000000;
    /*
    * res_b_a = 0 - 38765 = -38765
    */
    res_b_a.bits[0] = 0b00000000000000001001011101101101;
    res_b_a.bits[1] = 0b00000000000000000000000000000000;
    res_b_a.bits[2] = 0b00000000000000000000000000000000;
    res_b_a.bits[3] = 0b10000000000000000000000000000000;
    /*
    *res_d_c = 546784961 - (-453457) = 547238418
    */
    res_d_c.bits[0] = 0b00100000100111100011001000010010;
    res_d_c.bits[1] = 0b00000000000000000000000000000000;
    res_d_c.bits[2] = 0b00000000000000000000000000000000;
    res_d_c.bits[3] = 0b00000000000000000000000000000000;
    /*
    *res_c_d = -453457 - 546784961 = -547238418
    */
    res_c_d.bits[0] = 0b00100000100111100011001000010010;
    res_c_d.bits[1] = 0b00000000000000000000000000000000;
    res_c_d.bits[2] = 0b00000000000000000000000000000000;
    res_c_d.bits[3] = 0b10000000000000000000000000000000;
    /*
    *res_b_e = 0 - 984564567.3246 = -984564567.3246
    */
    res_b_e.bits[0] = 0b01011110001101101000001100011110;
    res_b_e.bits[1] = 0b00000000000000000000100011110100;
    res_b_e.bits[2] = 0b00000000000000000000000000000000;
    res_b_e.bits[3] = 0b10000000000001000000000000000000;
    /*
    *res_e_d = 984564567.3246 - 546784961 = 437779606.3246
    */
    res_e_d.bits[0] = 0b01001000111110101011000000001110;
    res_e_d.bits[1] = 0b00000000000000000000001111111011;
    res_e_d.bits[2] = 0b00000000000000000000000000000000;
    res_e_d.bits[3] = 0b00000000000001000000000000000000;
    int value_1 = s21_sub(a, b, &res_1);
    int value_2 = s21_sub(b, a, &res_2);
    int value_3 = s21_sub(d, c, &res_3);
    int value_4 = s21_sub(c, d, &res_4);
    int value_5 = s21_sub(b, e, &res_5);
    int value_6 = s21_sub(e, d, &res_6);
    int value_7 = s21_sub(f, c, &res_7);
    int value_8 = s21_sub(c, f, &res_8);
    ck_assert_int_eq(res_1.bits[0], res_a_b.bits[0]);
    ck_assert_int_eq(res_1.bits[1], res_a_b.bits[1]);
    ck_assert_int_eq(res_1.bits[2], res_a_b.bits[2]);
    ck_assert_int_eq(res_1.bits[3], res_a_b.bits[3]);
    ck_assert_int_eq(value_1, VALUE_OK);
    ck_assert_int_eq(res_2.bits[0], res_b_a.bits[0]);
    ck_assert_int_eq(res_2.bits[1], res_b_a.bits[1]);
    ck_assert_int_eq(res_2.bits[2], res_b_a.bits[2]);
    ck_assert_int_eq(res_2.bits[3], res_b_a.bits[3]);
    ck_assert_int_eq(value_2, VALUE_OK);
    ck_assert_int_eq(res_3.bits[0], res_d_c.bits[0]);
    ck_assert_int_eq(res_3.bits[1], res_d_c.bits[1]);
    ck_assert_int_eq(res_3.bits[2], res_d_c.bits[2]);
    ck_assert_int_eq(res_3.bits[3], res_d_c.bits[3]);
    ck_assert_int_eq(value_3, VALUE_OK);
    ck_assert_int_eq(res_4.bits[0], res_c_d.bits[0]);
    ck_assert_int_eq(res_4.bits[1], res_c_d.bits[1]);
    ck_assert_int_eq(res_4.bits[2], res_c_d.bits[2]);
    ck_assert_int_eq(res_4.bits[3], res_c_d.bits[3]);
    ck_assert_int_eq(value_4, VALUE_OK);
    ck_assert_int_eq(res_5.bits[0], res_b_e.bits[0]);
    ck_assert_int_eq(res_5.bits[1], res_b_e.bits[1]);
    ck_assert_int_eq(res_5.bits[2], res_b_e.bits[2]);
    ck_assert_int_eq(res_5.bits[3], res_b_e.bits[3]);
    ck_assert_int_eq(value_5, VALUE_OK);
    ck_assert_int_eq(res_6.bits[0], res_e_d.bits[0]);
    ck_assert_int_eq(res_6.bits[1], res_e_d.bits[1]);
    ck_assert_int_eq(res_6.bits[2], res_e_d.bits[2]);
    ck_assert_int_eq(res_6.bits[3], res_e_d.bits[3]);
    ck_assert_int_eq(value_6, VALUE_OK);
    ck_assert_int_eq(value_7, VALUE_INF);
    ck_assert_int_eq(value_8, VALUE_MINUS_INF);
#test S21_SUB_ADDITION_2_01
    s21_decimal src1, src2, origin, result;
    int value_type_result, value_type_origin;
    // src1 = 5;
    // src2 = 3;
    src1.bits[0] = 0b00000000000000000000000000000101;
    src1.bits[1] = 0b00000000000000000000000000000000;
    src1.bits[2] = 0b00000000000000000000000000000000;
    src1.bits[3] = 0b00000000000000000000000000000000;
    src2.bits[0] = 0b00000000000000000000000000000011;
    src2.bits[1] = 0b00000000000000000000000000000000;
    src2.bits[2] = 0b00000000000000000000000000000000;
    src2.bits[3] = 0b00000000000000000000000000000000;
    value_type_result = s21_sub(src1, src2, &result);
    value_type_origin = 0;
    origin.bits[0] = 0b00000000000000000000000000000010;
    origin.bits[1] = 0b00000000000000000000000000000000;
    origin.bits[2] = 0b00000000000000000000000000000000;
    origin.bits[3] = 0b00000000000000000000000000000000;
    ck_assert_int_eq(origin.bits[3], result.bits[3]);
    ck_assert_int_eq(origin.bits[2], result.bits[2]);
    ck_assert_int_eq(origin.bits[1], result.bits[1]);
    ck_assert_int_eq(origin.bits[0], result.bits[0]);
    ck_assert_int_eq(value_type_result, value_type_origin);
#test S21_SUB_ADDITION_2_02
    s21_decimal src1, src2, origin, result;
    int value_type_result, value_type_origin;
    // src1 = 3;
    // src2 = 6;
    src1.bits[0] = 0b00000000000000000000000000000011;
    src1.bits[1] = 0b00000000000000000000000000000000;
    src1.bits[2] = 0b00000000000000000000000000000000;
    src1.bits[3] = 0b00000000000000000000000000000000;
    src2.bits[0] = 0b00000000000000000000000000000110;
    src2.bits[1] = 0b00000000000000000000000000000000;
    src2.bits[2] = 0b00000000000000000000000000000000;
    src2.bits[3] = 0b00000000000000000000000000000000;
    value_type_result = s21_sub(src1, src2, &result);
    value_type_origin = 0;
    origin.bits[0] = 0b00000000000000000000000000000011;
    origin.bits[1] = 0b00000000000000000000000000000000;
    origin.bits[2] = 0b00000000000000000000000000000000;
    origin.bits[3] = 0b10000000000000000000000000000000;
    ck_assert_int_eq(origin.bits[3], result.bits[3]);
    ck_assert_int_eq(origin.bits[2], result.bits[2]);
    ck_assert_int_eq(origin.bits[1], result.bits[1]);
    ck_assert_int_eq(origin.bits[0], result.bits[0]);
    ck_assert_int_eq(value_type_result, value_type_origin);
#test S21_SUB_ADDITION_2_03
    s21_decimal src1, src2, origin, result;
    int value_type_result, value_type_origin;
    // src1 = 0;
    // src2 = 8;
    src1.bits[0] = 0b00000000000000000000000000000000;
    src1.bits[1] = 0b00000000000000000000000000000000;
    src1.bits[2] = 0b00000000000000000000000000000000;
    src1.bits[3] = 0b00000000000000000000000000000000;
    src2.bits[0] = 0b00000000000000000000000000001000;
    src2.bits[1] = 0b00000000000000000000000000000000;
    src2.bits[2] = 0b00000000000000000000000000000000;
    src2.bits[3] = 0b00000000000000000000000000000000;
    value_type_result = s21_sub(src1, src2, &result);
    value_type_origin = 0;
    origin.bits[0] = 0b00000000000000000000000000001000;
    origin.bits[1] = 0b00000000000000000000000000000000;
    origin.bits[2] = 0b00000000000000000000000000000000;
    origin.bits[3] = 0b10000000000000000000000000000000;
    ck_assert_int_eq(origin.bits[3], result.bits[3]);
    ck_assert_int_eq(origin.bits[2], result.bits[2]);
    ck_assert_int_eq(origin.bits[1], result.bits[1]);
    ck_assert_int_eq(origin.bits[0], result.bits[0]);
    ck_assert_int_eq(value_type_result, value_type_origin);
#test S21_SUB_ADDITION_2_04
    s21_decimal src1, src2, origin, result;
    int value_type_result, value_type_origin;
    // src1 = 7;
    // src2 = 0;
    src1.bits[0] = 0b00000000000000000000000000000111;
    src1.bits[1] = 0b00000000000000000000000000000000;
    src1.bits[2] = 0b00000000000000000000000000000000;
    src1.bits[3] = 0b00000000000000000000000000000000;
    src2.bits[0] = 0b00000000000000000000000000000000;
    src2.bits[1] = 0b00000000000000000000000000000000;
    src2.bits[2] = 0b00000000000000000000000000000000;
    src2.bits[3] = 0b00000000000000000000000000000000;
    value_type_result = s21_sub(src1, src2, &result);
    value_type_origin = 0;
    origin.bits[0] = 0b00000000000000000000000000000111;
    origin.bits[1] = 0b00000000000000000000000000000000;
    origin.bits[2] = 0b00000000000000000000000000000000;
    origin.bits[3] = 0b00000000000000000000000000000000;
    ck_assert_int_eq(origin.bits[3], result.bits[3]);
    ck_assert_int_eq(origin.bits[2], result.bits[2]);
    ck_assert_int_eq(origin.bits[1], result.bits[1]);
    ck_assert_int_eq(origin.bits[0], result.bits[0]);
    ck_assert_int_eq(value_type_result, value_type_origin);
#test S21_SUB_ADDITION_2_05
    s21_decimal src1, src2, origin, result;
    int value_type_result, value_type_origin;
    // src1 = 0.0;
    // src2 = 5;
    src1.bits[0] = 0b00000000000000000000000000000000;
    src1.bits[1] = 0b00000000000000000000000000000000;
    src1.bits[2] = 0b00000000000000000000000000000000;
    src1.bits[3] = 0b10000000000000010000000000000000;
    src2.bits[0] = 0b00000000000000000000000000000101;
    src2.bits[1] = 0b00000000000000000000000000000000;
    src2.bits[2] = 0b00000000000000000000000000000000;
    src2.bits[3] = 0b00000000000000000000000000000000;
    value_type_result = s21_sub(src1, src2, &result);
    value_type_origin = 0;
    origin.bits[0] = 0b00000000000000000000000000000101;
    origin.bits[1] = 0b00000000000000000000000000000000;
    origin.bits[2] = 0b00000000000000000000000000000000;
    origin.bits[3] = 0b10000000000000000000000000000000;
    ck_assert_int_eq(origin.bits[3], result.bits[3]);
    ck_assert_int_eq(origin.bits[2], result.bits[2]);
    ck_assert_int_eq(origin.bits[1], result.bits[1]);
    ck_assert_int_eq(origin.bits[0], result.bits[0]);
    ck_assert_int_eq(value_type_result, value_type_origin);
#test S21_SUB_ADDITION_2_06
    s21_decimal src1, src2, origin, result;
    int value_type_result, value_type_origin;
    // src1 = 3;
    // src2 = 0;
    src1.bits[0] = 0b00000000000000000000000000000011;
    src1.bits[1] = 0b00000000000000000000000000000000;
    src1.bits[2] = 0b00000000000000000000000000000000;
    src1.bits[3] = 0b00000000000000000000000000000000;
    src2.bits[0] = 0b00000000000000000000000000000000;
    src2.bits[1] = 0b00000000000000000000000000000000;
    src2.bits[2] = 0b00000000000000000000000000000000;
    src2.bits[3] = 0b00000000000000000000000000000000;
    value_type_result = s21_sub(src1, src2, &result);
    value_type_origin = 0;
    origin.bits[0] = 0b00000000000000000000000000000011;
    origin.bits[1] = 0b00000000000000000000000000000000;
    origin.bits[2] = 0b00000000000000000000000000000000;
    origin.bits[3] = 0b00000000000000000000000000000000;
    ck_assert_int_eq(origin.bits[3], result.bits[3]);
    ck_assert_int_eq(origin.bits[2], result.bits[2]);
    ck_assert_int_eq(origin.bits[1], result.bits[1]);
    ck_assert_int_eq(origin.bits[0], result.bits[0]);
    ck_assert_int_eq(value_type_result, value_type_origin);
#test S21_SUB_ADDITION_2_07
    s21_decimal src1, src2, origin, result;
    int value_type_result, value_type_origin;
    // src1 = 787891;
    // src2 = 238471;
    src1.bits[0] = 0b00000000000011000000010110110011;
    src1.bits[1] = 0b00000000000000000000000000000000;
    src1.bits[2] = 0b00000000000000000000000000000000;
    src1.bits[3] = 0b00000000000000000000000000000000;
    src2.bits[0] = 0b00000000000000111010001110000111;
    src2.bits[1] = 0b00000000000000000000000000000000;
    src2.bits[2] = 0b00000000000000000000000000000000;
    src2.bits[3] = 0b00000000000000000000000000000000;
    value_type_result = s21_sub(src1, src2, &result);
    value_type_origin = 0;
    origin.bits[0] = 0b00000000000010000110001000101100;
    origin.bits[1] = 0b00000000000000000000000000000000;
    origin.bits[2] = 0b00000000000000000000000000000000;
    origin.bits[3] = 0b00000000000000000000000000000000;
    ck_assert_int_eq(origin.bits[3], result.bits[3]);
    ck_assert_int_eq(origin.bits[2], result.bits[2]);
    ck_assert_int_eq(origin.bits[1], result.bits[1]);
    ck_assert_int_eq(origin.bits[0], result.bits[0]);
    ck_assert_int_eq(value_type_result, value_type_origin);
#test S21_SUB_ADDITION_2_08
    s21_decimal src1, src2, origin, result;
    int value_type_result, value_type_origin;
    // src1 = 9;
    // src2 = 18571145;
    src1.bits[0] = 0b00000000000000000000000000001001;
    src1.bits[1] = 0b00000000000000000000000000000000;
    src1.bits[2] = 0b00000000000000000000000000000000;
    src1.bits[3] = 0b00000000000000000000000000000000;
    src2.bits[0] = 0b00000001000110110101111110001001;
    src2.bits[1] = 0b00000000000000000000000000000000;
    src2.bits[2] = 0b00000000000000000000000000000000;
    src2.bits[3] = 0b00000000000000000000000000000000;
    value_type_result = s21_sub(src1, src2, &result);
    value_type_origin = 0;
    origin.bits[0] = 0b00000001000110110101111110000000;
    origin.bits[1] = 0b00000000000000000000000000000000;
    origin.bits[2] = 0b00000000000000000000000000000000;
    origin.bits[3] = 0b10000000000000000000000000000000;
    ck_assert_int_eq(origin.bits[3], result.bits[3]);
    ck_assert_int_eq(origin.bits[2], result.bits[2]);
    ck_assert_int_eq(origin.bits[1], result.bits[1]);
    ck_assert_int_eq(origin.bits[0], result.bits[0]);
    ck_assert_int_eq(value_type_result, value_type_origin);
#test S21_SUB_ADDITION_2_09
    s21_decimal src1, src2, origin, result;
    int value_type_result, value_type_origin;
    // src1 = 1849687;
    // src2 = 6;
    src1.bits[0] = 0b00000000000111000011100101010111;
    src1.bits[1] = 0b00000000000000000000000000000000;
    src1.bits[2] = 0b00000000000000000000000000000000;
    src1.bits[3] = 0b00000000000000000000000000000000;
    src2.bits[0] = 0b00000000000000000000000000000110;
    src2.bits[1] = 0b00000000000000000000000000000000;
    src2.bits[2] = 0b00000000000000000000000000000000;
    src2.bits[3] = 0b00000000000000000000000000000000;
    value_type_result = s21_sub(src1, src2, &result);
    value_type_origin = 0;
    origin.bits[0] = 0b00000000000111000011100101010001;
    origin.bits[1] = 0b00000000000000000000000000000000;
    origin.bits[2] = 0b00000000000000000000000000000000;
    origin.bits[3] = 0b00000000000000000000000000000000;
    ck_assert_int_eq(origin.bits[3], result.bits[3]);
    ck_assert_int_eq(origin.bits[2], result.bits[2]);
    ck_assert_int_eq(origin.bits[1], result.bits[1]);
    ck_assert_int_eq(origin.bits[0], result.bits[0]);
    ck_assert_int_eq(value_type_result, value_type_origin);
#test S21_SUB_ADDITION_2_10
    s21_decimal src1, src2, origin, result;
    int value_type_result, value_type_origin;
    // src1 = -3187878;
    // src2 = 1;
    src1.bits[0] = 0b00000000001100001010010010100110;
    src1.bits[1] = 0b00000000000000000000000000000000;
    src1.bits[2] = 0b00000000000000000000000000000000;
    src1.bits[3] = 0b10000000000000000000000000000000;
    src2.bits[0] = 0b00000000000000000000000000000001;
    src2.bits[1] = 0b00000000000000000000000000000000;
    src2.bits[2] = 0b00000000000000000000000000000000;
    src2.bits[3] = 0b00000000000000000000000000000000;
    value_type_result = s21_sub(src1, src2, &result);
    value_type_origin = 0;
    origin.bits[0] = 0b00000000001100001010010010100111;
    origin.bits[1] = 0b00000000000000000000000000000000;
    origin.bits[2] = 0b00000000000000000000000000000000;
    origin.bits[3] = 0b10000000000000000000000000000000;
    ck_assert_int_eq(origin.bits[3], result.bits[3]);
    ck_assert_int_eq(origin.bits[2], result.bits[2]);
    ck_assert_int_eq(origin.bits[1], result.bits[1]);
    ck_assert_int_eq(origin.bits[0], result.bits[0]);
    ck_assert_int_eq(value_type_result, value_type_origin);
#test S21_SUB_ADDITION_2_11
    s21_decimal src1, src2, origin, result;
    int value_type_result, value_type_origin;
    // src1 = 1;
    // src2 = 18768768;
    src1.bits[0] = 0b00000000000000000000000000000001;
    src1.bits[1] = 0b00000000000000000000000000000000;
    src1.bits[2] = 0b00000000000000000000000000000000;
    src1.bits[3] = 0b00000000000000000000000000000000;
    src2.bits[0] = 0b00000001000111100110001110000000;
    src2.bits[1] = 0b00000000000000000000000000000000;
    src2.bits[2] = 0b00000000000000000000000000000000;
    src2.bits[3] = 0b00000000000000000000000000000000;
    value_type_result = s21_sub(src1, src2, &result);
    value_type_origin = 0;
    origin.bits[0] = 0b00000001000111100110001101111111;
    origin.bits[1] = 0b00000000000000000000000000000000;
    origin.bits[2] = 0b00000000000000000000000000000000;
    origin.bits[3] = 0b10000000000000000000000000000000;
    ck_assert_int_eq(origin.bits[3], result.bits[3]);
    ck_assert_int_eq(origin.bits[2], result.bits[2]);
    ck_assert_int_eq(origin.bits[1], result.bits[1]);
    ck_assert_int_eq(origin.bits[0], result.bits[0]);
    ck_assert_int_eq(value_type_result, value_type_origin);
#test S21_SUB_ADDITION_2_12
    s21_decimal src1, src2, origin, result;
    int value_type_result, value_type_origin;
    // src1 = -2168564564;
    // src2 = -9;
    src1.bits[0] = 0b10000001010000011010101101010100;
    src1.bits[1] = 0b00000000000000000000000000000000;
    src1.bits[2] = 0b00000000000000000000000000000000;
    src1.bits[3] = 0b10000000000000000000000000000000;
    src2.bits[0] = 0b00000000000000000000000000001001;
    src2.bits[1] = 0b00000000000000000000000000000000;
    src2.bits[2] = 0b00000000000000000000000000000000;
    src2.bits[3] = 0b10000000000000000000000000000000;
    value_type_result = s21_sub(src1, src2, &result);
    value_type_origin = 0;
    origin.bits[0] = 0b10000001010000011010101101001011;
    origin.bits[1] = 0b00000000000000000000000000000000;
    origin.bits[2] = 0b00000000000000000000000000000000;
    origin.bits[3] = 0b10000000000000000000000000000000;
    ck_assert_int_eq(origin.bits[3], result.bits[3]);
    ck_assert_int_eq(origin.bits[2], result.bits[2]);
    ck_assert_int_eq(origin.bits[1], result.bits[1]);
    ck_assert_int_eq(origin.bits[0], result.bits[0]);
    ck_assert_int_eq(value_type_result, value_type_origin);
#test S21_SUB_ADDITION_2_13
    s21_decimal src1, src2, origin, result;
    int value_type_result, value_type_origin;
    // src1 = 9999999999999999999;
    // src2 = 1;
    src1.bits[0] = 0b10001001111001111111111111111111;
    src1.bits[1] = 0b10001010110001110010001100000100;
    src1.bits[2] = 0b00000000000000000000000000000000;
    src1.bits[3] = 0b00000000000000000000000000000000;
    src2.bits[0] = 0b00000000000000000000000000000001;
    src2.bits[1] = 0b00000000000000000000000000000000;
    src2.bits[2] = 0b00000000000000000000000000000000;
    src2.bits[3] = 0b00000000000000000000000000000000;
    value_type_result = s21_sub(src1, src2, &result);
    value_type_origin = 0;
    origin.bits[0] = 0b10001001111001111111111111111110;
    origin.bits[1] = 0b10001010110001110010001100000100;
    origin.bits[2] = 0b00000000000000000000000000000000;
    origin.bits[3] = 0b00000000000000000000000000000000;
    ck_assert_int_eq(origin.bits[3], result.bits[3]);
    ck_assert_int_eq(origin.bits[2], result.bits[2]);
    ck_assert_int_eq(origin.bits[1], result.bits[1]);
    ck_assert_int_eq(origin.bits[0], result.bits[0]);
    ck_assert_int_eq(value_type_result, value_type_origin);
#test S21_SUB_ADDITION_2_14
    s21_decimal src1, src2, origin, result;
    int value_type_result, value_type_origin;
    // src1 = 18446744073709551615;
    // src2 = 1;
    src1.bits[0] = 0b11111111111111111111111111111111;
    src1.bits[1] = 0b11111111111111111111111111111111;
    src1.bits[2] = 0b00000000000000000000000000000000;
    src1.bits[3] = 0b00000000000000000000000000000000;
    src2.bits[0] = 0b00000000000000000000000000000001;
    src2.bits[1] = 0b00000000000000000000000000000000;
    src2.bits[2] = 0b00000000000000000000000000000000;
    src2.bits[3] = 0b00000000000000000000000000000000;
    value_type_result = s21_sub(src1, src2, &result);
    value_type_origin = 0;
    origin.bits[0] = 0b11111111111111111111111111111110;
    origin.bits[1] = 0b11111111111111111111111111111111;
    origin.bits[2] = 0b00000000000000000000000000000000;
    origin.bits[3] = 0b00000000000000000000000000000000;
    ck_assert_int_eq(origin.bits[3], result.bits[3]);
    ck_assert_int_eq(origin.bits[2], result.bits[2]);
    ck_assert_int_eq(origin.bits[1], result.bits[1]);
    ck_assert_int_eq(origin.bits[0], result.bits[0]);
    ck_assert_int_eq(value_type_result, value_type_origin);
#test S21_SUB_ADDITION_2_15
    s21_decimal src1, src2, origin, result;
    int value_type_result, value_type_origin;
    // src1 = 18446744073709551615.0;
    // src2 = 3556877454;
    src1.bits[0] = 0b11111111111111111111111111110110;
    src1.bits[1] = 0b11111111111111111111111111111111;
    src1.bits[2] = 0b00000000000000000000000000001001;
    src1.bits[3] = 0b00000000000000010000000000000000;
    src2.bits[0] = 0b11010100000000011010010010001110;
    src2.bits[1] = 0b00000000000000000000000000000000;
    src2.bits[2] = 0b00000000000000000000000000000000;
    src2.bits[3] = 0b00000000000000000000000000000000;
    value_type_result = s21_sub(src1, src2, &result);
    value_type_origin = 0;
    origin.bits[0] = 0b10110111111011111001001001101010;
    origin.bits[1] = 0b11111111111111111111111111110111;
    origin.bits[2] = 0b00000000000000000000000000001001;
    origin.bits[3] = 0b00000000000000010000000000000000;
    ck_assert_int_eq(origin.bits[3], result.bits[3]);
    ck_assert_int_eq(origin.bits[2], result.bits[2]);
    ck_assert_int_eq(origin.bits[1], result.bits[1]);
    ck_assert_int_eq(origin.bits[0], result.bits[0]);
    ck_assert_int_eq(value_type_result, value_type_origin);
#test S21_SUB_ADDITION_2_16
    s21_decimal src1, src2, origin, result;
    int value_type_result, value_type_origin;
    // src1 = -54896651557845.352654545456455;
    // src2 = 21465;
    src1.bits[0] = 0b01110001100100011000110101000111;
    src1.bits[1] = 0b00001111010011100000001101011111;
    src1.bits[2] = 0b10110001011000010111001000100100;
    src1.bits[3] = 0b10000000000011110000000000000000;
    src2.bits[0] = 0b00000000000000000101001111011001;
    src2.bits[1] = 0b00000000000000000000000000000000;
    src2.bits[2] = 0b00000000000000000000000000000000;
    src2.bits[3] = 0b00000000000000000000000000000000;
    value_type_result = s21_sub(src1, src2, &result);
    value_type_origin = 0;
    origin.bits[0] = 0b01111001010101000000110101000111;
    origin.bits[1] = 0b00111001001100010000001100100101;
    origin.bits[2] = 0b10110001011000010111001000100101;
    origin.bits[3] = 0b10000000000011110000000000000000;
    ck_assert_int_eq(origin.bits[3], result.bits[3]);
    ck_assert_int_eq(origin.bits[2], result.bits[2]);
    ck_assert_int_eq(origin.bits[1], result.bits[1]);
    ck_assert_int_eq(origin.bits[0], result.bits[0]);
    ck_assert_int_eq(value_type_result, value_type_origin);
#test S21_SUB_ADDITION_2_17
    s21_decimal src1, src2, origin, result;
    int value_type_result, value_type_origin;
    // src1 = 7961327845421.879754123131254;
    // src2 = 0;
    src1.bits[0] = 0b01001110111001000011100101110110;
    src1.bits[1] = 0b01001011001101011010000111011001;
    src1.bits[2] = 0b00011001101110010111010010111111;
    src1.bits[3] = 0b00000000000011110000000000000000;
    src2.bits[0] = 0b00000000000000000000000000000000;
    src2.bits[1] = 0b00000000000000000000000000000000;
    src2.bits[2] = 0b00000000000000000000000000000000;
    src2.bits[3] = 0b00000000000000000000000000000000;
    value_type_result = s21_sub(src1, src2, &result);
    value_type_origin = 0;
    origin.bits[0] = 0b01001110111001000011100101110110;
    origin.bits[1] = 0b01001011001101011010000111011001;
    origin.bits[2] = 0b00011001101110010111010010111111;
    origin.bits[3] = 0b00000000000011110000000000000000;
    ck_assert_int_eq(origin.bits[3], result.bits[3]);
    ck_assert_int_eq(origin.bits[2], result.bits[2]);
    ck_assert_int_eq(origin.bits[1], result.bits[1]);
    ck_assert_int_eq(origin.bits[0], result.bits[0]);
    ck_assert_int_eq(value_type_result, value_type_origin);
#test S21_SUB_ADDITION_2_18
    s21_decimal src1, src2, origin, result;
    int value_type_result, value_type_origin;
    // src1 = -12345677.987654345678987654346;
    // src2 = 87654323456.9876545678987653;
    src1.bits[0] = 0b10010001000010101111010011001010;
    src1.bits[1] = 0b11000000010001011101010111110010;
    src1.bits[2] = 0b00100111111001000001101100000000;
    src1.bits[3] = 0b10000000000101010000000000000000;
    src2.bits[0] = 0b00010001110011011101000110000101;
    src2.bits[1] = 0b11110101101111000110111111000000;
    src2.bits[2] = 0b00000010110101010000111100111111;
    src2.bits[3] = 0b00000000000100000000000000000000;
    value_type_result = s21_sub(src1, src2, &result);
    value_type_origin = 0;
    origin.bits[0] = 0b11010010000011011110010110111111;
    origin.bits[1] = 0b10100111010011100111001000100001;
    origin.bits[2] = 0b00011100010100111001110111101101;
    origin.bits[3] = 0b10000000000100010000000000000000;
    ck_assert_int_eq(origin.bits[3], result.bits[3]);
    ck_assert_int_eq(origin.bits[2], result.bits[2]);
    ck_assert_int_eq(origin.bits[1], result.bits[1]);
    ck_assert_int_eq(origin.bits[0], result.bits[0]);
    ck_assert_int_eq(value_type_result, value_type_origin);
#test S21_SUB_ADDITION_2_19
    s21_decimal src1, src2, origin, result;
    int value_type_result, value_type_origin;
    // src1 = 12345677.987654345678987654346;
    // src2 = -87654323456.9876545678987653;
    src1.bits[0] = 0b10010001000010101111010011001010;
    src1.bits[1] = 0b11000000010001011101010111110010;
    src1.bits[2] = 0b00100111111001000001101100000000;
    src1.bits[3] = 0b00000000000101010000000000000000;
    src2.bits[0] = 0b00010001110011011101000110000101;
    src2.bits[1] = 0b11110101101111000110111111000000;
    src2.bits[2] = 0b00000010110101010000111100111111;
    src2.bits[3] = 0b10000000000100000000000000000000;
    value_type_result = s21_sub(src1, src2, &result);
    value_type_origin = 0;
    origin.bits[0] = 0b11010010000011011110010110111111;
    origin.bits[1] = 0b10100111010011100111001000100001;
    origin.bits[2] = 0b00011100010100111001110111101101;
    origin.bits[3] = 0b00000000000100010000000000000000;
    ck_assert_int_eq(origin.bits[3], result.bits[3]);
    ck_assert_int_eq(origin.bits[2], result.bits[2]);
    ck_assert_int_eq(origin.bits[1], result.bits[1]);
    ck_assert_int_eq(origin.bits[0], result.bits[0]);
    ck_assert_int_eq(value_type_result, value_type_origin);
#test S21_SUB_ADDITION_2_20
    s21_decimal src1, src2, origin, result;
    int value_type_result, value_type_origin;
    // src1 = -12345677.987 654 345 678 987 654 346;  =  {2433414346, 3225802226, 669260544, 0x80150000} = 00100111 11100100 00011011 00000000  11000000 01000101 11010101 11110010  10010001 00001010 11110100 11001010
    // src2 = -87654323456.987 654 567 898 765 3;     =  {298701189, 4122767296, 47517503, 0x80100000}   = 00000010 11010101 00001111 00111111  11110101 10111100 01101111 11000000  00010001 11001101 11010001 10000101
    src1.bits[0] = 0b10010001000010101111010011001010;
    src1.bits[1] = 0b11000000010001011101010111110010;
    src1.bits[2] = 0b00100111111001000001101100000000;
    src1.bits[3] = 0b10000000000101010000000000000000;
    src2.bits[0] = 0b00010001110011011101000110000101;
    src2.bits[1] = 0b11110101101111000110111111000000;
    src2.bits[2] = 0b00000010110101010000111100111111;
    src2.bits[3] = 0b10000000000100000000000000000000;
    value_type_result = s21_sub(src1, src2, &result);
    value_type_origin = 0;
    origin.bits[0] = 0b10010010000001100111100010100100;  // тут срабатывает банковсое округление
    origin.bits[1] = 0b10001011011010100100100011011111;
    origin.bits[2] = 0b00011100010100011001001100010001;
    origin.bits[3] = 0b00000000000100010000000000000000;
    ck_assert_int_eq(origin.bits[3], result.bits[3]);
    ck_assert_int_eq(origin.bits[2], result.bits[2]);
    ck_assert_int_eq(origin.bits[1], result.bits[1]);
    ck_assert_int_eq(origin.bits[0], result.bits[0]);
    ck_assert_int_eq(value_type_result, value_type_origin);
#test S21_SUB_ADDITION_2_21
    s21_decimal src1, src2, origin, result;
    int value_type_result, value_type_origin;
    // src1 = 0;
    // src2 = 0;
    src1.bits[0] = 0b00000000000000000000000000000000;
    src1.bits[1] = 0b00000000000000000000000000000000;
    src1.bits[2] = 0b00000000000000000000000000000000;
    src1.bits[3] = 0b00000000000000000000000000000000;
    src2.bits[0] = 0b00000000000000000000000000000000;
    src2.bits[1] = 0b00000000000000000000000000000000;
    src2.bits[2] = 0b00000000000000000000000000000000;
    src2.bits[3] = 0b00000000000000000000000000000000;
    value_type_result = s21_sub(src1, src2, &result);
    value_type_origin = 0;
    origin.bits[0] = 0b00000000000000000000000000000000;
    origin.bits[1] = 0b00000000000000000000000000000000;
    origin.bits[2] = 0b00000000000000000000000000000000;
    origin.bits[3] = 0b00000000000000000000000000000000;
    ck_assert_int_eq(origin.bits[3], result.bits[3]);
    ck_assert_int_eq(origin.bits[2], result.bits[2]);
    ck_assert_int_eq(origin.bits[1], result.bits[1]);
    ck_assert_int_eq(origin.bits[0], result.bits[0]);
    ck_assert_int_eq(value_type_result, value_type_origin);
#test S21_SUB_ADDITION_2_22
    s21_decimal src1, src2, origin, result;
    int value_type_result, value_type_origin;
    // src1 = 0;
    // src2 = 0;
    src1.bits[0] = 0b00000000000000000000000000000000;
    src1.bits[1] = 0b00000000000000000000000000000000;
    src1.bits[2] = 0b00000000000000000000000000000000;
    src1.bits[3] = 0b00000000000000000000000000000000;
    src2.bits[0] = 0b00000000000000000000000000000000;
    src2.bits[1] = 0b00000000000000000000000000000000;
    src2.bits[2] = 0b00000000000000000000000000000000;
    src2.bits[3] = 0b00000000000000000000000000000000;
    value_type_result = s21_sub(src1, src2, &result);
    value_type_origin = 0;
    origin.bits[0] = 0b00000000000000000000000000000000;
    origin.bits[1] = 0b00000000000000000000000000000000;
    origin.bits[2] = 0b00000000000000000000000000000000;
    origin.bits[3] = 0b00000000000000000000000000000000;
    ck_assert_int_eq(origin.bits[3], result.bits[3]);
    ck_assert_int_eq(origin.bits[2], result.bits[2]);
    ck_assert_int_eq(origin.bits[1], result.bits[1]);
    ck_assert_int_eq(origin.bits[0], result.bits[0]);
    ck_assert_int_eq(value_type_result, value_type_origin);
#test S21_SUB_ADDITION_2_23
    s21_decimal src1, src2, origin, result;
    int value_type_result, value_type_origin;
    // src1 = 0;
    // src2 = 0;
    src1.bits[0] = 0b00000000000000000000000000000000;
    src1.bits[1] = 0b00000000000000000000000000000000;
    src1.bits[2] = 0b00000000000000000000000000000000;
    src1.bits[3] = 0b00000000000000000000000000000000;
    src2.bits[0] = 0b00000000000000000000000000000000;
    src2.bits[1] = 0b00000000000000000000000000000000;
    src2.bits[2] = 0b00000000000000000000000000000000;
    src2.bits[3] = 0b00000000000000000000000000000000;
    value_type_result = s21_sub(src1, src2, &result);
    value_type_origin = 0;
    origin.bits[0] = 0b00000000000000000000000000000000;
    origin.bits[1] = 0b00000000000000000000000000000000;
    origin.bits[2] = 0b00000000000000000000000000000000;
    origin.bits[3] = 0b00000000000000000000000000000000;
    ck_assert_int_eq(origin.bits[3], result.bits[3]);
    ck_assert_int_eq(origin.bits[2], result.bits[2]);
    ck_assert_int_eq(origin.bits[1], result.bits[1]);
    ck_assert_int_eq(origin.bits[0], result.bits[0]);
    ck_assert_int_eq(value_type_result, value_type_origin);
#test S21_SUB_ADDITION_2_24
    s21_decimal src1, src2, origin, result;
    int value_type_result, value_type_origin;
    // src1 = 79228162514264337593543950335;
    // src2 = 1;
    src1.bits[0] = 0b11111111111111111111111111111111;
    src1.bits[1] = 0b11111111111111111111111111111111;
    src1.bits[2] = 0b11111111111111111111111111111111;
    src1.bits[3] = 0b00000000000000000000000000000000;
    src2.bits[0] = 0b00000000000000000000000000000001;
    src2.bits[1] = 0b00000000000000000000000000000000;
    src2.bits[2] = 0b00000000000000000000000000000000;
    src2.bits[3] = 0b00000000000000000000000000000000;
    value_type_result = s21_sub(src1, src2, &result);
    value_type_origin = 0;
    origin.bits[0] = 0b11111111111111111111111111111110;
    origin.bits[1] = 0b11111111111111111111111111111111;
    origin.bits[2] = 0b11111111111111111111111111111111;
    origin.bits[3] = 0b00000000000000000000000000000000;
    ck_assert_int_eq(origin.bits[3], result.bits[3]);
    ck_assert_int_eq(origin.bits[2], result.bits[2]);
    ck_assert_int_eq(origin.bits[1], result.bits[1]);
    ck_assert_int_eq(origin.bits[0], result.bits[0]);
    ck_assert_int_eq(value_type_result, value_type_origin);
#test S21_SUB_ADDITION_2_25
    s21_decimal src1, src2, origin, result;
    int value_type_result, value_type_origin;
    // src1 = 7922816251427554395;
    // src2 = 65645646;
    src1.bits[0] = 0b01011111000010000000010001011011;
    src1.bits[1] = 0b01101101111100110111111101100111;
    src1.bits[2] = 0b00000000000000000000000000000000;
    src1.bits[3] = 0b00000000000000000000000000000000;
    src2.bits[0] = 0b00000011111010011010110001001110;
    src2.bits[1] = 0b00000000000000000000000000000000;
    src2.bits[2] = 0b00000000000000000000000000000000;
    src2.bits[3] = 0b00000000000000000000000000000000;
    value_type_result = s21_sub(src1, src2, &result);
    value_type_origin = 0;
    origin.bits[0] = 0b01011011000111100101100000001101;
    origin.bits[1] = 0b01101101111100110111111101100111;
    origin.bits[2] = 0b00000000000000000000000000000000;
    origin.bits[3] = 0b00000000000000000000000000000000;
    ck_assert_int_eq(origin.bits[3], result.bits[3]);
    ck_assert_int_eq(origin.bits[2], result.bits[2]);
    ck_assert_int_eq(origin.bits[1], result.bits[1]);
    ck_assert_int_eq(origin.bits[0], result.bits[0]);
    ck_assert_int_eq(value_type_result, value_type_origin);
#test S21_SUB_ADDITION_2_26
    s21_decimal src1, src2, origin, result;
    int value_type_result, value_type_origin;
    // src1 = 665464545;
    // src2 = 8798232189789785;
    src1.bits[0] = 0b00100111101010100010111011100001;
    src1.bits[1] = 0b00000000000000000000000000000000;
    src1.bits[2] = 0b00000000000000000000000000000000;
    src1.bits[3] = 0b00000000000000000000000000000000;
    src2.bits[0] = 0b00010000010100101110011001011001;
    src2.bits[1] = 0b00000000000111110100000111110010;
    src2.bits[2] = 0b00000000000000000000000000000000;
    src2.bits[3] = 0b00000000000000000000000000000000;
    value_type_result = s21_sub(src1, src2, &result);
    value_type_origin = 0;
    origin.bits[0] = 0b11101000101010001011011101111000;
    origin.bits[1] = 0b00000000000111110100000111110001;
    origin.bits[2] = 0b00000000000000000000000000000000;
    origin.bits[3] = 0b10000000000000000000000000000000;
    ck_assert_int_eq(origin.bits[3], result.bits[3]);
    ck_assert_int_eq(origin.bits[2], result.bits[2]);
    ck_assert_int_eq(origin.bits[1], result.bits[1]);
    ck_assert_int_eq(origin.bits[0], result.bits[0]);
    ck_assert_int_eq(value_type_result, value_type_origin);
#test S21_SUB_ADDITION_2_27
    s21_decimal src1, src2, origin, result;
    int value_type_result, value_type_origin;
    // src1 = 2.7986531268974139743;
    // src2 = 9.979623121254565121244554;
    src1.bits[0] = 0b11111110100100001101100101011111;
    src1.bits[1] = 0b10000100011001000010000111101000;
    src1.bits[2] = 0b00000000000000000000000000000001;
    src1.bits[3] = 0b00000000000100110000000000000000;
    src2.bits[0] = 0b11010100101011100011110110001010;
    src2.bits[1] = 0b01110100000101000010011110100011;
    src2.bits[2] = 0b00000000000010000100000101000100;
    src2.bits[3] = 0b00000000000110000000000000000000;
    value_type_result = s21_sub(src1, src2, &result);
    value_type_origin = 0;
    origin.bits[0] = 0b00001110111111111010100000101010;
    origin.bits[1] = 0b00101001110101100000001000110100;
    origin.bits[2] = 0b00000000000001011111000010100001;
    origin.bits[3] = 0b10000000000110000000000000000000;
    ck_assert_int_eq(origin.bits[3], result.bits[3]);
    ck_assert_int_eq(origin.bits[2], result.bits[2]);
    ck_assert_int_eq(origin.bits[1], result.bits[1]);
    ck_assert_int_eq(origin.bits[0], result.bits[0]);
    ck_assert_int_eq(value_type_result, value_type_origin);
#test S21_SUB_ADDITION_2_28
    s21_decimal src1, src2, origin, result;
    int value_type_result, value_type_origin;
    // src1 = -9798956154578676.797564534156;
    // src2 = -2156878451.854764;
    src1.bits[0] = 0b01010100010000000011110110001100;
    src1.bits[1] = 0b10001011010100100000010101011001;
    src1.bits[2] = 0b00011111101010011000000110101101;
    src1.bits[3] = 0b10000000000011000000000000000000;
    src2.bits[0] = 0b01100101111100100100110110101100;
    src2.bits[1] = 0b00000000000001111010100110101011;
    src2.bits[2] = 0b00000000000000000000000000000000;
    src2.bits[3] = 0b10000000000001100000000000000000;
    value_type_result = s21_sub(src1, src2, &result);
    value_type_origin = 0;
    origin.bits[0] = 0b11010010100100100111101010001100;
    origin.bits[1] = 0b10011110100111100111000100000100;
    origin.bits[2] = 0b00011111101010011000000100111000;
    origin.bits[3] = 0b10000000000011000000000000000000;
    ck_assert_int_eq(origin.bits[3], result.bits[3]);
    ck_assert_int_eq(origin.bits[2], result.bits[2]);
    ck_assert_int_eq(origin.bits[1], result.bits[1]);
    ck_assert_int_eq(origin.bits[0], result.bits[0]);
    ck_assert_int_eq(value_type_result, value_type_origin);
#test S21_SUB_ADDITION_2_29
    s21_decimal src1, src2, origin, result;
    int value_type_result, value_type_origin;
    // src1 = 0.5456465465486476846545465485;
    // src2 = 0.68985125146545154;
    src1.bits[0] = 0b00001011000011110111000010001101;
    src1.bits[1] = 0b10010110101100000101100101010001;
    src1.bits[2] = 0b00010001101000010111101110000001;
    src1.bits[3] = 0b00000000000111000000000000000000;
    src2.bits[0] = 0b00010111001001010100110000000010;
    src2.bits[1] = 0b00000000111101010001010110011011;
    src2.bits[2] = 0b00000000000000000000000000000000;
    src2.bits[3] = 0b00000000000100010000000000000000;
    value_type_result = s21_sub(src1, src2, &result);
    value_type_origin = 0;
    origin.bits[0] = 0b01011010101111100101111101110011;
    origin.bits[1] = 0b00101101001111010011000001101000;
    origin.bits[2] = 0b00000100101010001101010101010111;
    origin.bits[3] = 0b10000000000111000000000000000000;
    ck_assert_int_eq(origin.bits[3], result.bits[3]);
    ck_assert_int_eq(origin.bits[2], result.bits[2]);
    ck_assert_int_eq(origin.bits[1], result.bits[1]);
    ck_assert_int_eq(origin.bits[0], result.bits[0]);
    ck_assert_int_eq(value_type_result, value_type_origin);
#test S21_SUB_ADDITION_2_30
    s21_decimal src1, src2, origin, result;
    int value_type_result, value_type_origin;
    // src1 = -1;
    // src2 = -79228162514264337593543950335;
    src1.bits[0] = 0b00000000000000000000000000000001;
    src1.bits[1] = 0b00000000000000000000000000000000;
    src1.bits[2] = 0b00000000000000000000000000000000;
    src1.bits[3] = 0b10000000000000000000000000000000;
    src2.bits[0] = 0b11111111111111111111111111111111;
    src2.bits[1] = 0b11111111111111111111111111111111;
    src2.bits[2] = 0b11111111111111111111111111111111;
    src2.bits[3] = 0b10000000000000000000000000000000;
    value_type_result = s21_sub(src1, src2, &result);
    value_type_origin = 0;
    origin.bits[0] = 0b11111111111111111111111111111110;
    origin.bits[1] = 0b11111111111111111111111111111111;
    origin.bits[2] = 0b11111111111111111111111111111111;
    origin.bits[3] = 0b00000000000000000000000000000000;
    ck_assert_int_eq(origin.bits[3], result.bits[3]);
    ck_assert_int_eq(origin.bits[2], result.bits[2]);
    ck_assert_int_eq(origin.bits[1], result.bits[1]);
    ck_assert_int_eq(origin.bits[0], result.bits[0]);
    ck_assert_int_eq(value_type_result, value_type_origin);
#test S21_SUB_ADDITION_2_31
    s21_decimal src1, src2, origin, result;
    int value_type_result, value_type_origin;
    // src1 = 32323465788987654;
    // src2 = 67543278.89765424354657687;
    src1.bits[0] = 0b01011000010000110001100100000110;
    src1.bits[1] = 0b00000000011100101101011000000101;
    src1.bits[2] = 0b00000000000000000000000000000000;
    src1.bits[3] = 0b00000000000000000000000000000000;
    src2.bits[0] = 0b10111110000100011000010110010111;
    src2.bits[1] = 0b11011001001111010001001011000110;
    src2.bits[2] = 0b00000000000001011001011001001000;
    src2.bits[3] = 0b00000000000100010000000000000000;
    value_type_result = s21_sub(src1, src2, &result);
    value_type_origin = 0;
    origin.bits[0] = 0b00001110100111001011111100100101;
    origin.bits[1] = 0b11011111010111101000100010100000;
    origin.bits[2] = 0b01101000011100010101100000011011;
    origin.bits[3] = 0b00000000000011000000000000000000;
    ck_assert_int_eq(origin.bits[3], result.bits[3]);
    ck_assert_int_eq(origin.bits[2], result.bits[2]);
    ck_assert_int_eq(origin.bits[1], result.bits[1]);
    ck_assert_int_eq(origin.bits[0], result.bits[0]);
    ck_assert_int_eq(value_type_result, value_type_origin);
#test S21_SUB_ADDITION_2_32
    s21_decimal src1, src2, origin, result;
    int value_type_result, value_type_origin;
    // src1 = -784515454.7989898652154545652;
    // src2 = -579895323215489956.67897455465;
    src1.bits[0] = 0b10110001001110110100010111110100;
    src1.bits[1] = 0b00111000100000111010110010000001;
    src1.bits[2] = 0b00011001010110010101110000011000;
    src1.bits[3] = 0b10000000000100110000000000000000;
    src2.bits[0] = 0b11100110001001011001001101101001;
    src2.bits[1] = 0b00111000110110101110001010110100;
    src2.bits[2] = 0b10111011010111111101000100011110;
    src2.bits[3] = 0b10000000000010110000000000000000;
    value_type_result = s21_sub(src1, src2, &result);
    value_type_origin = 0;
    origin.bits[0] = 0b00101100010111011001101101001111;
    origin.bits[1] = 0b11111000000111110000000110111111;
    origin.bits[2] = 0b10111011010111111101000100011001;
    origin.bits[3] = 0b00000000000010110000000000000000;
    ck_assert_int_eq(origin.bits[3], result.bits[3]);
    ck_assert_int_eq(origin.bits[2], result.bits[2]);
    ck_assert_int_eq(origin.bits[1], result.bits[1]);
    ck_assert_int_eq(origin.bits[0], result.bits[0]);
    ck_assert_int_eq(value_type_result, value_type_origin);
#test S21_SUB_ADDITION_2_33
    s21_decimal src1, src2, origin, result;
    int value_type_result, value_type_origin;
    // src1 = 0;
    // src2 = -37986322154988653.784354545765;
    src1.bits[0] = 0b00000000000000000000000000000000;
    src1.bits[1] = 0b00000000000000000000000000000000;
    src1.bits[2] = 0b00000000000000000000000000000000;
    src1.bits[3] = 0b00000000000000000000000000000000;
    src2.bits[0] = 0b01001111101101000110000001100101;
    src2.bits[1] = 0b01000010001101101011011001100001;
    src2.bits[2] = 0b01111010101111011000110010011010;
    src2.bits[3] = 0b10000000000011000000000000000000;
    value_type_result = s21_sub(src1, src2, &result);
    value_type_origin = 0;
    origin.bits[0] = 0b01001111101101000110000001100101;
    origin.bits[1] = 0b01000010001101101011011001100001;
    origin.bits[2] = 0b01111010101111011000110010011010;
    origin.bits[3] = 0b00000000000011000000000000000000;
    ck_assert_int_eq(origin.bits[3], result.bits[3]);
    ck_assert_int_eq(origin.bits[2], result.bits[2]);
    ck_assert_int_eq(origin.bits[1], result.bits[1]);
    ck_assert_int_eq(origin.bits[0], result.bits[0]);
    ck_assert_int_eq(value_type_result, value_type_origin);
#test S21_SUB_ADDITION_2_34
    s21_decimal src1, src2, origin, result;
    int value_type_result, value_type_origin;
    // src1 = 79228162513351883030198514100;
    // src2 = -912454563345436235;
    src1.bits[0] = 0b10110110000111000111000110110100;
    src1.bits[1] = 0b11110011010101100100111101101000;
    src1.bits[2] = 0b11111111111111111111111111111111;
    src1.bits[3] = 0b00000000000000000000000000000000;
    src2.bits[0] = 0b01001001111000111000111001001011;
    src2.bits[1] = 0b00001100101010011011000010010111;
    src2.bits[2] = 0b00000000000000000000000000000000;
    src2.bits[3] = 0b10000000000000000000000000000000;
    value_type_result = s21_sub(src1, src2, &result);
    value_type_origin = 0;
    origin.bits[0] = 0b11111111111111111111111111111111;
    origin.bits[1] = 0b11111111111111111111111111111111;
    origin.bits[2] = 0b11111111111111111111111111111111;
    origin.bits[3] = 0b00000000000000000000000000000000;
    ck_assert_int_eq(origin.bits[3], result.bits[3]);
    ck_assert_int_eq(origin.bits[2], result.bits[2]);
    ck_assert_int_eq(origin.bits[1], result.bits[1]);
    ck_assert_int_eq(origin.bits[0], result.bits[0]);
    ck_assert_int_eq(value_type_result, value_type_origin);
#test S21_SUB_ADDITION_2_35
    s21_decimal src1, src2, origin, result;
    int value_type_result, value_type_origin;
    decimal_reset(&result);
    // src1 = 59978456487987764548465456454;
    // src2 = -48786756456875658915646545165;
    src1.bits[0] = 0b00011111001111011111010101000110;
    src1.bits[1] = 0b01010100100001101100100010110010;
    src1.bits[2] = 0b11000001110011010000010000110001;
    src1.bits[3] = 0b00000000000000000000000000000000;
    src2.bits[0] = 0b01100000001001000001110100001101;
    src2.bits[1] = 0b11110100000010101101000010000000;
    src2.bits[2] = 0b10011101101000110111010110000110;
    src2.bits[3] = 0b10000000000000000000000000000000;
    value_type_result = s21_sub(src1, src2, &result);
    value_type_origin = 1;
    origin.bits[0] = 0b00000000000000000000000000000000;
    origin.bits[1] = 0b00000000000000000000000000000000;
    origin.bits[2] = 0b00000000000000000000000000000000;
    origin.bits[3] = 0b00000000111111110000000000000000;
    ck_assert_int_eq(origin.bits[3], result.bits[3]);
    ck_assert_int_eq(origin.bits[2], result.bits[2]);
    ck_assert_int_eq(origin.bits[1], result.bits[1]);
    ck_assert_int_eq(origin.bits[0], result.bits[0]);
    ck_assert_int_eq(value_type_result, value_type_origin);
#test S21_SUB_ADDITION_2_36
    s21_decimal src1, src2, origin, result;
    int value_type_result, value_type_origin;
    decimal_reset(&result);
    // src1 = 59978456487987764548465456454;  {524154182, 1418119346, 3251438641, 0x00000000}   = 11000001 11001101 00000100 00110001  01010100 10000110 11001000 10110010  00011111 00111101 11110101 01000110
    // src2 = -48786756456875658915646545165; {1612979469, 4094349440, 2644735366, 0x00000000}   = 10011101 10100011 01110101 10000110  11110100 00001010 11010000 10000000  01100000 00100100 00011101 00001101
    src1.bits[0] = 0b00011111001111011111010101000110;
    src1.bits[1] = 0b01010100100001101100100010110010;
    src1.bits[2] = 0b11000001110011010000010000110001;
    src1.bits[3] = 0b00000000000000000000000000000000;
    src2.bits[0] = 0b01100000001001000001110100001101;
    src2.bits[1] = 0b11110100000010101101000010000000;
    src2.bits[2] = 0b10011101101000110111010110000110;
    src2.bits[3] = 0b10000000000000000000000000000000;
    value_type_result = s21_sub(src1, src2, &result);
    value_type_origin = 1;
    origin.bits[0] = 0b00000000000000000000000000000000;
    origin.bits[1] = 0b00000000000000000000000000000000;
    origin.bits[2] = 0b00000000000000000000000000000000;
    origin.bits[3] = 0b00000000111111110000000000000000;
    ck_assert_int_eq(origin.bits[3], result.bits[3]);
    ck_assert_int_eq(origin.bits[2], result.bits[2]);
    ck_assert_int_eq(origin.bits[1], result.bits[1]);
    ck_assert_int_eq(origin.bits[0], result.bits[0]);
    ck_assert_int_eq(value_type_result, value_type_origin);
#test S21_SUB_ADDITION_2_37
    s21_decimal src1, src2, origin, result;
    int value_type_result, value_type_origin;
    // src1 = 79228162514264337593543950335;
    // src2 = 79228162514264337593543950335;
    src1.bits[0] = 0b11111111111111111111111111111111;
    src1.bits[1] = 0b11111111111111111111111111111111;
    src1.bits[2] = 0b11111111111111111111111111111111;
    src1.bits[3] = 0b00000000000000000000000000000000;
    src2.bits[0] = 0b11111111111111111111111111111111;
    src2.bits[1] = 0b11111111111111111111111111111111;
    src2.bits[2] = 0b11111111111111111111111111111111;
    src2.bits[3] = 0b00000000000000000000000000000000;
    value_type_result = s21_sub(src1, src2, &result);
    value_type_origin = 0;
    origin.bits[0] = 0b00000000000000000000000000000000;
    origin.bits[1] = 0b00000000000000000000000000000000;
    origin.bits[2] = 0b00000000000000000000000000000000;
    origin.bits[3] = 0b00000000000000000000000000000000;
    ck_assert_int_eq(origin.bits[3], result.bits[3]);
    ck_assert_int_eq(origin.bits[2], result.bits[2]);
    ck_assert_int_eq(origin.bits[1], result.bits[1]);
    ck_assert_int_eq(origin.bits[0], result.bits[0]);
    ck_assert_int_eq(value_type_result, value_type_origin);
#test S21_SUB_ADDITION_2_38
    s21_decimal src1, src2, origin, result;
    int value_type_result, value_type_origin;
    // src1 = 0.0;
    // src2 = 0.0;
    src1.bits[0] = 0b00000000000000000000000000000000;
    src1.bits[1] = 0b00000000000000000000000000000000;
    src1.bits[2] = 0b00000000000000000000000000000000;
    src1.bits[3] = 0b00000000000000010000000000000000;
    src2.bits[0] = 0b00000000000000000000000000000000;
    src2.bits[1] = 0b00000000000000000000000000000000;
    src2.bits[2] = 0b00000000000000000000000000000000;
    src2.bits[3] = 0b00000000000000010000000000000000;
    value_type_result = s21_sub(src1, src2, &result);
    value_type_origin = 0;
    origin.bits[0] = 0b00000000000000000000000000000000;
    origin.bits[1] = 0b00000000000000000000000000000000;
    origin.bits[2] = 0b00000000000000000000000000000000;
    origin.bits[3] = 0b00000000000000000000000000000000;
    ck_assert_int_eq(origin.bits[3], result.bits[3]);
    ck_assert_int_eq(origin.bits[2], result.bits[2]);
    ck_assert_int_eq(origin.bits[1], result.bits[1]);
    ck_assert_int_eq(origin.bits[0], result.bits[0]);
    ck_assert_int_eq(value_type_result, value_type_origin);
#test S21_SUB_ADDITION_2_39
    s21_decimal src1, src2, origin, result;
    int value_type_result, value_type_origin;
    decimal_reset(&result);
    // src1 = 1;
    // src2 = 0.0;
    src1.bits[0] = 0b00000000000000000000000000000001;
    src1.bits[1] = 0b00000000000000000000000000000000;
    src1.bits[2] = 0b00000000000000000000000000000000;
    src1.bits[3] = 0b00000000000000000000000000000000;
    src2.bits[0] = 0b00000000000000000000000000000000;
    src2.bits[1] = 0b00000000000000000000000000000000;
    src2.bits[2] = 0b00000000000000000000000000000000;
    src2.bits[3] = 0b00000000000000010000000000000000;
    value_type_result = s21_sub(src1, src2, &result);
    value_type_origin = 0;
    origin.bits[0] = 0b00000000000000000000000000000001;
    origin.bits[1] = 0b00000000000000000000000000000000;
    origin.bits[2] = 0b00000000000000000000000000000000;
    origin.bits[3] = 0b00000000000000000000000000000000;
    ck_assert_int_eq(origin.bits[3], result.bits[3]);
    ck_assert_int_eq(origin.bits[2], result.bits[2]);
    ck_assert_int_eq(origin.bits[1], result.bits[1]);
    ck_assert_int_eq(origin.bits[0], result.bits[0]);
    ck_assert_int_eq(value_type_result, value_type_origin);
#test S21_SUB_ADDITION_2_40
    s21_decimal src1, src2, origin, result;
    int value_type_result, value_type_origin;
    decimal_reset(&result);
    // src1 = 0.0;
    // src2 = 1;
    src1.bits[0] = 0b00000000000000000000000000000000;
    src1.bits[1] = 0b00000000000000000000000000000000;
    src1.bits[2] = 0b00000000000000000000000000000000;
    src1.bits[3] = 0b00000000000000010000000000000000;
    src2.bits[0] = 0b00000000000000000000000000000001;
    src2.bits[1] = 0b00000000000000000000000000000000;
    src2.bits[2] = 0b00000000000000000000000000000000;
    src2.bits[3] = 0b00000000000000000000000000000000;
    value_type_result = s21_sub(src1, src2, &result);
    value_type_origin = 0;
    origin.bits[0] = 0b00000000000000000000000000000001;
    origin.bits[1] = 0b00000000000000000000000000000000;
    origin.bits[2] = 0b00000000000000000000000000000000;
    origin.bits[3] = 0b10000000000000000000000000000000;
    ck_assert_int_eq(origin.bits[3], result.bits[3]);
    ck_assert_int_eq(origin.bits[2], result.bits[2]);
    ck_assert_int_eq(origin.bits[1], result.bits[1]);
    ck_assert_int_eq(origin.bits[0], result.bits[0]);
    ck_assert_int_eq(value_type_result, value_type_origin);
#test S21_SUB_ADDITION_2_41
    s21_decimal src1, src2, origin, result;
    int value_type_result, value_type_origin;
    decimal_reset(&result);
    // src1 = 1;
    // src2 = 0;
    src1.bits[0] = 0b00000000000000000000000000000001;
    src1.bits[1] = 0b00000000000000000000000000000000;
    src1.bits[2] = 0b00000000000000000000000000000000;
    src1.bits[3] = 0b00000000000000000000000000000000;
    src2.bits[0] = 0b00000000000000000000000000000000;
    src2.bits[1] = 0b00000000000000000000000000000000;
    src2.bits[2] = 0b00000000000000000000000000000000;
    src2.bits[3] = 0b00000000000000000000000000000000;
    value_type_result = s21_sub(src1, src2, &result);
    value_type_origin = 0;
    origin.bits[0] = 0b00000000000000000000000000000001;
    origin.bits[1] = 0b00000000000000000000000000000000;
    origin.bits[2] = 0b00000000000000000000000000000000;
    origin.bits[3] = 0b00000000000000000000000000000000;
    ck_assert_int_eq(origin.bits[3], result.bits[3]);
    ck_assert_int_eq(origin.bits[2], result.bits[2]);
    ck_assert_int_eq(origin.bits[1], result.bits[1]);
    ck_assert_int_eq(origin.bits[0], result.bits[0]);
    ck_assert_int_eq(value_type_result, value_type_origin);
#test S21_SUB_ADDITION_2_42
    s21_decimal src1, src2, origin, result;
    int value_type_result, value_type_origin;
    decimal_reset(&result);
    // src1 = 0;
    // src2 = 1;
    src1.bits[0] = 0b00000000000000000000000000000000;
    src1.bits[1] = 0b00000000000000000000000000000000;
    src1.bits[2] = 0b00000000000000000000000000000000;
    src1.bits[3] = 0b00000000000000000000000000000000;
    src2.bits[0] = 0b00000000000000000000000000000001;
    src2.bits[1] = 0b00000000000000000000000000000000;
    src2.bits[2] = 0b00000000000000000000000000000000;
    src2.bits[3] = 0b00000000000000000000000000000000;
    value_type_result = s21_sub(src1, src2, &result);
    value_type_origin = 0;
    origin.bits[0] = 0b00000000000000000000000000000001;
    origin.bits[1] = 0b00000000000000000000000000000000;
    origin.bits[2] = 0b00000000000000000000000000000000;
    origin.bits[3] = 0b10000000000000000000000000000000;
    ck_assert_int_eq(origin.bits[3], result.bits[3]);
    ck_assert_int_eq(origin.bits[2], result.bits[2]);
    ck_assert_int_eq(origin.bits[1], result.bits[1]);
    ck_assert_int_eq(origin.bits[0], result.bits[0]);
    ck_assert_int_eq(value_type_result, value_type_origin);
#test S21_SUB_ADDITION_2_43
    s21_decimal src1, src2, origin, result;
    int value_type_result, value_type_origin;
    decimal_reset(&result);
    // src1 = 0;
    // src2 = 0;
    src1.bits[0] = 0b00000000000000000000000000000000;
    src1.bits[1] = 0b00000000000000000000000000000000;
    src1.bits[2] = 0b00000000000000000000000000000000;
    src1.bits[3] = 0b00000000000000000000000000000000;
    src2.bits[0] = 0b00000000000000000000000000000000;
    src2.bits[1] = 0b00000000000000000000000000000000;
    src2.bits[2] = 0b00000000000000000000000000000000;
    src2.bits[3] = 0b00000000000000000000000000000000;
    value_type_result = s21_sub(src1, src2, &result);
    value_type_origin = 0;
    origin.bits[0] = 0b00000000000000000000000000000000;
    origin.bits[1] = 0b00000000000000000000000000000000;
    origin.bits[2] = 0b00000000000000000000000000000000;
    origin.bits[3] = 0b00000000000000000000000000000000;
    ck_assert_int_eq(origin.bits[3], result.bits[3]);
    ck_assert_int_eq(origin.bits[2], result.bits[2]);
    ck_assert_int_eq(origin.bits[1], result.bits[1]);
    ck_assert_int_eq(origin.bits[0], result.bits[0]);
    ck_assert_int_eq(value_type_result, value_type_origin);
#test S21_SUB_ADDITION_2_44
    s21_decimal src1, src2, origin, result;
    int value_type_result, value_type_origin;
    decimal_reset(&result);
    src1.bits[0] = 0b11111111111111111111111111111111;
    src1.bits[1] = 0b11111111111111111111111111111111;
    src1.bits[2] = 0b11111111111111111111111111111111;
    src1.bits[3] = 0b10000000000000000000000000000000;
    src2.bits[0] = 0b00000000000000000000000000000001;
    src2.bits[1] = 0b00000000000000000000000000000000;
    src2.bits[2] = 0b00000000000000000000000000000000;
    src2.bits[3] = 0b00000000000000000000000000000000;
    value_type_result = s21_sub(src1, src2, &result);
    value_type_origin = 2;
    origin.bits[0] = 0b00000000000000000000000000000000;
    origin.bits[1] = 0b00000000000000000000000000000000;
    origin.bits[2] = 0b00000000000000000000000000000000;
    origin.bits[3] = 0b10000000111111110000000000000000;
    ck_assert_int_eq(origin.bits[3], result.bits[3]);
    ck_assert_int_eq(origin.bits[2], result.bits[2]);
    ck_assert_int_eq(origin.bits[1], result.bits[1]);
    ck_assert_int_eq(origin.bits[0], result.bits[0]);
    ck_assert_int_eq(value_type_result, value_type_origin);
#test S21_SUB_ADDITION_2_45
    s21_decimal src1, src2, origin, result;
    int value_type_result, value_type_origin;
    decimal_reset(&result);
    // src1 = 0;
    // src2 = 0;
    src1.bits[0] = 0b11111111111111111111111111111111;
    src1.bits[1] = 0b11111111111111111111111111111111;
    src1.bits[2] = 0b11111111111111111111111111111111;
    src1.bits[3] = 0b00000000000000000000000000000000;
    src2.bits[0] = 0b00000000000000000000000000000110;
    src2.bits[1] = 0b00000000000000000000000000000000;
    src2.bits[2] = 0b00000000000000000000000000000000;
    src2.bits[3] = 0x00010000;
    value_type_result = s21_sub(src1, src2, &result);
    value_type_origin = 0;
    origin.bits[0] = 0b11111111111111111111111111111110;
    origin.bits[1] = 0b11111111111111111111111111111111;
    origin.bits[2] = 0b11111111111111111111111111111111;
    origin.bits[3] = 0b00000000000000000000000000000000;
    ck_assert_int_eq(origin.bits[3], result.bits[3]);
    ck_assert_int_eq(origin.bits[2], result.bits[2]);
    ck_assert_int_eq(origin.bits[1], result.bits[1]);
    ck_assert_int_eq(origin.bits[0], result.bits[0]);
    ck_assert_int_eq(value_type_result, value_type_origin);



#test S21_TRUNCATE
    s21_decimal result = {{0}};
    s21_decimal value_01 = {{543, 0, 0, 0x80050000}};                           // -0,00543 => -0
    s21_decimal value_02 = {{543, 0, 0, 0x00050000}};                           //  0,00543 => 0
    s21_decimal value_03 = {{4294967295, 4294967295, 4294967295, 0x800A0000}};  // -79 228 162 514 264 337 59,3 543 950 335 => -7 922 816 251 426 433 759
    s21_decimal value_04 = {{2147483647, 2147483647, 2147483647, 0x80180000}};  // -39 614, 081 247 908 796 757 769 715 711 => -39 614
    s21_decimal value_05 = {{10, 0, 0, 0x80010000}};                            // -1,0 => -1
    s21_decimal value_06 = {{98723, 0, 0, 0x80060000}};                         // -0,098723 => -0
    s21_decimal value_07 = {{0, 0, 0, 0x00000000}};                             //  0 => 0
    s21_decimal value_08 = {{0, 0, 0, 0x00050000}};                             //  0,00000 => 0
    s21_decimal value_09 = {{542, 0, 0, 0x00050000}};                           //  0,00542 => 0
    s21_decimal value_10 = {{10, 0, 0, 0x00010000}};                            //  1,0 => 1
    s21_decimal value_11 = {{14375, 0, 0, 0x00030000}};                         //  14,325 => 14
    s21_decimal value_12 = {{0, 4294967295, 0, 0x00060000}};                    //  18 446 744 069 414, 584 320 => 18 446 744 069 414
    s21_decimal value_13 = {{4294967295, 4294967295, 0, 0x000F0000}};           //  18 446, 744 073 709 551 615 => 18 446
    s21_decimal value_14 = {{2147483647, 2147483647, 2147483647, 0x000F0000}};  //  39 614 081 247 908, 796 757 769 715 711 => 39 614 081 247 908
    s21_decimal value_15 = {{699050, 0, 0, 0x00010000}};                        //  699 05,0 => 69 905
    s21_decimal value_16 = {{0, 0, 0, 0x80FF0000}};                             // -INF => fuction == 1
    s21_decimal value_17 = {{0, 0, 0, 0x00FF0000}};                             // +INF => fuction == 1
    s21_decimal value_18 = {{1431655765, 1431655765, 1431655765, 0x80FF0000}};  //  NaN (диапазон от (-1)*10^(-28) до (-1)*10^(-28), но !=0)
    s21_decimal correct_answer_01 = {{0, 0, 0, 0x80000000}};                    // -0
    s21_decimal correct_answer_02 = {{0, 0, 0, 0x00000000}};                    //  0
    s21_decimal correct_answer_03 = {{1593240287, 1844674407, 0, 0x80000000}};  // -7 922 816 251 426 433 759
    s21_decimal correct_answer_04 = {{39614, 0, 0, 0x80000000}};                // -39 614
    s21_decimal correct_answer_05 = {{1, 0, 0, 0x80000000}};                    // -1
    s21_decimal correct_answer_06 = {{0, 0, 0, 0x80000000}};
    s21_decimal correct_answer_07 = {{0, 0, 0, 0x00000000}};
    s21_decimal correct_answer_08 = {{0, 0, 0, 0x00000000}};
    s21_decimal correct_answer_09 = {{0, 0, 0, 0x00000000}};
    s21_decimal correct_answer_10 = {{1, 0, 0, 0x00000000}};
    s21_decimal correct_answer_11 = {{14, 0, 0, 0x00000000}};
    s21_decimal correct_answer_12 = {{4154500390, 4294, 0, 0x00000000}};
    s21_decimal correct_answer_13 = {{18446, 0, 0, 0x00000000}};
    s21_decimal correct_answer_14 = {{1597876900, 9223, 0, 0x00000000}};        //  39 614 081 247 908
    s21_decimal correct_answer_15 = {{69905, 0, 0, 0x00000000}};               //  69 905
    decimal_reset(&result);
    ck_assert_int_eq(s21_truncate(value_01, &result), 0);                     // -0
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_01.bits[i]);
    }
    decimal_reset(&result);
    ck_assert_int_eq(s21_truncate(value_02, &result), 0);                     //  0
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_02.bits[i]);
    }
    decimal_reset(&result);
    ck_assert_int_eq(s21_truncate(value_03, &result), 0);                     // -7 922 816 251 426 433 759
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_03.bits[i]);
    }
    decimal_reset(&result);
    ck_assert_int_eq(s21_truncate(value_04, &result), 0);                     // -39 614
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_04.bits[i]);
    }
    decimal_reset(&result);
    ck_assert_int_eq(s21_truncate(value_05, &result), 0);                     // -1
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_05.bits[i]);
    }
    decimal_reset(&result);
    ck_assert_int_eq(s21_truncate(value_06, &result), 0);                     // -0
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_06.bits[i]);
    }
    decimal_reset(&result);
    ck_assert_int_eq(s21_truncate(value_07, &result), 0);                     //  0
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_07.bits[i]);
    }
    decimal_reset(&result);
    ck_assert_int_eq(s21_truncate(value_08, &result), 0);                     //  0
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_08.bits[i]);
    }
    decimal_reset(&result);
    ck_assert_int_eq(s21_truncate(value_09, &result), 0);                     //  0
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_09.bits[i]);
    }
    decimal_reset(&result);
    ck_assert_int_eq(s21_truncate(value_10, &result), 0);                     //  0
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_10.bits[i]);
    }
    decimal_reset(&result);
    ck_assert_int_eq(s21_truncate(value_11, &result), 0);                     //  0
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_11.bits[i]);
    }
    decimal_reset(&result);
    ck_assert_int_eq(s21_truncate(value_12, &result), 0);                     //  0
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_12.bits[i]);
    }
    decimal_reset(&result);
    ck_assert_int_eq(s21_truncate(value_13, &result), 0);                     //  18 446
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_13.bits[i]);
    }
    decimal_reset(&result);
    ck_assert_int_eq(s21_truncate(value_14, &result), 0);                     //  39 614 081 247 908
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_14.bits[i]);
    }
    decimal_reset(&result);
    ck_assert_int_eq(s21_truncate(value_15, &result), 0);                     //  69 905
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_15.bits[i]);
    }
    decimal_reset(&result);                                      
    ck_assert_int_eq(s21_truncate(value_16, &result), 1);                     // 1: -INF
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], value_16.bits[i]);
    }
    decimal_reset(&result);    
    ck_assert_int_eq(s21_truncate(value_17, &result), 1);                     // 1: +INF
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], value_17.bits[i]);
    }
    decimal_reset(&result);  
    ck_assert_int_eq(s21_truncate(value_18, &result), 1);                     // 1: NaN
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], value_18.bits[i]);
    }



#test PRINT_DECIMAL_TO_BINARY
    s21_decimal value_01 = {{0}};
    printf("Тест вывода s21_decimal = \n");
    print_decimal_to_binary(value_01);



#test PRINT_BIG_DECIMAL_TO_BINARY
    s21_big_decimal value_01 = {{0, 0, 0, 0, 0, 0,0, 0, 0, 0x00000000}};
    printf("Тест вывода s21_big_decimal = \n");
    print_big_decimal_to_binary(value_01);




#test SET_BIT
    s21_decimal value_01 = {{0, 0, 0, 0x00000000}};        //  sign = 0 scale = 0    value_1.bits[3] = 00000000 00000000 00000000 00000000
    s21_decimal value_02 = {{0, 0, 0, 0x00010000}};        //  sign = 0 scale = 1    value_2.bits[3] = 00000000 00000001 00000000 00000000
    s21_decimal value_03 = {{0, 0, 0, 0x000F0000}};        //  sign = 0 scale = 15   value_3.bits[3] = 00000000 00001111 00000000 00000000
    ck_assert_int_eq(set_bit(&value_01, -5, 1), 1);
    ck_assert_int_eq(set_bit(&value_02, 5, 4), 1);
    ck_assert_int_eq(set_bit(&value_03, 145, 1), 1);



#test GET_SCALE
    s21_decimal value_1 = {{0, 0, 0, 0x00000000}};        //  sign = 0 scale = 0    value_1.bits[3] = 00000000 00000000 00000000 00000000
    s21_decimal value_2 = {{0, 0, 0, 0x00010000}};        //  sign = 0 scale = 1    value_2.bits[3] = 00000000 00000001 00000000 00000000
    s21_decimal value_3 = {{0, 0, 0, 0x000F0000}};        //  sign = 0 scale = 15   value_3.bits[3] = 00000000 00001111 00000000 00000000
    s21_decimal value_4 = {{0, 0, 0, 0x001C0000}};        //  sign = 0 scale = 28   value_4.bits[3] = 00000000 00011100 00000000 00000000
    s21_decimal value_5 = {{0, 0, 0, 0x001D0000}};        //  sign = 0 scale = 29   value_5.bits[3] = 00000000 00011101 00000000 00000000
    s21_decimal value_6 = {{0, 0, 0, 0x007F0000}};        //  sign = 0 scale = 127  value_6.bits[3] = 00000000 11111111 00000000 00000000
    s21_decimal value_7 = {{0, 0, 0, 0x80010000}};        //  sign = 1 scale = 1    value_1.bits[3] = 10000000 00000001 00000000 00000000
    s21_decimal value_8 = {{0, 0, 0, 0x800F0000}};        //  sign = 1 scale = 15   value_3.bits[3] = 10000000 00001111 00000000 00000000
    s21_decimal value_9 = {{2147483647, 2147483647, 2147483647, 2148466688}};  //  sign = 0 scale = 15   value_3.bits[3] = 10000000 00001111 00000000 00000000
    ck_assert_int_eq(get_scale(value_1), 0);
    ck_assert_int_eq(get_scale(value_2), 1);
    ck_assert_int_eq(get_scale(value_3), 15);
    ck_assert_int_eq(get_scale(value_4), 28);
    ck_assert_int_eq(get_scale(value_5), 29);
    ck_assert_int_eq(get_scale(value_6), 127);
    ck_assert_int_eq(get_scale(value_7), 1);
    ck_assert_int_eq(get_scale(value_8), 15);
    ck_assert_int_eq(get_scale(value_9), 15);



#test SET_SIGN
    s21_decimal tmp_value = {{0}};
    s21_decimal value_01 = {{0, 0, 0, 0x00000000}};
    s21_decimal value_02 = {{0, 0, 0, 0x80000000}};
    s21_decimal value_03 = {{0, 0, 0, 0x00020000}};
    s21_decimal value_04 = {{0, 0, 0, 0x80020000}};
    s21_decimal value_05 = {{15, 0, 0, 0x00030000}};
    s21_decimal value_06 = {{15, 0, 0, 0x80030000}};
    s21_decimal value_07 = {{15, 31, 63, 0x00050000}};
    s21_decimal value_08 = {{15, 31, 63, 0x80050000}};
    s21_decimal correct_answer_01 = {{0, 0, 0, 0x80000000}};
    s21_decimal correct_answer_02 = {{0, 0, 0, 0x00000000}};
    s21_decimal correct_answer_03 = {{0, 0, 0, 0x00020000}};
    s21_decimal correct_answer_04 = {{0, 0, 0, 0x80020000}};
    s21_decimal correct_answer_05 = {{15, 0, 0, 0x80030000}};
    s21_decimal correct_answer_06 = {{15, 0, 0, 0x00030000}};
    s21_decimal correct_answer_07 = {{15, 31, 63, 0x80050000}};
    s21_decimal correct_answer_08 = {{15, 31, 63, 0x00050000}};
    copy_from_decimal_to_decimal(value_01, &tmp_value);
    set_sign(&tmp_value, 1);
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(tmp_value.bits[i], correct_answer_01.bits[i]);
    }
    copy_from_decimal_to_decimal(value_02, &tmp_value);
    set_sign(&tmp_value, 0);
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(tmp_value.bits[i], correct_answer_02.bits[i]);
    }
    copy_from_decimal_to_decimal(value_03, &tmp_value);
    set_sign(&tmp_value, 0);
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(tmp_value.bits[i], correct_answer_03.bits[i]);
    }
    copy_from_decimal_to_decimal(value_04, &tmp_value);
    set_sign(&tmp_value, 1);
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(tmp_value.bits[i], correct_answer_04.bits[i]);
    }
    copy_from_decimal_to_decimal(value_05, &tmp_value);
    set_sign(&tmp_value, 1);
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(tmp_value.bits[i], correct_answer_05.bits[i]);
    }
    copy_from_decimal_to_decimal(value_06, &tmp_value);
    set_sign(&tmp_value, 0);
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(tmp_value.bits[i], correct_answer_06.bits[i]);
    }
    copy_from_decimal_to_decimal(value_07, &tmp_value);
    set_sign(&tmp_value, 1);
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(tmp_value.bits[i], correct_answer_07.bits[i]);
    }
    copy_from_decimal_to_decimal(value_08, &tmp_value);
    set_sign(&tmp_value, 0);
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(tmp_value.bits[i], correct_answer_08.bits[i]);
    }



#test CHANGE_SIGN
    s21_decimal value_01 = {{0, 0, 0, 0x00000000}};
    change_sign(&value_01);
    ck_assert_int_eq(value_01.bits[SCALE], 0x80000000);
    change_sign(&value_01);
    ck_assert_int_eq(value_01.bits[SCALE], 0x00000000);
    change_sign(&value_01);
    ck_assert_int_eq(value_01.bits[SCALE], 0x80000000);
    change_sign(&value_01);
    ck_assert_int_eq(value_01.bits[SCALE], 0x00000000);



#test BIG_CHANGE_SIGN
    s21_big_decimal value_01 = {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};
    big_change_sign(&value_01);
    ck_assert_int_eq(value_01.bits[9], 0x80000000);
    big_change_sign(&value_01);
    ck_assert_int_eq(value_01.bits[9], 0x00000000);
    big_change_sign(&value_01);
    ck_assert_int_eq(value_01.bits[9], 0x80000000);
    big_change_sign(&value_01);
    ck_assert_int_eq(value_01.bits[9], 0x00000000);



#test NORM_FROM_DECIMAL_TO_BIG_DECIMAL
    s21_big_decimal tmp_value_01 = {{0}};
    s21_big_decimal tmp_value_02 = {{0}}; 
    s21_decimal value_01_1 = {{300, 0, 0, 0x00020000}};        //  
    s21_decimal value_01_2 = {{10, 0, 0, 0x00010000}};         //  sign = 0 scale = 1    value_2.bits[3] = 00000000 00000001 00000000 00000000
    s21_decimal value_02_1 = {{376, 0, 0, 0x00000000}};        //  sign = 0 scale = 15   value_3.bits[3] = 00000000 00001111 00000000 00000000
    s21_decimal value_02_2 = {{54256, 0, 0, 0x00030000}};          //  sign = 0 scale = 28   value_4.bits[3] = 00000000 00011100 00000000 00000000
    s21_decimal value_03_1 = {{376, 0, 0, 0x00000000}};        //  sign = 0 scale = 15   value_3.bits[3] = 00000000 00001111 00000000 00000000
    s21_decimal value_03_2 = {{54256, 0, 0, 0x00000000}};          //  sign = 0 scale = 28   value_4.bits[3] = 00000000 00011100 00000000 00000000
    s21_big_decimal correct_answer_01_1 = {{300, 0, 0, 0, 0, 0, 0, 0, 0, 0x00020000}};
    s21_big_decimal correct_answer_01_2 = {{100, 0, 0, 0, 0, 0, 0, 0, 0, 0x00020000}};
    s21_big_decimal correct_answer_02_1 = {{376000, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};
    s21_big_decimal correct_answer_02_2 = {{54256, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};
    s21_big_decimal correct_answer_03_1 = {{376000, 0, 0, 0, 0, 0, 0, 0, 0, 0x00030000}};
    s21_big_decimal correct_answer_03_2 = {{54256, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};
    norm_from_decimal_to_big_decimal(value_01_1, value_01_2, &tmp_value_01, &tmp_value_02, 1);
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(tmp_value_01.bits[i], correct_answer_01_1.bits[i]);
    }
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(tmp_value_02.bits[i], correct_answer_01_2.bits[i]);
    }
    norm_from_decimal_to_big_decimal(value_02_1, value_02_2, &tmp_value_01, &tmp_value_02, 1);
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(tmp_value_01.bits[i], correct_answer_02_1.bits[i]);
    }
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(tmp_value_02.bits[i], correct_answer_02_2.bits[i]);
    }
    norm_from_decimal_to_big_decimal(value_03_1, value_03_2, &tmp_value_01, &tmp_value_02, 2);
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(tmp_value_01.bits[i], correct_answer_03_1.bits[i]);
    }
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(tmp_value_02.bits[i], correct_answer_03_2.bits[i]);
    }
    norm_from_decimal_to_big_decimal(value_03_1, value_03_2, &tmp_value_01, &tmp_value_02, 4);
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(tmp_value_01.bits[i], correct_answer_03_1.bits[i]);
    }
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(tmp_value_02.bits[i], correct_answer_03_2.bits[i]);
    }
    


#test ALIGNMENT_OF_POWERS_OF_DECIMAL
    s21_decimal value_11 = {{300, 0, 0, 0x00000000}};        //  
    s21_decimal value_12 = {{300, 0, 0, 0x00000000}};        //  
    s21_decimal correct_answer_11 = {{300, 0, 0, 0x00000000}};        //  sign = 0 scale = 1    value_2.bits[3] = 00000000 00000001 00000000 00000000
    s21_decimal correct_answer_12 = {{300, 0, 0, 0x00000000}};        //  sign = 0 scale = 1    value_2.bits[3] = 00000000 00000001 00000000 00000000
    ck_assert_int_eq(alignment_of_powers_of_decimal(&value_11, &value_12), 1);
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(value_11.bits[i], correct_answer_11.bits[i]);
    }
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(value_12.bits[i], correct_answer_12.bits[i]);
    }
    s21_decimal value_01 = {{300, 0, 0, 0x00020000}};        //  
    s21_decimal value_02 = {{10, 0, 0, 0x00010000}};        //  sign = 0 scale = 1    value_2.bits[3] = 00000000 00000001 00000000 00000000
    s21_decimal correct_answer_01 = {{300, 0, 0, 0x00000000}};        //  sign = 0 scale = 1    value_2.bits[3] = 00000000 00000001 00000000 00000000
    s21_decimal correct_answer_02 = {{100, 0, 0, 0x00000000}};        //  sign = 0 scale = 1    value_2.bits[3] = 00000000 00000001 00000000 00000000
    ck_assert_int_eq(alignment_of_powers_of_decimal(&value_01, &value_02), 0);
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(value_01.bits[i], correct_answer_01.bits[i]);
    }
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(value_02.bits[i], correct_answer_02.bits[i]);
    }
    s21_decimal value_03 = {{10, 0, 0, 0x00010000}};        //  sign = 0 scale = 1    value_2.bits[3] = 00000000 00000001 00000000 00000000
    s21_decimal value_04 = {{300, 0, 0, 0x00020000}};        //  
    s21_decimal correct_answer_03 = {{100, 0, 0, 0x00000000}};        //  sign = 0 scale = 1    value_2.bits[3] = 00000000 00000001 00000000 00000000
    s21_decimal correct_answer_04 = {{300, 0, 0, 0x00000000}};        //  sign = 0 scale = 1    value_2.bits[3] = 00000000 00000001 00000000 00000000
    ck_assert_int_eq(alignment_of_powers_of_decimal(&value_03, &value_04), 0);
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(value_03.bits[i], correct_answer_03.bits[i]);
    }
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(value_04.bits[i], correct_answer_04.bits[i]);
    }
    s21_decimal value_05 = {{1000, 0, 0, 0x00020000}};        //  sign = 0 scale = 1    value_2.bits[3] = 00000000 00000001 00000000 00000000
    s21_decimal value_06 = {{300, 0, 0, 0x00020000}};        //  
    s21_decimal correct_answer_05 = {{1000, 0, 0, 0x00000000}};        //  sign = 0 scale = 1    value_2.bits[3] = 00000000 00000001 00000000 00000000
    s21_decimal correct_answer_06 = {{300, 0, 0, 0x00000000}};        //  sign = 0 scale = 1    value_2.bits[3] = 00000000 00000001 00000000 00000000
    ck_assert_int_eq(alignment_of_powers_of_decimal(&value_05, &value_06), 0);
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(value_05.bits[i], correct_answer_05.bits[i]);
    }
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(value_06.bits[i], correct_answer_06.bits[i]);
    }
    


#test BIG_REMOVE_EXTRA_ZERO
    s21_big_decimal tmp_value = {{0}};  
    s21_big_decimal value_01 = {{4294892416, 4294967295, 16711679, 0, 0, 0, 0, 0, 0, 0x80000000}};  // -308 276 084 001 730 439 550 000 000 == -308 276 084 001 730 439 550 000 000
    s21_big_decimal value_02 = {{4294892416, 4294967295, 16711679, 0, 0, 0, 0, 0, 0, 0x80040000}};  // -308 276 084 001 730 439 550 00,0 000 == -30 827 608 400 173 043 955 000
    s21_big_decimal value_03 = {{4294892416, 4294967295, 16711679, 0, 0, 0, 0, 0, 0, 0x80070000}};  // -308 276 084 001 730 439 55,0 000 000 == -30 827 608 400 173 043 955
    s21_big_decimal value_04 = {{4294892416, 4294967295, 16711679, 0, 0, 0, 0, 0, 0, 0x80080000}};  // -308 276 084 001 730 439 5,50 000 000 == -3 082 760 840 017 304 395,5
    s21_big_decimal value_05 = {{4294960000, 0, 0, 0, 0, 0, 0, 0, 0, 0x80000000}};  // -4294960000 == -4294960000
    s21_big_decimal value_06 = {{4294960000, 0, 0, 0, 0, 0, 0, 0, 0, 0x80020000}};  // -42949600,00 == -42949600
    s21_big_decimal value_07 = {{4294960000, 0, 0, 0, 0, 0, 0, 0, 0, 0x80040000}};  // -429496,0000 == -429496
    s21_big_decimal value_08 = {{4294960000, 0, 0, 0, 0, 0, 0, 0, 0, 0x80060000}};  // -4294,960000 == -4294,96
    s21_big_decimal value_09 = {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0x80000000}};           // -0 == -0
    s21_big_decimal value_10 = {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0x80060000}};           // -0,000000 == -0
    s21_big_decimal value_11 = {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};           //  0 == 0
    s21_big_decimal value_12 = {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0x00060000}};           //  0,000000 == 0
    s21_big_decimal value_13 = {{4294960000, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};  //  4294960000 == 4294960000
    s21_big_decimal value_14 = {{4294960000, 0, 0, 0, 0, 0, 0, 0, 0, 0x00020000}};  //  42949600,00 == 42949600
    s21_big_decimal value_15 = {{4294960000, 0, 0, 0, 0, 0, 0, 0, 0, 0x00040000}};  //  429496,0000 == 429496
    s21_big_decimal value_16 = {{4294960000, 0, 0, 0, 0, 0, 0, 0, 0, 0x00060000}};  //  4294,960000 == 4294,96
    s21_big_decimal value_17 = {{4294892416, 4294967295, 16711679, 0, 0, 0, 0, 0, 0, 0x00000000}};  // 308 276 084 001 730 439 550 000 000 == 308 276 084 001 730 439 550 000 000
    s21_big_decimal value_18 = {{4294892416, 4294967295, 16711679, 0, 0, 0, 0, 0, 0, 0x00040000}};  // 308 276 084 001 730 439 550 00,0 000 == 30 827 608 400 173 043 955 000
    s21_big_decimal correct_answer_01 = {{4294892416, 4294967295, 16711679, 0, 0, 0, 0, 0, 0, 0x80000000}};  // -308 276 084 001 730 439 550 000 000
    s21_big_decimal correct_answer_02 = {{3126736184, 721554505, 1671, 0, 0, 0, 0, 0, 0, 0x80000000}};       // -30 827 608 400 173 043 955 000
    s21_big_decimal correct_answer_03 = {{522817779, 2882644610, 1, 0, 0, 0, 0, 0, 0, 0x80000000}};          // -3 082 760 840 017 304 395,5
    s21_big_decimal correct_answer_04 = {{522817779, 2882644610, 1, 0, 0, 0, 0, 0, 0, 0x80010000}};          // -3 082 760 840 017 304 395,5
    s21_big_decimal correct_answer_05 = {{4294960000, 0, 0, 0, 0, 0, 0, 0, 0, 0x80000000}};           // -4294960000 == -4294960000
    s21_big_decimal correct_answer_06 = {{42949600, 0, 0, 0, 0, 0, 0, 0, 0, 0x80000000}};             // -42949600,00 == -42949600
    s21_big_decimal correct_answer_07 = {{429496, 0, 0, 0, 0, 0, 0, 0, 0, 0x80000000}};               // -429496,0000 == -429496
    s21_big_decimal correct_answer_08 = {{429496, 0, 0, 0, 0, 0, 0, 0, 0, 0x80020000}};               // -4294,960000 == -4294,96
    s21_big_decimal correct_answer_09 = {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0x80000000}};                    // -0 == -0
    s21_big_decimal correct_answer_10 = {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0x80000000}};                    // -0,000000 == -0
    s21_big_decimal correct_answer_11 = {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};                    // 0 == 0
    s21_big_decimal correct_answer_12 = {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};                    // 0,000000 == 0
    s21_big_decimal correct_answer_13 = {{4294960000, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};           //  4294960000 == 4294960000
    s21_big_decimal correct_answer_14 = {{42949600, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};             //  42949600,00 == 42949600
    s21_big_decimal correct_answer_15 = {{429496, 0, 0, 0, 0, 0, 0, 0, 0, 0x0000000}};                //  429496,0000 == 429496
    s21_big_decimal correct_answer_16 = {{429496, 0, 0, 0, 0, 0, 0, 0, 0, 0x00020000}};               //  4294,960000 == 4294,96
    s21_big_decimal correct_answer_17 = {{4294892416, 4294967295, 16711679, 0, 0, 0, 0, 0, 0, 0x00000000}};          // 308 276 084 001 730 439 5,50 000 000 == 3 082 760 840 017 304 395,5
    s21_big_decimal correct_answer_18 = {{3126736184, 721554505, 1671, 0, 0, 0, 0, 0, 0, 0x00000000}};          // 308 276 084 001 730 439 55,0 000 000 == 30 827 608 400 173 043 955
    copy_from_big_decimal_to_big_decimal(value_01, &tmp_value);
    big_remove_extra_zero(&tmp_value);
    for (int i = 0; i < 10; i++) {
        ck_assert_int_eq(tmp_value.bits[i], correct_answer_01.bits[i]);
    }
    copy_from_big_decimal_to_big_decimal(value_02, &tmp_value);
    big_remove_extra_zero(&tmp_value);
    for (int i = 0; i < 10; i++) {
        ck_assert_int_eq(tmp_value.bits[i], correct_answer_02.bits[i]);
    }
    copy_from_big_decimal_to_big_decimal(value_03, &tmp_value);
    big_remove_extra_zero(&tmp_value);
    // for (int i = 0; i < 10; i++) {
    //     ck_assert_int_eq(tmp_value.bits[i], correct_answer_03.bits[i]);
    // }
    ck_assert_int_eq(tmp_value.bits[0], correct_answer_03.bits[0]);
    ck_assert_int_eq(tmp_value.bits[1], correct_answer_03.bits[1]);
    ck_assert_int_eq(tmp_value.bits[2], correct_answer_03.bits[2]);
    ck_assert_int_eq(tmp_value.bits[3], correct_answer_03.bits[3]);
    copy_from_big_decimal_to_big_decimal(value_04, &tmp_value);
    big_remove_extra_zero(&tmp_value);
    for (int i = 0; i < 10; i++) {
        ck_assert_int_eq(tmp_value.bits[i], correct_answer_04.bits[i]);
    }
    copy_from_big_decimal_to_big_decimal(value_05, &tmp_value);
    big_remove_extra_zero(&tmp_value);
    for (int i = 0; i < 10; i++) {
        ck_assert_int_eq(tmp_value.bits[i], correct_answer_05.bits[i]);
    }
    copy_from_big_decimal_to_big_decimal(value_06, &tmp_value);
    big_remove_extra_zero(&tmp_value);
    for (int i = 0; i < 10; i++) {
        ck_assert_int_eq(tmp_value.bits[i], correct_answer_06.bits[i]);
    }
    copy_from_big_decimal_to_big_decimal(value_07, &tmp_value);
    big_remove_extra_zero(&tmp_value);
    for (int i = 0; i < 10; i++) {
        ck_assert_int_eq(tmp_value.bits[i], correct_answer_07.bits[i]);
    }
    copy_from_big_decimal_to_big_decimal(value_08, &tmp_value);
    big_remove_extra_zero(&tmp_value);
    for (int i = 0; i < 10; i++) {
        ck_assert_int_eq(tmp_value.bits[i], correct_answer_08.bits[i]);
    }
    copy_from_big_decimal_to_big_decimal(value_09, &tmp_value);
    big_remove_extra_zero(&tmp_value);
    for (int i = 0; i < 10; i++) {
        ck_assert_int_eq(tmp_value.bits[i], correct_answer_09.bits[i]);
    }
    copy_from_big_decimal_to_big_decimal(value_10, &tmp_value);
    big_remove_extra_zero(&tmp_value);
    for (int i = 0; i < 10; i++) {
        ck_assert_int_eq(tmp_value.bits[i], correct_answer_10.bits[i]);
    }
    copy_from_big_decimal_to_big_decimal(value_11, &tmp_value);
    big_remove_extra_zero(&tmp_value);
    for (int i = 0; i < 10; i++) {
        ck_assert_int_eq(tmp_value.bits[i], correct_answer_11.bits[i]);
    }
    copy_from_big_decimal_to_big_decimal(value_12, &tmp_value);
    big_remove_extra_zero(&tmp_value);
    for (int i = 0; i < 10; i++) {
        ck_assert_int_eq(tmp_value.bits[i], correct_answer_12.bits[i]);
    }
    copy_from_big_decimal_to_big_decimal(value_13, &tmp_value);
    big_remove_extra_zero(&tmp_value);
    for (int i = 0; i < 10; i++) {
        ck_assert_int_eq(tmp_value.bits[i], correct_answer_13.bits[i]);
    }
    copy_from_big_decimal_to_big_decimal(value_14, &tmp_value);
    big_remove_extra_zero(&tmp_value);
    for (int i = 0; i < 10; i++) {
        ck_assert_int_eq(tmp_value.bits[i], correct_answer_14.bits[i]);
    }
    copy_from_big_decimal_to_big_decimal(value_15, &tmp_value);
    big_remove_extra_zero(&tmp_value);
    for (int i = 0; i < 10; i++) {
        ck_assert_int_eq(tmp_value.bits[i], correct_answer_15.bits[i]);
    }
    copy_from_big_decimal_to_big_decimal(value_16, &tmp_value);
    big_remove_extra_zero(&tmp_value);
    for (int i = 0; i < 10; i++) {
        ck_assert_int_eq(tmp_value.bits[i], correct_answer_16.bits[i]);
    }
    copy_from_big_decimal_to_big_decimal(value_17, &tmp_value);
    big_remove_extra_zero(&tmp_value);
    for (int i = 0; i < 10; i++) {
        ck_assert_int_eq(tmp_value.bits[i], correct_answer_17.bits[i]);
    }
    copy_from_big_decimal_to_big_decimal(value_18, &tmp_value);
    big_remove_extra_zero(&tmp_value);
    for (int i = 0; i < 10; i++) {
        ck_assert_int_eq(tmp_value.bits[i], correct_answer_18.bits[i]);
    }



#test VALUE_TYPE
    s21_decimal value_01 = {{4294967295, 4294967295, 4294967295, 0x80000000}};  // -79 228 162 514 264 337 593 543 950 335
    s21_decimal value_02 = {{0, 4294967295, 0, 0x80000000}};                    // -18 446 744 069 414 584 320
    s21_decimal value_03 = {{1, 0, 0, 0x80000000}};                             // -1
    s21_decimal value_04 = {{0, 0, 0, 0x00000000}};                             //  0
    s21_decimal value_05 = {{4294967295, 4294967295, 4294967295, 0x00000000}};  //  79 228 162 514 264 337 593 543 950 335
    s21_decimal value_06 = {{0, 0, 0, 0x80FF0000}};                             // -INF
    s21_decimal value_07 = {{0, 0, 0, 0x00FF0000}};                             // +INF
    s21_decimal value_08 = {{1431655765, 1431655765, 1431655765, 0x80FF0000}};  //  NaN (диапазон от (-1)*10^(-28) до (-1)*10^(-28), но !=0)
    ck_assert_int_eq(value_type(value_01), 0);           // -79 228 162 514 264 337 593 543 950 335 => 0
    ck_assert_int_eq(value_type(value_02), 0);           // -18 446 744 069 414 584 320 => 0
    ck_assert_int_eq(value_type(value_03), 0);           // -1 => 0
    ck_assert_int_eq(value_type(value_04), 0);           // 0 => 0
    ck_assert_int_eq(value_type(value_05), 0);           // 79 228 162 514 264 337 593 543 950 335 => 0
    ck_assert_int_eq(value_type(value_06), 2);           // -INF => 2
    ck_assert_int_eq(value_type(value_07), 1);           // +INF => 1
    ck_assert_int_eq(value_type(value_08), 3);           // NaN => 3
    

#test NUM_IS_ZERO
    s21_decimal value_01 = {{4294967295, 4294967295, 4294967295, 0x80000000}};  // -79 228 162 514 264 337 593 543 950 335
    s21_decimal value_07 = {{4294967295, 0, 0, 0x80000000}};                    // -4 294 967 295
    s21_decimal value_08 = {{2147483647, 0, 0, 0x80000000}};                    // -2 147 483 647
    s21_decimal value_09 = {{1, 0, 0, 0x80000000}};                             // -1
    s21_decimal value_10 = {{0, 0, 0, 0x80000000}};                             // -0
    s21_decimal value_11 = {{0, 0, 0, 0x00000000}};                             //  0
    s21_decimal value_12 = {{1, 0, 0, 0x00000000}};                             //  1
    s21_decimal value_16 = {{4294967295, 4294967295, 0, 0x00000000}};           //  18 446 744 073 709 551 615
    s21_decimal value_17 = {{4294967295, 4294967295, 536870911, 0x00000000}};   //  9 903 520 314 283 042 199 192 993 791
    s21_decimal value_20 = {{4294967295, 4294967295, 4294967295, 0x00000000}};  //  79 228 162 514 264 337 593 543 950 335
    s21_decimal value_21 = {{0, 0, 0, 0x80FF0000}};                             // -INF
    s21_decimal value_22 = {{0, 0, 0, 0x00FF0000}};                             // +INF
    s21_decimal value_23 = {{1431655765, 1431655765, 1431655765, 0x80FF0000}};  //  NaN (диапазон от (-1)*10^(-28) до (-1)*10^(-28), но !=0)
    ck_assert_int_eq(num_is_zero(value_01), 0);  // 0 == 0 : -79 228 162 514 264 337 593 543 950 335 != 0
    ck_assert_int_eq(num_is_zero(value_07), 0);  // 0 == 0 : -4 294 967 295 != 0
    ck_assert_int_eq(num_is_zero(value_08), 0);  // 0 == 0 : -2 147 483 647 != 0
    ck_assert_int_eq(num_is_zero(value_09), 0);  // 0 == 0 : -1 != 0
    ck_assert_int_eq(num_is_zero(value_10), 1);  // 1 == 1 : -0 == 0
    ck_assert_int_eq(num_is_zero(value_11), 1);  // 1 == 1 :  0 == 0
    ck_assert_int_eq(num_is_zero(value_12), 0);  // 0 == 0 :  1 != 0
    ck_assert_int_eq(num_is_zero(value_16), 0);  // 0 == 0 :  18 446 744 073 709 551 615 != 0
    ck_assert_int_eq(num_is_zero(value_17), 0);  // 0 == 0 :  9 903 520 314 283 042 199 192 993 791 != 0
    ck_assert_int_eq(num_is_zero(value_20), 0);  // 0 == 0 :  79 228 162 514 264 337 593 543 950 335 != 0
    ck_assert_int_eq(num_is_zero(value_21), 0);  // 0 == 0 : -INF != 0
    ck_assert_int_eq(num_is_zero(value_22), 0);  // 0 == 0 : +INF != 0
    ck_assert_int_eq(num_is_zero(value_23), 0);  // 0 == 0 :  NaN != 0


#test SHIFT_LEFT_1_BITS
    s21_decimal value_01 = {{15, 0, 0, 0x00000000}};
    s21_decimal value_02 = {{4294967295, 4294967295, 4294967295, 0x00000000}};
    s21_decimal correct_answer_01 = {{30, 0, 0, 0x00000000}};
    shift_left_1_bits(&value_01);
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(value_01.bits[i], correct_answer_01.bits[i]);
    }
    ck_assert_int_eq(shift_left_1_bits(&value_02), 1);



#test S21_SHIFT_LEFT_3_BITS
    s21_decimal value_01 = {{15, 0, 0, 0x00000000}};
    s21_decimal value_02 = {{4294967295, 4294967295, 4294967295, 0x00000000}};
    s21_decimal value_03 = {{4294967295, 4294967295, 2147483647, 0x00000000}};
    s21_decimal value_04 = {{4294967295, 4294967295, 1073741823, 0x00000000}};
    s21_decimal correct_answer_01 = {{120, 0, 0, 0x00000000}};
    shift_left_3_bits(&value_01);
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(value_01.bits[i], correct_answer_01.bits[i]);
    }
    ck_assert_int_eq(shift_left_3_bits(&value_02), 1);
    ck_assert_int_eq(shift_left_3_bits(&value_03), 1);
    ck_assert_int_eq(shift_left_3_bits(&value_04), 1);



#test SHIFT_RIGHT_1_BITS
    s21_decimal value_01 = {{0, 0, 4294967295, 0x00000000}};
    s21_decimal value_02 = {{0, 0, 2147483648, 0x00000000}};
    s21_decimal correct_answer_01 = {{0, 2147483648, 2147483647, 0x00000000}};
    s21_decimal correct_answer_02 = {{0, 0, 1073741824, 0x00000000}};
    shift_right_1_bits(&value_01);
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(value_01.bits[i], correct_answer_01.bits[i]);
    }
    shift_right_1_bits(&value_02);
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(value_02.bits[i], correct_answer_02.bits[i]);
    }



#test SHIFT_RIGHT_3_BITS
    s21_decimal value_01 = {{0, 0, 4294967295, 0x00000000}};
    s21_decimal correct_answer_01 = {{0, 3758096384, 536870911, 0x00000000}};
    shift_right_3_bits(&value_01);
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(value_01.bits[i], correct_answer_01.bits[i]);
    }



#test BIG_SHIFT_RIGHT_3_BITS
    s21_big_decimal value_01 = {{2345, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};
    s21_big_decimal correct_answer_01 = {{293, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};
    big_shift_right_3_bits(&value_01);
    for (int i = 0; i < 10; i++) {
        ck_assert_int_eq(value_01.bits[i], correct_answer_01.bits[i]);
    }



#test MUL_BY_TEN
    s21_decimal tmp_value = {{0}};                                              // 0
    s21_decimal value_07 = {{4294967295, 0, 0, 0x80000000}};                    // -4 294 967 295
    s21_decimal value_12 = {{1, 0, 0, 0x00000000}};                             //  1
    s21_decimal value_14 = {{4294967295, 0, 0, 0x00000000}};                    //  4 294 967 295
    s21_decimal value_01 = {{4294967295, 4294967295, 4294967295, 0x00000000}};  //
    s21_decimal value_02 = {{4294967295, 4294967295, 4294967295, 0x80000000}};  //
    s21_decimal correct_answer_01 = {{10, 0, 0, 0x00010000}};                   //  1 * 10^1  = 10
    s21_decimal correct_answer_02 = {{4294966296, 999, 0, 0x00030000}};         //  4294967295 * 10^3 = 11 11100111 11111111 11111111 11111100 00011000
    s21_decimal correct_answer_03 = {{4294966296, 999, 0, 0x80030000}};         //  4294967295 * 10^3 = 11 11100111 11111111 11111111 11111100 00011000
    copy_from_decimal_to_decimal(value_12, &tmp_value);  //  1 * 10^1
    mul_by_ten(&tmp_value, 1);
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(tmp_value.bits[i], correct_answer_01.bits[i]);
    }
    copy_from_decimal_to_decimal(value_14, &tmp_value);  //  4294967295 * 10^3 = 4294967295000 = 00000011 11100111  11111111 11111111 11111100 00011000
    mul_by_ten(&tmp_value, 3);
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(tmp_value.bits[i], correct_answer_02.bits[i]);
    }
    copy_from_decimal_to_decimal(value_07, &tmp_value);  // -4294967295 * 10^3
    mul_by_ten(&tmp_value, 3);
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(tmp_value.bits[i], correct_answer_03.bits[i]);
    }
    copy_from_decimal_to_decimal(value_01, &tmp_value);  // -4294967295 * 10^3
    mul_by_ten(&tmp_value, 1);
    ck_assert_int_eq(num_is_inf(tmp_value), 1);
    copy_from_decimal_to_decimal(value_02, &tmp_value);  // -4294967295 * 10^3
    mul_by_ten(&tmp_value, 1);
    ck_assert_int_eq(num_is_n_inf(tmp_value), 1);
   


#test MUL_BY_TEN_CHANGE_SCALE
    s21_decimal tmp_value = {{0}};                                              // 0
    s21_decimal value_01 = {{4294967295, 4294967295, 4294967295, 0x80000000}};  // -79 228 162 514 264 337 593 543 950 335
    s21_decimal value_08 = {{2147483647, 0, 0, 0x80000000}};                    // -2 147 483 647
    s21_decimal value_09 = {{1, 0, 0, 0x80000000}};                             // -1
    s21_decimal value_10 = {{0, 0, 0, 0x80000000}};                             // -0
    s21_decimal value_11 = {{0, 0, 0, 0x00000000}};                             //  0
    s21_decimal value_12 = {{1, 0, 0, 0x00000000}};                             //  1
    s21_decimal value_13 = {{2147483647, 0, 0, 0}};                             //  2 147 483 647
    s21_decimal value_19 = {{0, 4294967295, 4294967295, 0x00000000}};           //  79 228 162 514 264 337 589 248 983 040
    s21_decimal value_21 = {{0, 0, 0, 0x80FF0000}};                             // -INF
    s21_decimal value_22 = {{0, 0, 0, 0x00FF0000}};                             // +INF
    s21_decimal correct_answer_01 = {{1000000, 0, 0, 0x00000000}};              //  1 * 10^6  = 1111 01000010 01000000
    s21_decimal correct_answer_02 = {{1410065408, 2, 0, 0x00000000}};           //  1 * 10^10 = 10  01010100 00001011 11100100 00000000
    s21_decimal correct_answer_03 = {{1661992960, 1808227885, 5, 0x00000000}};  //  1 * 10^20 = 101  01101011 11000111 01011110 00101101  01100011 00010000 00000000 00000000
    s21_decimal correct_answer_04 = {{2147483647, 0, 0, 0x00020000}};           //  214748,3647 * 10^2 =  21474836,47
    s21_decimal correct_answer_05 = {{2147483647, 0, 0, 0x80020000}};           // -214748,3647 * 10^2 = -21474836,47
    s21_decimal correct_answer_06 = {{4294967196, 49, 0, 0x00000000}};          //  21474836,47 * 10^4 =  214748364700
    s21_decimal correct_answer_07 = {{4294967196, 49, 0, 0x80000000}};          // -21474836,47 * 10^4 = -214748364700   11 0001 11111111 11111111 11111111 10011100
    s21_decimal correct_answer_08 = {{0, 0, 0, 0x00000000}};                    //  0 * 10^4 = 0
    s21_decimal correct_answer_09 = {{0, 0, 0, 0x00000000}};                    // -0 * 10^4 = 0
    copy_from_decimal_to_decimal(value_12, &tmp_value);  // 1 * 10^6
    mul_by_ten_change_scale(&tmp_value, 6);
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(tmp_value.bits[i], correct_answer_01.bits[i]);
    }
    copy_from_decimal_to_decimal(value_12, &tmp_value);  // 1 * 10^10
    mul_by_ten_change_scale(&tmp_value, 10);
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(tmp_value.bits[i], correct_answer_02.bits[i]);
    }
    copy_from_decimal_to_decimal(value_12, &tmp_value);  // 1 * 10^20
    mul_by_ten_change_scale(&tmp_value, 20);
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(tmp_value.bits[i], correct_answer_03.bits[i]);
    }
    copy_from_decimal_to_decimal(value_13, &tmp_value);  // 214748,3647 * 10^2
    set_scale(&tmp_value, 4);
    mul_by_ten_change_scale(&tmp_value, 2);
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(tmp_value.bits[i], correct_answer_04.bits[i]);
    }
    copy_from_decimal_to_decimal(value_08, &tmp_value);  // -214748,3647 * 10^2
    set_scale(&tmp_value, 4);
    mul_by_ten_change_scale(&tmp_value, 2);
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(tmp_value.bits[i], correct_answer_05.bits[i]);
    }
    copy_from_decimal_to_decimal(value_13, &tmp_value);  // 21474836,47 * 10^4
    set_scale(&tmp_value, 2);
    mul_by_ten_change_scale(&tmp_value, 4);
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(tmp_value.bits[i], correct_answer_06.bits[i]);
    }
    copy_from_decimal_to_decimal(value_08, &tmp_value);  // -21474836,47 * 10^4
    set_scale(&tmp_value, 2);
    mul_by_ten_change_scale(&tmp_value, 4);
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(tmp_value.bits[i], correct_answer_07.bits[i]);
    }
    copy_from_decimal_to_decimal(value_11, &tmp_value);  // 0 * 10^4
    mul_by_ten_change_scale(&tmp_value, 4);
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(tmp_value.bits[i], correct_answer_08.bits[i]);
    }
    copy_from_decimal_to_decimal(value_11, &tmp_value);  // 0 * 10^4
    set_scale(&tmp_value, 2);
    mul_by_ten_change_scale(&tmp_value, 4);
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(tmp_value.bits[i], correct_answer_08.bits[i]);
    }
    copy_from_decimal_to_decimal(value_10, &tmp_value);  // -0 * 10^4
    mul_by_ten_change_scale(&tmp_value, 4);
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(tmp_value.bits[i], correct_answer_09.bits[i]);
    }
    copy_from_decimal_to_decimal(value_10, &tmp_value);  // -0 * 10^4
    set_scale(&tmp_value, 2);
    mul_by_ten_change_scale(&tmp_value, 4);
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(tmp_value.bits[i], correct_answer_09.bits[i]);
    }
    copy_from_decimal_to_decimal(value_12, &tmp_value);  // 1 * 10^30 == +INF
    mul_by_ten_change_scale(&tmp_value, 30);
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(tmp_value.bits[i], value_22.bits[i]);
    }
    copy_from_decimal_to_decimal(value_09, &tmp_value);  // -1 * 10^30 == -INF
    mul_by_ten_change_scale(&tmp_value, 30);
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(tmp_value.bits[i], value_21.bits[i]);
    }
    copy_from_decimal_to_decimal(value_01, &tmp_value);  // -INF
    mul_by_ten_change_scale(&tmp_value, 1);
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(tmp_value.bits[i], value_21.bits[i]);
    }
    copy_from_decimal_to_decimal(value_19, &tmp_value);  // +INF
    mul_by_ten_change_scale(&tmp_value, 1);
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(tmp_value.bits[i], value_22.bits[i]);
    }



#test DIV_BY_TEN
    s21_decimal result = {{0}};                                                     //  0
    s21_decimal value_01 = {{952, 0, 0, 0x00000000}};                               //  952
    s21_decimal value_02 = {{145, 0, 0, 0x00010000}};                               //  14,5
    s21_decimal value_03 = {{952, 0, 0, 0x80000000}};                               // -952
    s21_decimal value_04 = {{952, 0, 0, 0x80000000}};                               // -952
    s21_decimal correct_answer_01 = {{952, 0, 0, 0x00010000}};                      //  95,2
    s21_decimal correct_answer_02 = {{145, 0, 0, 0x00020000}};                      //  1,45
    s21_decimal correct_answer_03 = {{952, 0, 0, 0x80010000}};                      // -95,2
    s21_decimal correct_answer_04 = {{952, 0, 0, 0x80020000}};                      // -9,52
    copy_from_decimal_to_decimal(value_01, &result);
    div_by_ten(&result, 1);
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_01.bits[i]);
    }
    copy_from_decimal_to_decimal(value_02, &result);
    div_by_ten(&result, 1);
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_02.bits[i]);
    }
    copy_from_decimal_to_decimal(value_03, &result);
    div_by_ten(&result, 1);
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_03.bits[i]);
    }
    copy_from_decimal_to_decimal(value_04, &result);
    div_by_ten(&result, 2);
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_04.bits[i]);
    }



#test DIV_BY_TEN_CHANGE_SCALE
    s21_decimal result = {{0}};                                                     //  0
    s21_decimal value_01 = {{952, 0, 0, 0x00010000}};                               //  952
    s21_decimal value_02 = {{145, 0, 0, 0x00000000}};                               //  14,5
    s21_decimal correct_answer_01 = {{952, 0, 0, 0x00020000}};                      //  95,2
    s21_decimal correct_answer_02 = {{145, 0, 0, 0x00020000}};                      //  1,45
    copy_from_decimal_to_decimal(value_01, &result);
    div_by_ten_change_scale(&result, 1);
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_01.bits[i]);
    }
    copy_from_decimal_to_decimal(value_02, &result);
    div_by_ten(&result, 2);
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_02.bits[i]);
    }



#test BIG_DIV_BY_TEN
    s21_big_decimal result = {{0}};                                                     //  0
    s21_big_decimal value_01 = {{952, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};             //  952
    s21_big_decimal value_02 = {{145, 0, 0, 0, 0, 0, 0, 0, 0, 0x00010000}};             //  14,5
    s21_big_decimal correct_answer_01 = {{95, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};    //  95,2
    s21_big_decimal correct_answer_02 = {{14, 0, 0, 0, 0, 0, 0, 0, 0, 0x00010000}};    //  1,45
    copy_from_big_decimal_to_big_decimal(value_01, &result);
    big_div_by_ten(&result, 1);
    for (int i = 0; i < 10; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_01.bits[i]);
    }
    copy_from_big_decimal_to_big_decimal(value_02, &result);
    big_div_by_ten(&result, 1);
    for (int i = 0; i < 10; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_02.bits[i]);
    }



#test NUM_IS_INF
    s21_decimal value_01 = {{0, 0, 0, 0x80FF0000}};                             // -INF
    s21_decimal value_02 = {{0, 0, 0, 0x00FF0000}};                             // +INF
    s21_decimal value_03 = {{0, 3, 0, 0x80FF0000}};                             //  NaN (диапазон от (-1)*10^(-28) до (-1)*10^(-28), но !=0)
    s21_decimal value_04 = {{0, 3, 0, 0x00FF0000}};                             //  NaN (диапазон от (-1)*10^(-28) до (-1)*10^(-28), но !=0)
    s21_decimal value_05 = {{0, 0, 0, 0x00000000}};                             //  0
    s21_decimal value_06 = {{546, 0, 0, 0x00000000}};                           //  546
    s21_decimal value_07 = {{546, 0, 0, 0x80000000}};                           // -546
    s21_decimal value_08 = {{812, 0, 0, 0x00060000}};                           //  0,000812
    s21_decimal value_09 = {{812, 0, 0, 0x80060000}};                           // -0,000812
    ck_assert_int_eq(num_is_inf(value_01), 0);
    ck_assert_int_eq(num_is_inf(value_02), 1);
    ck_assert_int_eq(num_is_inf(value_03), 0);
    ck_assert_int_eq(num_is_inf(value_04), 0);
    ck_assert_int_eq(num_is_inf(value_05), 0);
    ck_assert_int_eq(num_is_inf(value_06), 0);
    ck_assert_int_eq(num_is_inf(value_07), 0);
    ck_assert_int_eq(num_is_inf(value_08), 0);
    ck_assert_int_eq(num_is_inf(value_09), 0);



#test NUM_IS_N_INF
    s21_decimal value_01 = {{0, 0, 0, 0x80FF0000}};                             // -INF
    s21_decimal value_02 = {{0, 0, 0, 0x00FF0000}};                             // +INF
    s21_decimal value_03 = {{0, 3, 0, 0x80FF0000}};                             //  NaN (диапазон от (-1)*10^(-28) до (-1)*10^(-28), но !=0)
    s21_decimal value_04 = {{0, 3, 0, 0x00FF0000}};                             //  NaN (диапазон от (-1)*10^(-28) до (-1)*10^(-28), но !=0)
    s21_decimal value_05 = {{0, 0, 0, 0x00000000}};                             //  0
    s21_decimal value_06 = {{546, 0, 0, 0x00000000}};                           //  546
    s21_decimal value_07 = {{546, 0, 0, 0x80000000}};                           // -546
    s21_decimal value_08 = {{812, 0, 0, 0x00060000}};                           //  0,000812
    s21_decimal value_09 = {{812, 0, 0, 0x80060000}};                           // -0,000812
    ck_assert_int_eq(num_is_n_inf(value_01), 1);
    ck_assert_int_eq(num_is_n_inf(value_02), 0);
    ck_assert_int_eq(num_is_n_inf(value_03), 0);
    ck_assert_int_eq(num_is_n_inf(value_04), 0);
    ck_assert_int_eq(num_is_n_inf(value_05), 0);
    ck_assert_int_eq(num_is_n_inf(value_06), 0);
    ck_assert_int_eq(num_is_n_inf(value_07), 0);
    ck_assert_int_eq(num_is_n_inf(value_08), 0);
    ck_assert_int_eq(num_is_n_inf(value_09), 0);



#test NUM_IS_NAN
    s21_decimal value_01 = {{0, 0, 0, 0x80FF0000}};                             // -INF
    s21_decimal value_02 = {{0, 0, 0, 0x00FF0000}};                             // +INF
    s21_decimal value_03 = {{0, 3, 0, 0x80FF0000}};                             //  NaN (диапазон от (-1)*10^(-28) до (-1)*10^(-28), но !=0)
    s21_decimal value_04 = {{0, 3, 0, 0x00FF0000}};                             //  NaN (диапазон от (-1)*10^(-28) до (-1)*10^(-28), но !=0)
    s21_decimal value_05 = {{0, 0, 0, 0x00000000}};                             //  0
    s21_decimal value_06 = {{546, 0, 0, 0x00000000}};                           //  546
    s21_decimal value_07 = {{546, 0, 0, 0x80000000}};                           // -546
    s21_decimal value_08 = {{812, 0, 0, 0x00060000}};                           //  0,000812
    s21_decimal value_09 = {{812, 0, 0, 0x80060000}};                           // -0,000812
    ck_assert_int_eq(num_is_nan(value_01), 0);
    ck_assert_int_eq(num_is_nan(value_02), 0);
    ck_assert_int_eq(num_is_nan(value_03), 1);
    ck_assert_int_eq(num_is_nan(value_04), 1);
    ck_assert_int_eq(num_is_nan(value_05), 0);
    ck_assert_int_eq(num_is_nan(value_06), 0);
    ck_assert_int_eq(num_is_nan(value_07), 0);
    ck_assert_int_eq(num_is_nan(value_08), 0);
    ck_assert_int_eq(num_is_nan(value_09), 0);



#test BIG_NUM_IS_INF
    s21_big_decimal value_01 = {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0x80FF0000}};                             // -INF
    s21_big_decimal value_02 = {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0x00FF0000}};                             // +INF
    s21_big_decimal value_03 = {{0, 3, 0, 0, 0, 0, 0, 0, 0, 0x80FF0000}};                             //  NaN (диапазон от (-1)*10^(-28) до (-1)*10^(-28), но !=0)
    s21_big_decimal value_04 = {{0, 3, 0, 0, 0, 0, 0, 0, 0, 0x00FF0000}};                             //  NaN (диапазон от (-1)*10^(-28) до (-1)*10^(-28), но !=0)
    s21_big_decimal value_05 = {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};                             //  0
    s21_big_decimal value_06 = {{546, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};                           //  546
    s21_big_decimal value_07 = {{546, 0, 0, 0, 0, 0, 0, 0, 0, 0x80000000}};                           // -546
    s21_big_decimal value_08 = {{812, 0, 0, 0, 0, 0, 0, 0, 0, 0x00060000}};                           //  0,000812
    s21_big_decimal value_09 = {{812, 0, 0, 0, 0, 0, 0, 0, 0, 0x80060000}};                           // -0,000812
    ck_assert_int_eq(big_num_is_inf(value_01), 0);
    ck_assert_int_eq(big_num_is_inf(value_02), 1);
    ck_assert_int_eq(big_num_is_inf(value_03), 0);
    ck_assert_int_eq(big_num_is_inf(value_04), 0);
    ck_assert_int_eq(big_num_is_inf(value_05), 0);
    ck_assert_int_eq(big_num_is_inf(value_06), 0);
    ck_assert_int_eq(big_num_is_inf(value_07), 0);
    ck_assert_int_eq(big_num_is_inf(value_08), 0);
    ck_assert_int_eq(big_num_is_inf(value_08), 0);
    ck_assert_int_eq(big_num_is_inf(value_09), 0);



#test BIG_NUM_IS_N_INF
    s21_big_decimal value_01 = {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0x80FF0000}};                             // -INF
    s21_big_decimal value_02 = {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0x00FF0000}};                             // +INF
    s21_big_decimal value_03 = {{0, 3, 0, 0, 0, 0, 0, 0, 0, 0x80FF0000}};                             //  NaN (диапазон от (-1)*10^(-28) до (-1)*10^(-28), но !=0)
    s21_big_decimal value_04 = {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};                             //  0
    s21_big_decimal value_05 = {{546, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};                           //  546
    s21_big_decimal value_06 = {{546, 0, 0, 0, 0, 0, 0, 0, 0, 0x80000000}};                           // -546
    s21_big_decimal value_07 = {{812, 0, 0, 0, 0, 0, 0, 0, 0, 0x00060000}};                           //  0,000812
    s21_big_decimal value_08 = {{812, 0, 0, 0, 0, 0, 0, 0, 0, 0x80060000}};                           // -0,000812
    ck_assert_int_eq(big_num_is_n_inf(value_01), 1);
    ck_assert_int_eq(big_num_is_n_inf(value_02), 0);
    ck_assert_int_eq(big_num_is_n_inf(value_03), 0);
    ck_assert_int_eq(big_num_is_n_inf(value_04), 0);
    ck_assert_int_eq(big_num_is_n_inf(value_05), 0);
    ck_assert_int_eq(big_num_is_n_inf(value_06), 0);
    ck_assert_int_eq(big_num_is_n_inf(value_07), 0);
    ck_assert_int_eq(big_num_is_n_inf(value_08), 0);



#test BIG_NUM_IS_NAN
    s21_big_decimal value_01 = {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0x80FF0000}};                             // -INF
    s21_big_decimal value_02 = {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0x00FF0000}};                             // +INF
    s21_big_decimal value_03 = {{0, 3, 0, 0, 0, 0, 0, 0, 0, 0x80FF0000}};                             //  NaN (диапазон от (-1)*10^(-28) до (-1)*10^(-28), но !=0)
    s21_big_decimal value_04 = {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};                             //  0
    s21_big_decimal value_05 = {{546, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};                           //  546
    s21_big_decimal value_06 = {{546, 0, 0, 0, 0, 0, 0, 0, 0, 0x80000000}};                           // -546
    s21_big_decimal value_07 = {{812, 0, 0, 0, 0, 0, 0, 0, 0, 0x00060000}};                           //  0,000812
    s21_big_decimal value_08 = {{812, 0, 0, 0, 0, 0, 0, 0, 0, 0x80060000}};                           // -0,000812
    ck_assert_int_eq(big_num_is_nan(value_01), 0);
    ck_assert_int_eq(big_num_is_nan(value_02), 0);
    ck_assert_int_eq(big_num_is_nan(value_03), 1);
    ck_assert_int_eq(big_num_is_nan(value_04), 0);
    ck_assert_int_eq(big_num_is_nan(value_05), 0);
    ck_assert_int_eq(big_num_is_nan(value_06), 0);
    ck_assert_int_eq(big_num_is_nan(value_07), 0);
    ck_assert_int_eq(big_num_is_nan(value_08), 0);



#test SET_NUMBER_IS_NOT_A_NUMBER
    s21_decimal result = {{0}};                                                 //  0
    s21_decimal value_01 = {{546, 0, 0, 0x00000000}};                           //  546
    s21_decimal value_02 = {{546, 0, 0, 0x80000000}};                           // -546
    decimal_reset(&result);
    copy_from_decimal_to_decimal(value_01, &result);
    ck_assert_int_eq(set_number_is_not_a_number(&result, 1), 0);
    ck_assert_int_eq(num_is_nan(result), 1);
    decimal_reset(&result);
    copy_from_decimal_to_decimal(value_02, &result);
    ck_assert_int_eq(set_number_is_not_a_number(&result, 0), 0);
    ck_assert_int_eq(num_is_nan(result), 1);



#test BIG_IS_GREATER
    s21_big_decimal value_01 = {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};
    s21_big_decimal value_02 = {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};
    ck_assert_int_eq(big_is_greater(value_01, value_02), 0);
    s21_big_decimal value_03 = {{10, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};
    s21_big_decimal value_04 = {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};
    ck_assert_int_eq(big_is_greater(value_03, value_04), 1);
    s21_big_decimal value_05 = {{10, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};
    s21_big_decimal value_06 = {{100, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};
    ck_assert_int_eq(big_is_greater(value_05, value_06), 0);
    s21_big_decimal value_07 = {{10, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};
    s21_big_decimal value_08 = {{100, 0, 0, 0, 0, 0, 0, 0, 0, 0x80000000}};
    ck_assert_int_eq(big_is_greater(value_07, value_08), 1);
    s21_big_decimal value_09 = {{1000, 0, 0, 0, 0, 0, 0, 0, 0, 0x80000000}};
    s21_big_decimal value_10 = {{100, 0, 0, 0, 0, 0, 0, 0, 0, 0x80000000}};
    ck_assert_int_eq(big_is_greater(value_09, value_10), 0);
    s21_big_decimal value_11 = {{1000, 0, 0, 0, 0, 0, 0, 0, 0, 0x80000000}};
    s21_big_decimal value_12 = {{100, 0, 0, 0, 0, 0, 0, 0, 0, 0x80000000}};
    ck_assert_int_eq(big_is_greater(value_11, value_12), 0);
    s21_big_decimal value_13 = {{10, 0, 0, 0, 0, 0, 0, 0, 0, 0x80020000}};
    s21_big_decimal value_14 = {{100, 0, 0, 0, 0, 0, 0, 0, 0, 0x80020000}};
    ck_assert_int_eq(big_is_greater(value_13, value_14), 1);
    s21_big_decimal value_15 = {{4294967295, 4294967295, 4294967295, 0, 0, 0, 0, 0, 0, 0x00020000}};
    s21_big_decimal value_16 = {{4294967295, 4294967295, 4294967295, 0, 0, 0, 0, 0, 0, 0x00000000}};
    ck_assert_int_eq(big_is_greater(value_15, value_16), 0);
    s21_big_decimal value_17 = {{4294967196, 4294967295, 4294967295, 99, 0, 0, 0, 0, 0, 0x00020000}};          //  79 228 162 514 264 337 593 543 950 335,00 = 1100011  11111111 11111111 11111111 11111111  11111111 11111111 11111111 11111111  11111111 11111111 11111111 10011100
    s21_big_decimal value_18 = {{4294967295, 4294967295, 4294967295, 0, 0, 0, 0, 0, 0, 0x00000000}};           //  79 228 162 514 264 337 593 543 950 335
    ck_assert_int_eq(big_is_greater(value_17, value_18), 0);
    s21_big_decimal value_19 = {{4294967096, 4294967295, 4294967295, 99, 0, 0, 0, 0, 0, 0x00020000}};          //  79 228 162 514 264 337 593 543 950 334,00 = 1100011  11111111 11111111 11111111 11111111  11111111 11111111 11111111 11111111  11111111 11111111 11111111 00111000
    s21_big_decimal value_20 = {{4294967295, 4294967295, 4294967295, 0, 0, 0, 0, 0, 0, 0x00000000}};           //  79 228 162 514 264 337 593 543 950 335
    ck_assert_int_eq(big_is_greater(value_19, value_20), 0);
    s21_big_decimal value_21 = {{1, 0, 0, 0, 0, 0, 0, 0, 0, 0x001C0000}};          //  0,000 000 000 000 000 000 000 000 000 01
    s21_big_decimal value_22 = {{1, 0, 0, 0, 0, 0, 0, 0, 0, 0x001B0000}};          //  0,000 000 000 000 000 000 000 000 000 1
    ck_assert_int_eq(big_is_greater(value_21, value_22), 0);
    s21_big_decimal value_23 = {{1, 0, 0, 0, 0, 0, 0, 0, 0, 0x001B0000}};          //  0,000 000 000 000 000 000 000 000 000 1
    s21_big_decimal value_24 = {{1, 0, 0, 0, 0, 0, 0, 0, 0, 0x001C0000}};          //  0,000 000 000 000 000 000 000 000 000 01
    ck_assert_int_eq(big_is_greater(value_23, value_24), 1);
    s21_big_decimal value_25 = {{1, 0, 0, 0, 0, 0, 0, 0, 0, 0x001D0000}};          //  0,000 000 000 000 000 000 000 000 000 001
    s21_big_decimal value_26 = {{1, 0, 0, 0, 0, 0, 0, 0, 0, 0x001C0000}};          //  0,000 000 000 000 000 000 000 000 000 01
    ck_assert_int_eq(big_is_greater(value_25, value_26), 0);



#test BIG_IS_EQUAL
    s21_big_decimal value_01 = {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};
    s21_big_decimal value_02 = {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};
    ck_assert_int_eq(big_is_equal(value_01, value_02), 1);
    s21_big_decimal value_03 = {{10, 0, 0, 0, 0, 0, 0, 0, 0, 0x80000000}};
    s21_big_decimal value_04 = {{10, 0, 0, 0, 0, 0, 0, 0, 0, 0x80000000}};
    ck_assert_int_eq(big_is_equal(value_03, value_04), 1);
    s21_big_decimal value_05 = {{10, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};
    s21_big_decimal value_06 = {{100, 0, 0, 0, 0, 0, 0, 0, 0, 0x00010000}};
    ck_assert_int_eq(big_is_equal(value_05, value_06), 1);
    s21_big_decimal value_07 = {{10, 0, 456, 0, 0, 0, 0, 0, 0, 0x00000000}};
    s21_big_decimal value_08 = {{10, 0, 456, 0, 0, 0, 0, 0, 0, 0x00000000}};
    ck_assert_int_eq(big_is_equal(value_07, value_08), 1);
    s21_big_decimal value_09 = {{1000, 0, 0, 0, 0, 0, 0, 0, 0, 0x80000000}};
    s21_big_decimal value_10 = {{1000, 0, 0, 0, 0, 0, 0, 0, 0, 0x80000000}};
    ck_assert_int_eq(big_is_equal(value_09, value_10), 1);
    s21_big_decimal value_11 = {{1000, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};
    s21_big_decimal value_12 = {{100, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};
    ck_assert_int_eq(big_is_equal(value_11, value_12), 0);
    s21_big_decimal value_13 = {{100, 0, 0, 0, 0, 0, 0, 0, 0, 0x80000000}};
    s21_big_decimal value_14 = {{100, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};
    ck_assert_int_eq(big_is_equal(value_13, value_14), 0);
    s21_big_decimal value_15 = {{100, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};
    s21_big_decimal value_16 = {{100, 0, 0, 0, 0, 0, 0, 0, 0, 0x80000000}};
    ck_assert_int_eq(big_is_equal(value_15, value_16), 0);



#test BIG_IS_GREAT_OR_EQUAL
    s21_big_decimal value_01 = {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};
    s21_big_decimal value_02 = {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};
    ck_assert_int_eq(big_is_greater_or_equal(value_01, value_02), 1);
    s21_big_decimal value_03 = {{10, 0, 0, 0, 0, 0, 0, 0, 0, 0x80000000}};
    s21_big_decimal value_04 = {{10, 0, 0, 0, 0, 0, 0, 0, 0, 0x80000000}};
    ck_assert_int_eq(big_is_greater_or_equal(value_03, value_04), 1);
    s21_big_decimal value_05 = {{10, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};
    s21_big_decimal value_06 = {{100, 0, 0, 0, 0, 0, 0, 0, 0, 0x00010000}};
    ck_assert_int_eq(big_is_greater_or_equal(value_05, value_06), 1);
    s21_big_decimal value_07 = {{10, 0, 456, 0, 0, 0, 0, 0, 0, 0x00000000}};
    s21_big_decimal value_08 = {{10, 0, 456, 0, 0, 0, 0, 0, 0, 0x00000000}};
    ck_assert_int_eq(big_is_greater_or_equal(value_07, value_08), 1);
    s21_big_decimal value_09 = {{1000, 0, 0, 0, 0, 0, 0, 0, 0, 0x80000000}};
    s21_big_decimal value_10 = {{1000, 0, 0, 0, 0, 0, 0, 0, 0, 0x80000000}};
    ck_assert_int_eq(big_is_greater_or_equal(value_09, value_10), 1);



#test BIG_MUL
    s21_big_decimal result = {{0}};                                                 //  0
    s21_big_decimal value_01 = {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};           //  0
    s21_big_decimal value_02 = {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};           //  0
    s21_big_decimal correct_answer_01 = {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};  //  0
    big_decimal_reset(&result);
    ck_assert_int_eq(big_mul(value_01, value_02, &result), 0);                    //  0 * 0 = 0
    for (int i = 0; i < 10; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_01.bits[i]);
    }
    s21_big_decimal value_03 = {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};           //  0
    s21_big_decimal value_04 = {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0x80000000}};           // -0
    s21_big_decimal correct_answer_02 = {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};  //  0
    big_decimal_reset(&result);
    ck_assert_int_eq(big_mul(value_03, value_04, &result), 0);                    //  0 * (-0) = 0
    for (int i = 0; i < 10; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_02.bits[i]);
    }
    s21_big_decimal value_05 = {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};           //  0
    s21_big_decimal value_06 = {{25, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};          //  25
    s21_big_decimal correct_answer_03 = {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};  //  0
    big_decimal_reset(&result);
    ck_assert_int_eq(big_mul(value_05, value_06, &result), 0);                    //  0 * 25 = 0
    for (int i = 0; i < 10; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_03.bits[i]);
    }
    s21_big_decimal value_07 = {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};           //  0
    s21_big_decimal value_08 = {{25, 0, 0, 0, 0, 0, 0, 0, 0, 0x80000000}};          // -25
    s21_big_decimal correct_answer_04 = {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};  //  0
    big_decimal_reset(&result);
    ck_assert_int_eq(big_mul(value_07, value_08, &result), 0);                    //  0 * (-25) = 0
    for (int i = 0; i < 10; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_04.bits[i]);
    }
    s21_big_decimal value_09 = {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};           //  0
    s21_big_decimal value_10 = {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0x00FF0000}};           //  INF
    big_decimal_reset(&result);
    ck_assert_int_eq(big_mul(value_09, value_10, &result), 3);                    //  0 * INF = -NAN
    ck_assert_int_eq(big_num_is_nan(result), 1);
    s21_big_decimal value_11 = {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};           //  0
    s21_big_decimal value_12 = {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0x80FF0000}};           // -INF
    big_decimal_reset(&result);
    ck_assert_int_eq(big_mul(value_11, value_12, &result), 3);                    //  0 * (-INF) = -NAN
    ck_assert_int_eq(big_num_is_nan(result), 1);
    s21_big_decimal value_13 = {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};           //  0
    s21_big_decimal value_14 = {{1, 345, 4, 0, 0, 0, 0, 0, 0, 0x80FF0000}};         // -NAN
    big_decimal_reset(&result);
    ck_assert_int_eq(big_mul(value_13, value_14, &result), 3);                    //  0 * (-NAN) = -NAN
    ck_assert_int_eq(big_num_is_nan(result), 1);
    s21_big_decimal value_15 = {{2147483647, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};  //  2 147 483 647
    s21_big_decimal value_16 = {{0, 0, 0,0, 0, 0, 0, 0, 0,  0x00000000}};           //  0
    s21_big_decimal correct_answer_08 = {{0}};                                      //  0 
    big_decimal_reset(&result);
    ck_assert_int_eq(big_mul(value_15, value_16, &result), 0);                    //  2 147 483 647 * 0 = 0
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_08.bits[i]);
    }
    s21_big_decimal value_17 = {{2147483647, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};  //  2 147 483 647
    s21_big_decimal value_18 = {{25, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};          //  25
    s21_big_decimal correct_answer_09 = {{2147483623, 12, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};//  53 687 091 175 
    big_decimal_reset(&result);
    ck_assert_int_eq(big_mul(value_17, value_18, &result), 0);                    //  2 147 483 647 * 0 = 53 687 091 175
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_09.bits[i]);
    }
    s21_big_decimal value_19 = {{2147483647, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};  //  2 147 483 647
    s21_big_decimal value_20 = {{25, 0, 0, 0, 0, 0, 0, 0, 0, 0x80000000}};          // -25
    s21_big_decimal correct_answer_10 = {{2147483623, 12, 0, 0, 0, 0, 0, 0, 0, 0x80000000}};// -53 687 091 175 
    big_decimal_reset(&result);
    ck_assert_int_eq(big_mul(value_19, value_20, &result), 0);                    //  2 147 483 647 * (-25) = -53 687 091 175
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_10.bits[i]);
    }
    s21_big_decimal value_21 = {{2147483647, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};  //  2 147 483 647
    s21_big_decimal value_22 = {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0x00FF0000}};           //  INF
    s21_big_decimal correct_answer_11 = {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0x00FF0000}};  //  INF
    big_decimal_reset(&result);
    ck_assert_int_eq(big_mul(value_21, value_22, &result), 1);                    //  2 147 483 647 * INF = 53 687 091 175
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_11.bits[i]);
    }
    s21_big_decimal value_23 = {{2147483647, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};  //  2 147 483 647
    s21_big_decimal value_24 = {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0x80FF0000}};           // -INF
    s21_big_decimal correct_answer_12 = {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0x80FF0000}};  // -INF
    big_decimal_reset(&result);
    ck_assert_int_eq(big_mul(value_23, value_24, &result), 2);                    //  2 147 483 647 * (-INF) = -INF
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_12.bits[i]);
    }
    s21_big_decimal value_25 = {{2147483647, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};  //  2 147 483 647
    s21_big_decimal value_26 = {{12, 232, 0, 0, 0, 0, 0, 0, 0, 0x00FF0000}};        //  NAN
    big_decimal_reset(&result);
    ck_assert_int_eq(big_mul(value_25, value_26, &result), 3);                    //  2 147 483 647 * NAN = -NAN
    ck_assert_int_eq(big_num_is_nan(result), 1);
    
    s21_big_decimal value_27 = {{2147483647, 0, 0, 0, 0, 0, 0, 0, 0, 0x80000000}};  // -2 147 483 647
    s21_big_decimal value_28 = {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};           //  0
    s21_big_decimal correct_answer_14 = {{0}};                                      //  0 
    big_decimal_reset(&result);
    ck_assert_int_eq(big_mul(value_27, value_28, &result), 0);                    // -2 147 483 647 * 0 = 0
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_14.bits[i]);
    }
    s21_big_decimal value_29 = {{2147483647, 0, 0, 0, 0, 0, 0, 0, 0, 0x80000000}};  // -2 147 483 647
    s21_big_decimal value_30 = {{25, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};          //  25
    s21_big_decimal correct_answer_15 = {{2147483623, 12, 0, 0, 0, 0, 0, 0, 0, 0x80000000}};// -53 687 091 175 
    big_decimal_reset(&result);
    ck_assert_int_eq(big_mul(value_29, value_30, &result), 0);                    // -2 147 483 647 * 25 = -53 687 091 175
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_15.bits[i]);
    }
    s21_big_decimal value_31 = {{2147483647, 0, 0, 0, 0, 0, 0, 0, 0, 0x80000000}};  // -2 147 483 647
    s21_big_decimal value_32 = {{25, 0, 0, 0, 0, 0, 0, 0, 0, 0x80000000}};          // -25
    s21_big_decimal correct_answer_16 = {{2147483623, 12, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};//  53 687 091 175 
    big_decimal_reset(&result);
    ck_assert_int_eq(big_mul(value_31, value_32, &result), 0);                    // -2 147 483 647 * (-25) = 53 687 091 175
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_16.bits[i]);
    }
    s21_big_decimal value_33 = {{2147483647, 0, 0, 0, 0, 0, 0, 0, 0, 0x80000000}};  // -2 147 483 647
    s21_big_decimal value_34 = {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0x00FF0000}};           //  INF
    s21_big_decimal correct_answer_17 = {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0x80FF0000}};  // -INF
    big_decimal_reset(&result);
    ck_assert_int_eq(big_mul(value_33, value_34, &result), 2);                    // -2 147 483 647 * INF = -INF
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_17.bits[i]);
    }
    s21_big_decimal value_35 = {{2147483647, 0, 0, 0, 0, 0, 0, 0, 0, 0x80000000}};  // -2 147 483 647
    s21_big_decimal value_36 = {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0x80FF0000}};           // -INF
    s21_big_decimal correct_answer_18 = {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0x00FF0000}};  //  INF
    big_decimal_reset(&result);
    ck_assert_int_eq(big_mul(value_35, value_36, &result), 1);                    // -2 147 483 647 * (-INF) =  INF
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_18.bits[i]);
    }
    s21_big_decimal value_37 = {{2147483647, 0, 0, 0, 0, 0, 0, 0, 0, 0x80000000}};  // -2 147 483 647
    s21_big_decimal value_38 = {{12, 232, 0, 0, 0, 0, 0, 0, 0, 0x00FF0000}};        //  NAN
    big_decimal_reset(&result);
    ck_assert_int_eq(big_mul(value_37, value_38, &result), 3);                    //  2 147 483 647 * NAN = -NAN
    ck_assert_int_eq(big_num_is_nan(result), 1);
    s21_big_decimal value_39 = {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0x00FF0000}};           //  INF
    s21_big_decimal value_40 = {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};           //  0
    big_decimal_reset(&result);
    ck_assert_int_eq(big_mul(value_39, value_40, &result), 3);                    //  INF * 0 = -NAN
    ck_assert_int_eq(big_num_is_nan(result), 1);
    s21_big_decimal value_41 = {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0x00FF0000}};           //  INF
    s21_big_decimal value_42 = {{25, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};          //  25
    s21_big_decimal correct_answer_21 = {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0x00FF0000}};  //  INF
    big_decimal_reset(&result);
    ck_assert_int_eq(big_mul(value_41, value_42, &result), 1);                    //  INF * 25 = INF
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_21.bits[i]);
    }
    s21_big_decimal value_43 = {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0x00FF0000}};           //  INF
    s21_big_decimal value_44 = {{25, 0, 0, 0, 0, 0, 0, 0, 0, 0x80000000}};          //  -25
    s21_big_decimal correct_answer_22 = {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0x80FF0000}};  // -INF
    big_decimal_reset(&result);
    ck_assert_int_eq(big_mul(value_43, value_44, &result), 2);                    //  INF * (-25) = -INF
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_22.bits[i]);
    }
    s21_big_decimal value_45 = {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0x00FF0000}};           //  INF
    s21_big_decimal value_46 = {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0x00FF0000}};           //  INF
    s21_big_decimal correct_answer_23 = {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0x00FF0000}};  //  INF
    big_decimal_reset(&result);
    ck_assert_int_eq(big_mul(value_45, value_46, &result), 1);                    //  INF * INF = INF
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_23.bits[i]);
    }
    s21_big_decimal value_47 = {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0x00FF0000}};           //  INF
    s21_big_decimal value_48 = {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0x80FF0000}};           // -INF
    s21_big_decimal correct_answer_24 = {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0x80FF0000}};  // -INF
    big_decimal_reset(&result);
    ck_assert_int_eq(big_mul(value_47, value_48, &result), 2);                    //  INF * -INF = -INF
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_24.bits[i]);
    }
    s21_big_decimal value_49 = {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0x00FF0000}};           //  INF
    s21_big_decimal value_50 = {{1, 0, 230, 0, 0, 0, 0, 0, 0, 0x80FF0000}};         // -NAN
    big_decimal_reset(&result);
    ck_assert_int_eq(big_mul(value_49, value_50, &result), 3);                    //  INF * -NAN = -NAN
    ck_assert_int_eq(big_num_is_nan(result), 1);
    s21_big_decimal value_51 = {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0x80FF0000}};           // -INF
    s21_big_decimal value_52 = {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};           //  0
    big_decimal_reset(&result);
    ck_assert_int_eq(big_mul(value_51, value_52, &result), 3);                    // -INF * 0 = -NAN
    ck_assert_int_eq(big_num_is_nan(result), 1);
    s21_big_decimal value_53 = {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0x80FF0000}};           // -INF
    s21_big_decimal value_54 = {{25, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};          //  25
    s21_big_decimal correct_answer_27 = {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0x80FF0000}};  // -INF
    big_decimal_reset(&result);
    ck_assert_int_eq(big_mul(value_53, value_54, &result), 2);                    // -INF * 25 = -INF
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_27.bits[i]);
    }
    s21_big_decimal value_55 = {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0x80FF0000}};           // -INF
    s21_big_decimal value_56 = {{25, 0, 0, 0, 0, 0, 0, 0, 0, 0x80000000}};          // -25
    s21_big_decimal correct_answer_28 = {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0x00FF0000}};  //  INF
    big_decimal_reset(&result);
    ck_assert_int_eq(big_mul(value_55, value_56, &result), 1);                    // -INF * (-25) = INF
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_28.bits[i]);
    }
    s21_big_decimal value_57 = {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0x80FF0000}};           // -INF
    s21_big_decimal value_58 = {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0x00FF0000}};           //  INF
    s21_big_decimal correct_answer_29 = {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0x80FF0000}};  // -INF
    big_decimal_reset(&result);
    ck_assert_int_eq(big_mul(value_57, value_58, &result), 2);                    // -INF * INF = -INF
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_29.bits[i]);
    }
    s21_big_decimal value_59 = {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0x80FF0000}};           // -INF
    s21_big_decimal value_60 = {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0x80FF0000}};           // -INF
    s21_big_decimal correct_answer_30 = {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0x00FF0000}};  //  INF
    big_decimal_reset(&result);
    ck_assert_int_eq(big_mul(value_59, value_60, &result), 1);                    // -INF * -INF = INF
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_30.bits[i]);
    }
    s21_big_decimal value_61 = {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0x80FF0000}};           // -INF
    s21_big_decimal value_62 = {{1, 0, 230, 0, 0, 0, 0, 0, 0, 0x80FF0000}};         // -NAN
    big_decimal_reset(&result);
    ck_assert_int_eq(big_mul(value_61, value_62, &result), 3);                    // -INF * -NAN = -NAN
    ck_assert_int_eq(big_num_is_nan(result), 1);
    s21_big_decimal value_63 = {{1, 0, 230, 0, 0, 0, 0, 0, 0, 0x80FF0000}};         // -NAN
    s21_big_decimal value_64 = {{1, 0, 230, 0, 0, 0, 0, 0, 0, 0x80FF0000}};         // -NAN
    big_decimal_reset(&result);
    ck_assert_int_eq(big_mul(value_63, value_64, &result), 3);                    // -INF * -NAN = -NAN
    ck_assert_int_eq(big_num_is_nan(result), 1);



#test BIG_MUL_BY_TEN
    // s21_big_decimal result = {{0}};                                                 //  0
    s21_big_decimal value_01 = {{5000, 0, 0, 0, 0, 0, 0, 0, 0, 0x80000000}};           //  0
    s21_big_decimal value_02 = {{5000, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};           //  0
    s21_big_decimal value_03 = {{5000, 0, 0, 0, 0, 0, 0, 0, 0, 0x80020000}};           //  0
    s21_big_decimal value_04 = {{5000, 0, 0, 0, 0, 0, 0, 0, 0, 0x00020000}};           //  0
    s21_big_decimal value_05 = {{5000, 0, 0, 0, 0, 0, 0, 0, 4134567987, 0x00020000}};           //  0
    s21_big_decimal value_06 = {{5000, 0, 0, 0, 0, 0, 0, 0, 4134567987, 0x80020000}};           //  0
    s21_big_decimal correct_answer_01 = {{50000, 0, 0, 0, 0, 0, 0, 0, 0, 0x80010000}};  //  0
    s21_big_decimal correct_answer_02 = {{50000, 0, 0, 0, 0, 0, 0, 0, 0, 0x00010000}};  //  0
    s21_big_decimal correct_answer_03 = {{500000, 0, 0, 0, 0, 0, 0, 0, 0, 0x80040000}};  //  0
    s21_big_decimal correct_answer_04 = {{500000, 0, 0, 0, 0, 0, 0, 0, 0, 0x00040000}};  //  0
    s21_big_decimal correct_answer_05 = {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0x00FF0000}};  //  0
    s21_big_decimal correct_answer_06 = {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0x80FF0000}};  //  0
    // big_decimal_reset(&result);
    ck_assert_int_eq(big_mul_by_ten(&value_01, 1), 0);
    for (int i = 0; i < 10; i++) {
        ck_assert_int_eq(value_01.bits[i], correct_answer_01.bits[i]);
    }
    ck_assert_int_eq(big_mul_by_ten(&value_02, 1), 0);
    for (int i = 0; i < 10; i++) {
        ck_assert_int_eq(value_02.bits[i], correct_answer_02.bits[i]);
    }
    ck_assert_int_eq(big_mul_by_ten(&value_03, 2), 0);
    for (int i = 0; i < 10; i++) {
        ck_assert_int_eq(value_03.bits[i], correct_answer_03.bits[i]);
    }
    ck_assert_int_eq(big_mul_by_ten(&value_04, 2), 0);
    for (int i = 0; i < 10; i++) {
        ck_assert_int_eq(value_04.bits[i], correct_answer_04.bits[i]);
    }
    ck_assert_int_eq(big_mul_by_ten(&value_05, 3), 1);
    for (int i = 0; i < 10; i++) {
        ck_assert_int_eq(value_05.bits[i], correct_answer_05.bits[i]);
    }
    ck_assert_int_eq(big_mul_by_ten(&value_06, 3), 1);
    for (int i = 0; i < 10; i++) {
        ck_assert_int_eq(value_06.bits[i], correct_answer_06.bits[i]);
    }



#test BIG_DIV_RESULT_INT
    s21_big_decimal result = {{0}};                                                 //  0
    s21_big_decimal value_01 = {{9, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};           //  0
    s21_big_decimal value_02 = {{3, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};           //  0
    s21_big_decimal correct_answer_01 = {{3, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};  //  0
    big_decimal_reset(&result);
    ck_assert_int_eq(big_div_result_int(value_01, value_02, &result), 0);                    //  0 * 0 = 0
    for (int i = 0; i < 10; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_01.bits[i]);
    }
    // s21_big_decimal result = {{0}};                                                 //  0
    s21_big_decimal value_03 = {{10, 0, 0, 0, 0, 0, 0, 0, 0, 0x80000000}};           //  0
    s21_big_decimal value_04 = {{3, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};           //  0
    s21_big_decimal correct_answer_02 = {{3, 0, 0, 0, 0, 0, 0, 0, 0, 0x80000000}};  //  0
    big_decimal_reset(&result);
    ck_assert_int_eq(big_div_result_int(value_03, value_04, &result), 0);                    //  0 * 0 = 0
    for (int i = 0; i < 10; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_02.bits[i]);
    }
    s21_big_decimal value_05 = {{3, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};           //  0
    s21_big_decimal value_06 = {{9, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};           //  0
    s21_big_decimal correct_answer_03 = {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};  //  0
    big_decimal_reset(&result);
    ck_assert_int_eq(big_div_result_int(value_05, value_06, &result), 0);                    //  0 * 0 = 0
    for (int i = 0; i < 10; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_03.bits[i]);
    }
    s21_big_decimal value_07 = {{30, 0, 0, 0, 0, 0, 0, 0, 0, 0x00010000}};           //  0
    s21_big_decimal value_08 = {{9, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};           //  0
    s21_big_decimal correct_answer_04 = {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};  //  0
    big_decimal_reset(&result);
    ck_assert_int_eq(big_div_result_int(value_07, value_08, &result), 0);                    //  0 * 0 = 0
    for (int i = 0; i < 10; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_04.bits[i]);
    }
    s21_big_decimal value_09 = {{30, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};           //  0
    s21_big_decimal value_10 = {{9, 0, 0, 0, 0, 0, 0, 0, 0, 0x80010000}};           //  0
    s21_big_decimal correct_answer_05 = {{33, 0, 0, 0, 0, 0, 0, 0, 0, 0x80000000}};  //  0
    big_decimal_reset(&result);
    ck_assert_int_eq(big_div_result_int(value_09, value_10, &result), 0);                    //  0 * 0 = 0
    for (int i = 0; i < 10; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_05.bits[i]);
    }
    s21_big_decimal value_11 = {{30, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};           //  0
    s21_big_decimal value_12 = {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0x80000000}};           //  0
    // s21_big_decimal correct_answer_06 = {{0}};  //  0
    big_decimal_reset(&result);
    ck_assert_int_eq(big_div_result_int(value_11, value_12, &result), 3);                    //  0 * 0 = 0
    ck_assert_int_eq(big_num_is_nan(result), 1);                    //  0 * 0 = 0
    s21_big_decimal value_13 = {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};           //  0
    s21_big_decimal value_14 = {{30, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};           //  0
    s21_big_decimal correct_answer_07 = {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};  //  0
    big_decimal_reset(&result);
    ck_assert_int_eq(big_div_result_int(value_13, value_14, &result), 0);                    //  0 * 0 = 0
    for (int i = 0; i < 10; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_07.bits[i]);
    }
    s21_big_decimal value_15 = {{30, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};           //  0
    s21_big_decimal value_16 = {{30, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};           //  0
    s21_big_decimal correct_answer_08 = {{1, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};  //  0
    big_decimal_reset(&result);
    ck_assert_int_eq(big_div_result_int(value_15, value_16, &result), 0);                    //  0 * 0 = 0
    for (int i = 0; i < 10; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_08.bits[i]);
    }



#test BIG_TRUNCATE
    s21_big_decimal result = {{0}};
    s21_big_decimal value_01 = {{543, 0, 0, 0, 0, 0, 0, 0, 0, 0x80050000}};                           // -0,00543 => -0
    s21_big_decimal value_02 = {{543, 0, 0, 0, 0, 0, 0, 0, 0, 0x00050000}};                           //  0,00543 => 0
    s21_big_decimal correct_answer_01 = {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0x80000000}};                    // -0
    s21_big_decimal correct_answer_02 = {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};                    //  0
    big_decimal_reset(&result);
    ck_assert_int_eq(big_truncate(value_01, &result), 0);                     // -0
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_01.bits[i]);
    }
    big_decimal_reset(&result);
    ck_assert_int_eq(big_truncate(value_02, &result), 0);                     //  0
    for (int i = 0; i < 4; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_02.bits[i]);
    }

#test BIG_ADDITION_ACTION
    s21_big_decimal result = {{0}};
    s21_big_decimal value_01_1 = {{4, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};
    s21_big_decimal value_01_2 = {{4, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};
    s21_big_decimal correct_answer_01 = {{8, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};
    s21_big_decimal value_02_1 = {{6, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};
    s21_big_decimal value_02_2 = {{40, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};
    s21_big_decimal correct_answer_02 = {{46, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};
    big_addition_action(value_01_1, value_01_2, &result);
    for (int i = 0; i < 10; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_01.bits[i]);
    }
    big_addition_action(value_02_1, value_02_2, &result);
    for (int i = 0; i < 10; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_02.bits[i]);
    }

#test BIG_SUBTRACTION_ACTION
    s21_big_decimal result = {{0}};
    s21_big_decimal value_01_1 = {{4, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};
    s21_big_decimal value_01_2 = {{2, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};
    s21_big_decimal correct_answer_01 = {{2, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};
    s21_big_decimal value_02_1 = {{90, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};
    s21_big_decimal value_02_2 = {{45, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};
    s21_big_decimal correct_answer_02 = {{45, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};
    s21_big_decimal value_03_1 = {{9856, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};
    s21_big_decimal value_03_2 = {{9856, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};
    s21_big_decimal correct_answer_03 = {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};
    big_subtraction_action(value_01_1, value_01_2, &result);
    for (int i = 0; i < 10; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_01.bits[i]);
    }
    big_subtraction_action(value_02_1, value_02_2, &result);
    for (int i = 0; i < 10; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_02.bits[i]);
    }
    big_subtraction_action(value_03_1, value_03_2, &result);
    for (int i = 0; i < 10; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_03.bits[i]);
    }

#test BIG_DIVISION_ACTION
    s21_big_decimal result = {{0}};
    s21_big_decimal value_01_1 = {{8, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};
    s21_big_decimal value_01_2 = {{4, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};
    s21_big_decimal correct_answer_01 = {{2, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};
    s21_big_decimal value_02_1 = {{135, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};
    s21_big_decimal value_02_2 = {{45, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};
    s21_big_decimal correct_answer_02 = {{3, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};
    s21_big_decimal value_03_1 = {{9015, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};
    s21_big_decimal value_03_2 = {{3, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};
    s21_big_decimal correct_answer_03 = {{3005, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};
    s21_big_decimal value_04_1 = {{111, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};
    s21_big_decimal value_04_2 = {{22, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};
    s21_big_decimal correct_answer_04 = {{5, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};
    s21_big_decimal value_05_1 = {{99, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};
    s21_big_decimal value_05_2 = {{10, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};
    s21_big_decimal correct_answer_05 = {{9, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};
    s21_big_decimal value_06_1 = {{3687, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};
    s21_big_decimal value_06_2 = {{328, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};
    s21_big_decimal correct_answer_06 = {{11, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};
    s21_big_decimal value_07_1 = {{3687, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};
    s21_big_decimal value_07_2 = {{328, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};
    s21_big_decimal correct_answer_07 = {{79, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};
    s21_big_decimal value_08_1 = {{3687, 0, 0, 0, 0, 0, 0, 0, 0, 0x00020000}};
    s21_big_decimal value_08_2 = {{328, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};
    s21_big_decimal correct_answer_08 = {{79, 0, 0, 0, 0, 0, 0, 0, 0, 0x00020000}};
    s21_big_decimal value_09_1 = {{3687, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};
    s21_big_decimal value_09_2 = {{328, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};
    s21_big_decimal correct_answer_09 = {{79, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};
    s21_big_decimal value_10_1 = {{50, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};
    s21_big_decimal value_10_2 = {{45, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};
    s21_big_decimal correct_answer_10 = {{5, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};
    s21_big_decimal value_11_1 = {{7777, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};
    s21_big_decimal value_11_2 = {{10, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};
    s21_big_decimal correct_answer_11 = {{777, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};
    s21_big_decimal value_12_1 = {{6666, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};
    s21_big_decimal value_12_2 = {{10, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};
    s21_big_decimal correct_answer_12 = {{6, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};
    big_division_action(value_01_1, value_01_2, &result, 0);
    for (int i = 0; i < 10; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_01.bits[i]);
    }
    big_decimal_reset(&result);
    ck_assert_int_eq(big_division_action(value_02_1, value_02_2, &result, 0), 0);
    for (int i = 0; i < 10; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_02.bits[i]);
    }
    big_decimal_reset(&result);
    ck_assert_int_eq(big_division_action(value_03_1, value_03_2, &result, 0), 0);
    for (int i = 0; i < 10; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_03.bits[i]);
    }
    big_decimal_reset(&result);
    ck_assert_int_eq(big_division_action(value_04_1, value_04_2, &result, 0), 0);
    for (int i = 0; i < 10; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_04.bits[i]);
    }
    big_decimal_reset(&result);
    ck_assert_int_eq(big_division_action(value_05_1, value_05_2, &result, 1), 0);
    for (int i = 0; i < 10; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_05.bits[i]);
    }
    big_decimal_reset(&result);
    ck_assert_int_eq(big_division_action(value_06_1, value_06_2, &result, 0), 0);
    for (int i = 0; i < 10; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_06.bits[i]);
    }
    big_decimal_reset(&result);
    ck_assert_int_eq(big_division_action(value_07_1, value_07_2, &result, 1), 0);
    for (int i = 0; i < 10; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_07.bits[i]);
    }
    big_decimal_reset(&result);
    ck_assert_int_eq(big_division_action(value_08_1, value_08_2, &result, 1), 0);
    for (int i = 0; i < 10; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_08.bits[i]);
    }
    big_decimal_reset(&result);
    ck_assert_int_eq(big_division_action(value_09_1, value_09_2, &result, 1), 0);
    for (int i = 0; i < 10; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_09.bits[i]);
    }
    big_decimal_reset(&result);
    ck_assert_int_eq(big_division_action(value_10_1, value_10_2, &result, 1), 0);
    for (int i = 0; i < 10; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_10.bits[i]);
    }
    big_decimal_reset(&result);
    ck_assert_int_eq(big_division_action(value_11_1, value_11_2, &result, 0), 0);
    for (int i = 0; i < 10; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_11.bits[i]);
    }
    big_decimal_reset(&result);
    ck_assert_int_eq(big_division_action(value_12_1, value_12_2, &result, 1), 0);
    for (int i = 0; i < 10; i++) {
        ck_assert_int_eq(result.bits[i], correct_answer_12.bits[i]);
    }



    #test BIG_DIGITS_IN_MANTIS
    s21_big_decimal value_01 = {{8, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};
    s21_big_decimal value_02 = {{657890, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};
    s21_big_decimal value_03 = {{4294967295, 4294967295, 4294967295, 1, 0, 0, 0, 0, 0, 0x00000000}};
    s21_big_decimal value_04 = {{50000, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};
    ck_assert_int_eq(big_digits_in_mantis(value_01), 1);
    ck_assert_int_eq(big_digits_in_mantis(value_02), 6);
    ck_assert_int_eq(big_digits_in_mantis(value_03), 30);
    ck_assert_int_eq(big_digits_in_mantis(value_04), 5);
    


#test BIG_DIV_BY_TEN_CHANGE_SCALE
    s21_big_decimal value_01 = {{67, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};
    s21_big_decimal value_02 = {{41234567, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};
    s21_big_decimal value_03 = {{2544814102, 4294967168, 4294967295, 3567587327, 232, 0, 0, 0, 0, 0x00000000}};    // 79 228 162 514 264 337 593 543 950 335 452 789 000 214 = 11101000  11010100 10100101 00001111 11111111  11111111 11111111 11111111 11111111  11111111 11111111 11111111 10000000  10010111 10101110 11001000 00010110
    s21_big_decimal value_04 = {{2544814102, 4294967168, 4294967295, 3567587327, 232, 0, 0, 0, 0, 0x00240000}};    // 79 228, 162 514 264 337 593 543 950 335 452 789 000 214 = 11101000  11010100 10100101 00001111 11111111  11111111 11111111 11111111 11111111  11111111 11111111 11111111 10000000  10010111 10101110 11001000 00010110
    s21_big_decimal value_05 = {{4294967295, 0, 0, 0, 0, 0, 0, 0, 0, 0x00030000}};    // 4 294 967,295
    s21_big_decimal value_06 = {{4294967295, 0, 0, 0, 0, 0, 0, 0, 0, 0x00030000}};    // 4 294 967, 295
    s21_big_decimal correct_answer_01 = {{6, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};
    s21_big_decimal correct_answer_02 = {{412, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};
    s21_big_decimal correct_answer_03 = {{79228, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};                             // 79 228
    s21_big_decimal correct_answer_04 = {{79228162, 0, 0, 0, 0, 0, 0, 0, 0, 0x00030000}};                             // 79 228
    s21_big_decimal correct_answer_05 = {{4294967, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};                             // 79 228
    s21_big_decimal correct_answer_06 = {{4294, 0, 0, 0, 0, 0, 0, 0, 0, 0x00000000}};                             // 79 228
    big_div_by_ten_change_scale(&value_01, 1);
    for (int i = 0; i < 10; i++) {
        ck_assert_int_eq(value_01.bits[i], correct_answer_01.bits[i]);
    }
    big_div_by_ten_change_scale(&value_02, 5);
    for (int i = 0; i < 10; i++) {
        ck_assert_int_eq(value_02.bits[i], correct_answer_02.bits[i]);
    }
    big_div_by_ten_change_scale(&value_03, 36);
    for (int i = 0; i < 10; i++) {
        ck_assert_int_eq(value_03.bits[i], correct_answer_03.bits[i]);
    }
    big_div_by_ten_change_scale(&value_04, 33);
    for (int i = 0; i < 10; i++) {
        ck_assert_int_eq(value_04.bits[i], correct_answer_04.bits[i]);
    }
    big_div_by_ten_change_scale(&value_05, 3);
    for (int i = 0; i < 10; i++) {
        ck_assert_int_eq(value_05.bits[i], correct_answer_05.bits[i]);
    }
    big_div_by_ten_change_scale(&value_06, 6);
    for (int i = 0; i < 10; i++) {
        ck_assert_int_eq(value_06.bits[i], correct_answer_06.bits[i]);
    }
    